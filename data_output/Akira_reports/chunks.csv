text|source|chunk_id
Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers TOSHINORI USUI, NTT Secure Platform Laboratories/Institute of Industrial Science, The University of Tokyo, Japan|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|8f9ffe4ca7a642a8b8b10de05bcebdb1
YUTO OTSUKI, TOMONORI IKUSE, YUHEI KAWAKOYA, MAKOTO IWAMURA, and JUN MIYOSHI, NTT Secure Platform Laboratories, Japan KANTA MATSUURA, Institute of Industrial Science, The University of Tokyo, Japan Script languages are designed to be easy-to-use and require low learning costs. These features provide attackers options to choose a script language for developing their malicious scripts. This diversity of choice in the attacker side unexpectedly imposes a significant cost on the preparation for analysis tools in the defense side. That is, we have to prepare for multiple script languages to analyze malicious scripts written in them. We call this unbalanced cost for script languages asymmetry problem. To solve this problem, we propose a method for automatically detecting the hook and tap points in a script engine binary that is essential for building a script Application Programming Interface (API) tracer. Our method allows us to reduce the cost of reverse engineering of a script engine binary, which is the largest portion of the development of a script API tracer, and build a script API tracer for a script language with minimum manual intervention. This advantage results in solving the asymmetry problem. The experimental results showed that our method generated the script API tracers for the three script languages popular among attackers (Visual Basic for Applications (VBA), Microsoft Visual Basic Scripting Edition (VBScript), and PowerShell).|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|ceab321aaa874c8c88880d3377427a0e
The results also demonstrated that these script API tracers successfully analyzed real-world malicious scripts. CCS Concepts: • Security and privacy → Malware and its mitigation; Software reverse engineering; • Software and its engineering → Simulator / interpreter; • Computing methodologies → Optimization algorithms; Additional Key Words and Phrases: Malicious script, dynamic analysis, reverse engineering, function enhancement ACM Reference format: Toshinori Usui, Yuto Otsuki, Tomonori Ikuse, Yuhei Kawakoya, Makoto Iwamura, Jun Miyoshi, and Kanta Matsuura. 2021. Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers. Digit. Threat. : Res. Pract. 2, 1, Article 5 (January 2021), 31 pages. https://doi.org/10.1145/3416126|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|a1365391633d4e13886e07744698bf0f
"Presently, Y. Otsuki is with NTT Security (Japan) KK, Japan. This work was partially supported by JSPS KAKENHI Grant Number JP17KT0081. Authors’ addresses: T. Usui, NTT Secure Platform Laboratories/Institute of Industrial Science, The University of Tokyo, 3-9-11 Midoricho, Musashino-shi, Tokyo, Japan, 180-8585; email: toshinori.usui.rt@hco.ntt.co.jp; Y. Otsuki, T. Ikuse, Y. Kawakoya, M. Iwamura, and J. Miyoshi, NTT Secure Platform Laboratories, Japan; emails: yuuto.ootsuki.uh@hco.ntt.co.jp, tomonori.ikuse.ez@hco.ntt.co.jp, yuuhei.kawakoya.sy@hco.ntt.co.jp, makoto.iwamura.sw@hco.ntt.co.jp, jun.miyoshi.fu@hco.ntt.co.jp; K. Matsuura, Institute of Industrial Science, The University of Tokyo, 4-6-1 Komaba, Meguro-ku, Tokyo, Japan, 153-8505; email: kanta@iis.u-tokyo.ac.jp.

This work is licensed under a Creative Commons Attribution-Share Alike International 4.0 License.

© 2021 Copyright held by the owner/author(s). 2576-5337/2021/01-ART5 https://doi.org/10.1145/3416126 Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

5

5:2 •

1

T. Usui et al.

INTRODUCTION"|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|2b7ec023443342e0a0c17dd3e0b08c4a
"5

5:2 •

1

T. Usui et al.

INTRODUCTION

The diversity of script languages creates a blind spot for malicious scripts to hide from analysis and detection. Attackers can flexibly choose a script language to develop a module of their malicious scripts and change scripts for developing another module of them. However, we (security side) are not always well-prepared for any script languages since the development of analysis tools for even a single script language incurs a certain cost. We call this gap of costs between attackers and defenders the asymmetry problem. This asymmetry problem provides attackers an advantage in evading the security of their target systems. That is, an attacker can choose one script language for which a target organization may not be well-prepared to develop malicious scripts for attacking the system without detection. One approach for solving this asymmetry problem is focusing on system-level monitoring such as Windows Application Programming Interfaces (APIs) or system calls. We can universally monitor the behavior of malicious scripts no matter what script languages the malicious scripts are written in if we set hooks for monitoring at the system-level. As long as malicious scripts run on a Windows platform, it has to more or less depend on Windows APIs or system calls to perform certain actions. If we set hooks on each API and monitor the invocations of those APIs from malicious scripts, we can probably comprehend the behavior of these scripts."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|48abe98cc4674017b95c327e7aeafab5
However, this systemlevel monitoring approach is not sufficient from the viewpoint of analysis efficiency because some script API calls do not reach any system APIs, such as string or object operations. That is, we do not always capture the complete behavior of malicious scripts running on the platform. This lack of captures results in partial understanding of malicious scripts and leads to underestimating the threat of such scripts. Another approach for malicious script analysis is focusing on a specific language and embedding monitoring mechanisms into a runtime environment of the script. This approach resolves the semantic gap problem mentioned above but requires deep domain knowledge to develop a monitoring tool. For example, we have to know both the specifications of a script language and the internal architecture of the script engine to develop a dynamic analysis tool for the script. In addition, this approach supports only a target script language. That is, we need to develop an analysis tool for each script language separately. In summary, we (security side) need an approach universally applicable for any script languages and finegrained enough for analyzing the detailed behavior of a malicious script. However, previous studies satisfied only either of these requirements at the same time. To mitigate the gap between attackers and defenders, we propose a method of generating script API tracers with a small amount of human intervention.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|5e6f11e3fa3b4ef5800b4dfac0ae454d
The basic idea of our method is to eliminate the knowledge of script engine internals from the requirements for developing analysis tools for a script language. Instead, we complement this knowledge with several test programs written in the script language (test scripts) and run them on the script engine for differential execution analysis [8, 57] to clarify the local functions corresponding to the script APIs, which are usually acquired with the manual analysis of the script engine. Bravely speaking, our method allows us to replace the knowledge of script engine internals with one of the specifications of the script for writing test scripts. Our method is composed of five steps: execution trace logging, hook point detection, tap point detection, hook and tap point verification, and script API tracer generation. The most important function of our method is detecting points called hook points in which the method inserts hooks to append code to script engines for script analysis as well as points called tap points, which are memory regions logged by the code for analysis. Our method first acquires branch traces by executing manually crafted scripts called test scripts, each of which only calls a specific script API of the analysis target. Our method then obtains hook and tap points that correspond to the target script API by analyzing the obtained branch trace with the differential execution analysis-based hook point detection method.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|b4d25e732aad43528091284ae782d9b8
"Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:3"|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|6dd94ef7f72d46b28ff0360dedf58e66
"5:3

Note that we define a script API as a callable functionality provided by a script engine. For example, each builtin function and statement of Visual Basic for Applications (VBA) and Microsoft Visual Basic Scripting Edition (VBScript), such as CreateObject and Eval, and commandlets (Cmdlets) of PowerShell, such as Invoke-Expression, are script APIs. A challenge in this research was efficiently finding the local function that corresponds to the target script API from the large number of local functions of a script engine binary. We addressed this challenge by emphasizing the local function corresponding to the target script API as the difference in branch traces of two scripts that call the target script API different times. To achieve this differentiation, we modified the Smith-Waterman algorithm [44] borrowed from bioinformatics, which finds a similar common subsequence from two or more sequences, to fit it to this problem. Our method does not allow us to directly fulfill the second requirement, i.e., universal applicability. However, we believe that our method allows us to reduce the cost of developing an analysis tool for each script language. Therefore, we can lower the bar for preparing analysis tools for any script languages. We implemented a prototype system that uses our method called STAGER, a script analyzer generator based on engine reversing, for evaluating the method. We conducted experiments on STAGER with VBA, VBScript, and PowerShell."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|ecadde8e51cd41cf8485ad04e7bab5c7
The experimental results indicate that our method can precisely detect hook and tap points and generate script API tracers that can output analysis logs containing script semantics. The hook and tap points are detected within a few tens of seconds. Using the STAGER-generated script API tracers, we analyzed real-world malicious scripts obtained from VirusTotal [1], a malware sharing service for research. The output logs showed that the script API tracers could effectively analyze malicious scripts in a short time. Our method enables the generation of a script API tracer for proprietary script languages for which existing methods cannot construct analysis tools. It can therefore contribute to providing better protection against malicious scripts. Our contributions are as follows. — We first propose a method that generates a script API tracer by analyzing the script engine binaries. — We confirmed that our method can accurately detect hook and tap points within realistic time through experiments. In addition, our method only requires tens of seconds of human intervention for analyzing a script API. — We showed that the script API tracers generated with our method can provide information useful for analysts by analyzing malicious scripts in the wild. This article is an extended version of our previous work [48].|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|1c5e2d98adbd46538635c5af23abbef5
"2 BACKGROUND AND MOTIVATION 2.1 Motivating Example Our running example is a malicious script collected from VirusTotal, and its analysis logs acquired using several different script analysis tools. Note that the script analysis tools in this section include all tools that can extract the behavior of scripts regardless of whether they were explicitly designed to analyze scripts. Therefore, system API tracers are included in the script analysis tools in the subsequent sections. Figure 1 shows a malicious script and acquired analysis logs corresponding to it. The upper left, Figure 1(a) shows an excerpt of this malicious script that has more than 1,000 lines of code. As shown in the figure, the malicious script is heavily obfuscated; thus, static analysis is difficult. The upper right, Figure 1(b) shows the deobfuscated script obtained from manual analysis. Since analysts can easily comprehend the behavior of the malicious script, it would be ideal as the analysis log. However, manually analyzing such malicious script is tedious and time consuming and is sometimes nearly impossible depending on the heaviness of the obfuscation. The lower left, Figure 1(c) shows an excerpt of the system API trace log obtained by attaching a system API tracer called API Monitor [5] to the script engine process. This log contains a large number of system API calls that Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

5:4 •

T. Usui et al."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|d5ffa0b39345496d8844b9a8f4376e93
"5:4 •

T. Usui et al.

Fig. 1. Obfuscated malicious script and its analysis logs acquired from several different script analysis tools.

are both relevant and irrelevant to the malicious script. The irrelevant calls are involved in the script engine. Some system API calls that are relevant to remote procedure calls (e.g., component object model (COM) and Windows Management Instrumentation (WMI)) by the malicious script and the ones that are only handled in the script engine (e.g., eval) do not appear in the log. These prevent analysts from comprehending the behavior of the malicious script; therefore, the system API tracer is not appropriate for analyzing malicious scripts. The lower right, Figure 1(d) shows the script API trace log that we aim to create with our method. This log has similar semantics to the one from manual analysis in which analysts can comprehend its behavior through it. Therefore, script API tracers are essential for malicious script analysis. However, building such script API tracer is difficult as discussed in detail in Section 2.3.3. Thus, our goal is to propose a method for easily and systematically building script API tracers that can acquire such logs."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|258dabd4dc6d4fd6bfb4e8794cb51af6
"2.2 Requirements of Script Analysis Tool We clarify the three requirements that script analysis tools should fulfill from the perspective of malicious script analysis. (1) Universal applicability. Attackers use various script languages to create their malicious scripts. Hence, methods for constructing script analysis tools (hereafter, construction methods) should be applicable to various languages with diverse language specifications. Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:5"|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|7b86863443354489bef0510d4330ab11
"Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:5

(2) Preservability of script semantics. When analyzing scripts, the more output logs lose script semantics, the less information analysts can obtain from the logs. Therefore, construction methods should preserve script semantics to provide better information for analysis. (3) Binary applicability. When constructing script analysis tools of script engines, which are proprietary software (we call them proprietary script engines), their source code is not available. Because attackers often use such proprietary script languages, it is necessary for construction methods to be applicable to binaries. We also discuss what form of logs should be output with script analysis tools. As mentioned in requirement (2), the logs should preserve script semantics. That is, logs that can reconstruct the script APIs, and their arguments that the target script used are desirable. For example, when a script executes CreateObject(WScript.Shell), the corresponding analysis log should contain the script API CreateObject and its argument WScript.Shell. A script API tracer generated with our method outputs such logs."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|823aa687607e48d59f3878057fe7afed
"2.3 Design and Problem of Script Analysis Tool 2.3.1 Script-level Monitoring. Design. Script-level monitoring inserts hooks directly into the target script. Since malicious scripts are generally obfuscated, it is difficult to find appropriate hook points inside scripts that can output insightful information for analysts. Therefore, hooks are inserted using a hook point-free method, i.e., by overriding specific script APIs. Listing 1 shows a code snippet that achieves script-level monitoring of a script API eval in JavaScript. In this code, a hook is inserted by overriding the eval function (line 2), which inserts the code for analysis that outputs its argument as a log (line 3). Problem. There are two problems with script-level monitoring: applicability and stealthiness. Since this design requires overriding script APIs, it is only applicable to the script languages that allow overriding of the builtin functions. Therefore, it does not fulfill the requirement of language independence mentioned in Section 2.2. This design is not sufficiently practical for malicious script analysis because few script languages support such a language feature.

Listing. 1. Example of script-level monitoring implementation."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|4ec65e44ed514bb090851f82676794a7
"Listing. 1. Example of script-level monitoring implementation.

2.3.2 System-level Monitoring. Design. System-level monitoring inserts hooks into system APIs and/or system calls for monitoring their invocation. It then analyzes scripts by executing the target script while observing the script engine process. Problem. System-level monitoring causes a problem of a semantic gap due to the distance between the hook points in a system and the target scripts. There are two specific problems caused by a semantic gap: avalanche effect and semantic loss. The avalanche effect is a problem that makes an observation capture a large amount of noise, which occurs when one or more layers exist between an observation target and an observation point. Ralf et al. [23] referred to the avalanche effect caused by the existence of the COM layer, and we found that that of the script engine layer also causes the avalanche effect. The main concern with semantic loss is that it decreases information useful for analysts. For example, a script API Document.Cookie.Set, which has the semantics of setting cookies in the script layer, loses some semantics in the system API layer because it is just observed as WriteFile. For these reasons, system-level monitoring does not fulfill the requirement of the preservability of script semantics mentioned in Section 2.2.

Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

5:6 •"|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|53833c44ec5e4876ba07180bb5ccff3e
"Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

5:6 •

T. Usui et al. Table 1. Summary of Requirements Fulfillment with Each Design

Design

Script



level

System



level

Script engine



level

Proposed

(1) Universal

✗

✓

✓

✓

(2) Semantics

✓

✗

✓

✓

(3) Binary

✓

✓

✗

✓"|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|53888f3f075a41299445e9497ff2a6fb
"✓

2.3.3 Script Engine-level Monitoring. Design. Script engine-level monitoring inserts hooks into specific functionalities in script engines. Because inserting hooks into script engines requires deep understanding of its implementation, there are few methods that can obtain such knowledge. One is analyzing script engines by reading source code or reverse-engineering binaries. Another is building an emulator to obtain a fully understood implementation of the target script engine. Unlike script-level monitoring, script engine-level monitoring is independent of language specifications. It also does not cause a semantic gap, unlike system-level monitoring. Problem. The problem with this design is its implementation difficulty. Although this design may be easily achieved if a script engine provides interfaces for analysis such as Antimalware Scan Interface (AMSI) [34], this is just a limited example. In general, a developer of analysis tools with this design has to discover appropriate hook and tap points for inserting hooks into the target script engine binary. For open source script engines, we can find hook and tap points by analyzing the source code. However, only the limited script languages have their corresponding script engines whose source code is available. In addition, even source code analysis requires certain workloads. Moreover, obtaining the hook and tap points for proprietary script engines requires reverse-engineering, and there is no automatic method for this."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|0c6b9ed301eb4027a6fcac380fb3f95d
"In addition, manual analysis requires skilled reverse-engineers and unrealistic human effort. Therefore, this design does not fulfill the requirement of binary applicability mentioned in Section 2.2.

2.4 Approach and Assumption Table 1 summarizes how each design fulfills the requirements mentioned in Section 2.2. As mentioned in the previous section, neither script-level nor system-level monitoring can fulfill all the requirements. It is also, in principle, difficult for them to fulfill the requirements through their improvement. The problem with the binary applicability of script engine-level monitoring will be solved if automatic reverse-engineering of script engines is enabled. Therefore, our approach is to automatically obtain information required for hooking by analyzing script engine binaries, which makes it applicable to binaries. When analyzing script engine binaries, we assume knowledge of the language specifications of the target script. This knowledge is used for writing test scripts that are input to script engines during analysis. We do not assume knowledge of internal implementation of the target script engines. Therefore, no previous reverseengineering of the target script engines is required."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|ab80334ef82546bd87b084b72acbd6f4
"2.5 Formal Problem Definition A script engine binary B is modeled as a tuple (M, C) where M is a set of memory blocks associated with E, and C is a set of code blocks that implements B. Here, let a, ... ∈ A be a set of the script APIs of the observing targets, i a , ... ∈ I A ⊂ C be their corresponding implementation, and r a , ... ∈ R A ⊂ M be arguments of the script APIs, the problem is finding I A and R A from C, M, and A, which is, in general, difficult. Therefore, our goal is to provide a map f : M × C × A → I A × R A . Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:7

Fig. 2. Overview of our method."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|ba18aaa9d2e54589bbfce594b149074e
3 METHOD 3.1 Overview Figure 2 shows an overview of our method. The main purpose of our method is automatically detecting hook and tap points by analyzing script engine binaries. The method uses test scripts that are input to the target script engine and executed during dynamic analysis of the engine. These test scripts are manually written before using our method. As mentioned above, our method is composed of five steps: execution trace logging, hook point detection, tap point detection, hook and tap points verification, and script API tracer generation. The execution trace logging step first acquires execution traces by monitoring the script engine executing the test scripts. The hook point detection step extracts hook point candidates by the application of our modified Smith-Waterman algorithm to the execution trace obtained in the previous step. After the hook point candidates are obtained, the tap point detection step extracts tap points and confirms the hook point. The verification step tests the detected hook and tap points to avoid false positives of script API trace logs. Using the obtained hook and tap points, the final step inserts hooks into the target script engine and outputs it as a script API tracer. We define hook and tap points as follows. — A hook point is the entry of any local function that corresponds to the target script API in a script engine. — A tap point is defined as any argument of the local function at which the hook point is set.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|3bfafc5253084e94aa81c63d5cad56ec
"These definitions are reasonable for well-designed script engines. It is normal for such engines to implement each script API in the corresponding local functions for better cohesion and coupling. In the implementation, the arguments of a script API call would be ordinarily passed via the arguments of the local functions. Note that obfuscations, such as control-flow flattening and unreasonable function inlining, are unusual among our analysis targets since they are not malicious binaries. In our method, we let hook points that correspond to target script APIs A be h a0 , h a1 , ... ∈ H A and tap points be ta0,0 , ta0,1 , ... ∈ TA whose index of each element indicates the script API and the index of its arguments. Therefore, Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

5:8 •

T. Usui et al.

Fig. 3. Hook and tap points in generic design of script engine."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|c5f7be306ff64407bc4e7a8bff8472b1
"5:8 •

T. Usui et al.

Fig. 3. Hook and tap points in generic design of script engine.

f : M × C × A → I A × R A ⇒ f : M × C × A → H A × TA . Also, we let a set of test scripts be s 0 , ... ∈ S and the execution traces corresponding to it be es0 , ... ∈ E S . We locate hook and tap points in a generic script engine for better understanding of what our method is analyzing. Figure 3 depicts generic design of script engines and the hook and tap points in its virtual machine (VM). Recent script engines generally use a VM that executes bytecode for script interpretation. The input script is translated into the bytecode through the analysis phase, which is responsible for lexical, syntactic, and semantic analysis, and the code generation phase, which is responsible for code optimization and generation. The VM executes VM instructions in the bytecode that are implemented as VM instruction handlers by using a decoder and dispatcher. The script APIs, which are generally implemented as functions, are called by the instructions. The hook points are placed at the entry of the functions and the tap points at the memory corresponding to the arguments of the hooked functions. Somestudies [9, 18, 25] identified VM instruction handlers; however, to the best of our knowledge, no studies have been conducted regarding identification of script APIs and their arguments."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|2fc340c9fc0e4a53b625b7ec3939232d
3.2 Preliminary: Test Script Preparation Test scripts used with our method have to fulfill the following four requirements. (1) A test script executes the target script API with no error. (2) A test script only has the behavior relating to the target script API. It is also allowed to execute script APIs essential for executing the target script API. For example, if the target script API is Invoke (i.e., COM method invocation), CreateObject is essentially required. (3) Two test scripts are required to analyze one target script API. One calls the target script API only once and the other calls it N times. Note that N is a predefined parameter. (4) The arguments of the target script API are arbitrarily defined as long as the script API is not skipped when it is executed multiple times. For example, executing CreateObject multiple times with the same argument may be skipped because copying the existing object instead of creating a new object is a better approach. A test script works as a specifier of the target script API, which our method analyzes. Therefore, it contains only the target script API. For example, when one wants to analyze the local functions regarding the script API CreateObject and obtain the corresponding hook point, the test script only contains a call of CreateObject such as in Listing 2. Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|73213ffe129e44deb048d8b79fad053e
"Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:9

Listings 2 and 3 show an example of test scripts for the script API of CreateObject in VBScript. As shown in the scripts, they fulfill the four requirements of the test scripts. They call the target script API CreateObject with no error (requirement 1) and only have the behavior relating to it (requirement 2). They are two test scripts in which one calls the target script API only once and the other calls it three times (requirement 3). The different arguments of WScript.Shell, MSXML.XMLHTTP, and ADODB.Stream are chosen for each call of the target script API so that the calls are not skipped even when they are called multiple times (requirement 4). These test scripts have to be manually prepared before the analysis. Writing test scripts requires knowledge of the language specifications of the target script language, which does not conflict with the assumption given in Section 2.4. The amount of human effort required for preparing test scripts is evaluated in Section 5.8. Since this preparation (manually) converts the target script APIs into the corresponding test scripts, it provides a map д : A → S A .

Listing. 2. Example of test script for CreateObject in VBScript that calls once.

Listing. 3. Example of test script for CreateObject in VBScript that calls three times."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|82ec8196490c43d29a2b8c607f99b698
"Listing. 3. Example of test script for CreateObject in VBScript that calls three times.

3.3 Execution Trace Logging This step acquires the execution traces that correspond to the test scripts for the target script APIs by executing and monitoring the script engine binary. Therefore, it provides a map h : M × C × S A → E S A . An execution trace with our method consists of an API trace and branch trace. The API trace contains the system APIs and their arguments called during the execution. This trace is acquired by inserting code for outputting logs by API hooks and executing the test scripts. The branch trace logs the type of executed branch instructions and their source and destination addresses. This is achieved by instruction hooks, which inserts code for log output to each branch instruction. This step logs only call, ret, and indirect jmp instructions because these types of branch instructions generally relate to script API calls."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|1e55aebd34b94892969f12f509f8d735
"3.4 Hook Point Detection The hook point detection step uses a dynamic analysis technique called differential execution analysis. This analysis technique first acquires multiple execution traces by changing their execution conditions then analyzes their differences. A concept of this step is illustrated in Figure 4. It is assumed that an execution trace with one script API call differs from another with multiple calls only in the limited part of the trace regarding the called script API. Since we use a branch trace in this step, its analysis granularity is code block-level. Therefore, this step is even effective for script APIs that do not call system APIs. For example of such script APIs, Eval in VBScript, which only interacts with the script engine, does not need to call system APIs. Also, script APIs regarding COM method invocation does not call system APIs. Therefore, system-level monitoring, which uses system API calls as a clue, cannot observe the behavior of these script APIs. However, our method is effective even for these script APIs since this step is independent from system API calls. Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

5:10



T. Usui et al.

Fig. 4. Concept of hook point detection by differential execution analysis."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|63845799bcf64fab9f79ec72e8fc86e5
This step uses multiple test scripts, i.e., one that calls the target script API once and the other(s) that calls it multiple times, as described in Section 3.2. This step differentiates the execution traces acquired with these test scripts and finds the parts of the traces related to the target script API that appears in the difference. This differentiation is done by finding common subsequences with high similarity from multiple branch traces. Note that this common subsequence is defined as a subset of branch traces, which appears once in the trace of the test script that calls the target script API once and appears N times in the trace of one that calls it N times. To extract these common sequences, our method uses a modified version of the Smith-Waterman algorithm borrowed from bioinformatics. The Smith-Waterman algorithm performs local sequence alignment, which extracts a subsequence with high similarity from two or more sequences. However, we have a problem in that it does not take into account the number of common subsequences that appeared; therefore, we modified it to take this into account. We first explain the original Smith-Waterman algorithm, then introduce our modified version. The SmithWaterman algorithm is a sequence alignment algorithm based on dynamic programming (DP) that can detect a subsequence of the highest similarity appearing in two or more sequences. This algorithm uses a table called a DP table.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|7f03c1d8993e44908f3ac23dcf6878ff
"In a DP table, one sequence is located at the table head, another is located at the table side, and each cell contains a match score. A match score F (i, j) of cell (i, j) is calculated based on Equation (1), where i is the index of rows and j is the index of columns. 0 ⎧ ⎪ ⎪ ⎪ ⎪ F (i − 1, j − 1) + s (i, j) F (i, j) = max ⎨ ⎪ F (i − 1, j) + d ⎪ ⎪ ⎪ ⎩ F (i, j − 1) + d, where



s (i, j) =

2

−2

(match)

(unmatch)

d = −1

(1)

(2)

(3)

Our modified algorithm is the same as the original up to filling all cells of the DP table. We provide an example of a DP table in Figure 5 for further explanation. A sequence of A, B, and C in this figure indicates one of the gray boxes in Figure 4. The letter S indicates the white box that appears at the start of the execution trace, whereas E indicates the white box at the end. The letter M denotes the white boxes that appear between the gray boxes as margins. Although, these elements actually consist of multiple lines of branch trace logs; they are compressed as A, B, and so on, for simplification. The original Smith-Waterman algorithm only finds the common subsequence of the Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:11

Fig. 5. Modified Smith



Waterman algorithm."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|62c53a75e0e243cdb1736d2062783530
"Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:11

Fig. 5. Modified Smith



Waterman algorithm.

highest similarity (S, A, B, and C with dotted line in Figure 5) by backtracking from the cell with the maximum score (the cell with score 8 in Figure 5). After finding one such sequence, it exits the exploration. After this procedure, the modified Smith-Waterman algorithm performs further exploration. Algorithm 1 shows our modified Smith-Waterman algorithm. This algorithm repeatedly extracts subsequences of high similarity from the rows that are the same as the common subsequence extracted with the original algorithm (i.e., the dashed rounded rectangle in Figure 5). This is done by finding the local maximum value from the rows and backtracking from it. The modified algorithm repeats this procedure N times to extract N common subsequences (the three dotted circles in Figure 5). If the similarity among the subsequences exceeds the predefined threshold, the algorithm detects the branches constructing the subsequence as hook point candidates. Otherwise, it examines the cell with the next highest score. Algorithm 1 shows the detail of the modified Smith-Waterman algorithm. This step provides a map k : E S A1 × E S AN → H A where S A1 ⊂ S A indicates the test scripts that call the target script API once and S AN does those that call twice."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|144df9aaedf8446a9ccaab8b8f0c110e
"3.5 Tap Point Detection The tap point detection step plays two important roles. The first is to select the final hook points from the hook point candidates obtained in the previous step. The second is to find the memory regions that should be dumped Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

5:12 • T. Usui et al. ALGORITHM 1: Modified Smith-Waterman algorithm Require: seq1, seq2, N , threshold Ensure: result_seqs dptbl ⇐ DPTable(seq1, seq2).fillCell() i⇐1 repeat result_seqs ⇐ [] max_cell ⇐ dptbl .searchNthMaxCell(i) max_seq ⇐ dptbl .backtrackFrom(max_cell ) result_seqs.append(max_seq) rows ⇐ dptbl .getSameRows(max_seq)j ⇐ 1 for n = 1 to N do repeat max_cell ⇐ dptbl .searchNthMaxCellInRows(j, rows) max_seq ⇐ dptbl .backtrackFrom(max_cell ) j ⇐j+1 until isNotSubseq(max_seq, result_seqs) result_seqs.append(max_seq) end for min_similarity ⇐ 1.0 for seq1 ∈ result_seq do for seq2 ∈ result_seq do similarity ⇐ calcSimilarity(seq1, seq2) if similarity < min_similarity then min_similarity ⇐ similarity end if end for end for i ⇐i +1 until min_similarity > threshold"|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|f201ef11f94b4c648b6823b3097d690b
into logs. Such memory regions have two patterns: arguments and return values of script APIs. This step provides a map l : M × C × S A × H A → TA . 3.5.1 Argument. This step adopts a value-based approach that finds the matched values between the test script and the memory region of the script engine process. If an argument value of the script APIs in the test scripts also appears in a specific memory region, the location of the memory region is identified as a tap point. Tap point detection for arguments of script APIs is carried out by exploring the arguments of the local functions detected as hook point candidates. To do this, this step acquires the execution trace again with hooks inserted into the hook point candidates obtained in the previous step. The arguments of the hook point candidates are available by referring to the memory location based on the calling convention. Since the type information (e.g., integer, string, and structure) of each argument is not available, further exploration requires heuristics. Figure 6 illustrates the exploration heuristics used with this step. First, if an argument of a hook point candidate is not possible to be dereferenced as a pointer (i.e., the pointer address is not mapped), this step regards it as a value of primitive types. Otherwise, this step regards it as a pointer value and dereferences it. When an argument is regarded as a value, we consider the value as the various known types including the known structures for matching.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|4ac9373afd3146519007245f3d9a3951
"In addition, this step also regards a pointer as the one pointing a structure with the predefined size and alignment to explore the unknown user-defined structures. As a result of this exploration, if the arguments Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:13

Fig. 6. Concept of tap point detection."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|61bb70dd1bf343db9db4de2fd4618855
"Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:13

Fig. 6. Concept of tap point detection.

in the test script are observed as the arguments at a hook point candidate, this step regards the candidate as legitimate and determines the memory region of the argument as a tap point. This exploration is improved if the type information is available. Therefore, this step may explore the memory regions more precisely by applying research conducted on reverse-engineering type information such as Laika [10], Type Inference on Executables (TIE) [29], Howard [43], Reverse Engineering Work for Automatic Revelation of Data Structures (REWARDS) [31], and Argos [56] or that on predicting type information such as Debin [20] and TypeMiner [33]. 3.5.2 Return Value. There are two problems with tap point detection for return values of script APIs. The first is that return values in test scripts tend to have low controllability. As mentioned in Section 3.5, tap point detection uses matching between the values in a test script and those in script engines. If a value in a test script is hardly controllable (e.g., it will always be 0 or 1), its matching would be more difficult than that with controllable values. The second problem is a gap between a script and script engine. Due to this gap, how a variable is managed in a script and script engine may differ. This makes the return values in scripts and actual values in script engines different."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|29c90defc318401c836c2874dfed9526
For example, an object in a script engine returned by an object creation function may be returned as an integer that indicates the index of an object management table in scripts. We use value-based detection in a similar manner as tap point detection for arguments. The difference is the entry point of the exploration. Since return values of script APIs may be passed through the return value and output arguments of the corresponding function in the script engine, the proposed method begins to explore from them. If the return value in the test script does not appear in the script engine, the proposed method tentatively regards the return value of the hook point function as that of script APIs.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|f6264da776fe4e77baf56a0bb68aa52b
"3.6 Hook and Tap Point Verification After hook and tap point detection, verifying their effectiveness is an important step. We define false positives (FPs) and false negatives (FNs) in the context of script API tracing regarding hook and tap points as follows. FPs indicate the log lines of called script APIs that are NOT actually called by the target script regarding the hook and tap points. FNs indicate the script APIs missing in the log lines, which are actually called by the target script. Figure 7 shows an example case that produces an FP. In this figure, the hook and tap points for script API A are set at the function dispatch and its argument, which are actually shared between script API A and script API B. The hook with the points can log script API A calls; however, a call of script API B is also logged incorrectly at Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

5:14



T. Usui et al.

Fig. 7. False positive case."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|36ec13c65ec64d4db7a4300b9202154a
"5:14



T. Usui et al.

Fig. 7. False positive case.

the time script API A is called. Therefore, this hook is inappropriate since it produces FPs. This problem is caused by the fact that the proposition “hook and tap points are appropriate → a correct script API log to a test script is available” is true, whereas its converse is false. For many hook and tap points and test scripts, the converse is also true. However, a counter example shown in Figure 7 exists. Since our method implicitly depends on the converse, it would be a pitfall that causes the FP case on rare occasions. To avoid this, this step verifies the hook and tap points selected for a script API and reselects the others from the candidates if the FPs are produced during verification. The verification uses multiple scripts called verification scripts that call the target script. The only requirement of these scripts is that they contain a call of the target script API whose arguments are comprehensible. Therefore, since verification scripts do not have to fulfill the complexed requirements like test scripts, they are automatically collectable from websites on the Internet such as official documents of the target script language and software development platforms like GitHub [17]. Note that since the verification depends on the corrected verification scripts, it reduces FPs on a best effort basis. This step first extracts the script API calls and their arguments from the corrected scripts."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|bc4eaf5b1b6d4659b9a357a2b75d7126
Since benign scripts corrected from the Internet are not generally obfuscated, the extraction is done with no difficulty by static analysis. This step then executes the scripts with the generated script API tracer to obtain analysis logs. If the difference between the script API calls extracted from the verification scripts and those from the analysis logs is observed, the verification is failed and the other hook and tap point candidates are reselected. Through this step, our method can experimentally select the hook and tap points that produce fewer FPs.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|7cd91e80e4fd4c3da09fa62249f372a7
"3.7 Script API Tracer Generation We use the hook and tap points obtained in the above steps for appending script API trace capability to the target script engines. By using the maps h, д, k, l that are provided in the above sections and the inputs of our method B (i.e., (M, C)) and A, the method can construct the map of the goal f : M × C × S A → H A × TA . Therefore, this step can use the hook and tap points that corresponds to the target script APIs obtained with the above steps. Our method hooks the local functions that correspond to the hook points and inserts analysis code. Note that a hook point indicates the entry of a local function that is related to a script API, as mentioned in Section 3.1. The analysis code dumps the memory of the tap points with the appropriate type into the analysis log. This code insertion is achieved using generic binary instrumentation techniques. Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:15"|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|e55166988c004f739c38e398c537a47b
"Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:15

Although execution trace logging step uses instruction-level hooking, script API tracer generation step generates script API tracers by using function-level hooking. The former step requires instruction-level hooking for exhaustively capturing all branches executed in the script engine binaries. However, as the definitions of hook and tap points in Section 3.1 indicate, they are located at the function entry and its arguments; the latter step is done only with function-level hooking.

4

IMPLEMENTATION"|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|9adc39510fe2450cb4be2023c94c551d
"4

IMPLEMENTATION

To evaluate our method, we implemented it in a prototype system called STAGER, which is a script analyzer generator based on engine reversing. STAGER uses Intel Pin [32] to insert instruction-level hooks into the target script engine for acquiring execution traces. Intel Pin is a dynamic binary instrumentation framework that uses dynamic binary translation with a VM. STAGER enumerates symbols of the system libraries in the target script engine process and inserts hooks into them for obtaining called system APIs and their arguments. It also hooks an instruction ins executed in the target script engine process when one of the following conditions is true. — INS_IsIndirectBranchOrCall(ins) && INS_IsBranch(ins)} — INS_IsCall(ins) — INS_IsRet(ins) As mentioned in Section 3, our method hooks detected hook and tap points with function-level hooking. Although Intel Pin also provides a function-level hooking feature with dynamic binary translation, it generally has a heavier overhead than the one with inline hooking. Therefore, STAGER uses Detours [39], which provides an inline hooking feature, for generating script API tracers. Detours is a dynamic binary instrumentation framework that enables inline hooking of functions. Although its main target of hooking is Windows APIs, it is also applicable to hook local functions that have known addresses and arguments."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|072f89afc1524e74ad5f6da7ef300b06
"Our script API tracer is implemented as a dynamic link library (DLL), which is preloaded into the process of the target script engine. It reads the configuration file in which hook and tap points are written and inserts inline hooks regarding them into the script engine with Detours. It is universally applicable to various script engines by using the corresponding configuration files. Since STAGER automatically detects the hook and tap points and outputs it to the configuration file, the script API tracer is easily generated for the script engines that STAGER analyzed.

5

EVALUATION

We conducted experiments on STAGER to answer the following research questions (RQs). — RQ1: What is the accuracy of hook and tap point detection with STAGER? — RQ2: How much performance overhead does STAGER introduce to generate a script API tracer? — RQ3: Is the STAGER-generated tracer applicable to malicious scripts in the wild? — RQ4: How many FPs and FNs does the script API tracer, generated with STAGER (STAGER-generated tracer), produce? — RQ5: How well does the STAGER-generated tracer work compared with existing analysis tools? — RQ6: How much overhead do the STAGER-generated tracers produce? — RQ7: How much human effort is required to prepare test scripts?"|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|7b53789925034343b3841ffc07e235eb
"5.1 Experimental Setup Table 2 summarizes the experimental setup. We set up this environment as a VM. One virtual Central Processing Unit (CPU) was assigned to this VM. Although STAGER is more beneficial for proprietary script engines, we applied it to both open source and proprietary script engines. Open source engines are used because we can easily confirm the correctness of the Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

5:16



T. Usui et al.

Table 2. Experimental Environment

OS

CPU

RAM

VBA

VBScript

VBScript

PowerShell

Windows 7 32



bit

Intel Core i7



6600U CPU @ 2.60GHz

2GB

VBE7.dll (Version 7.1.10.48)

vbscript.dll (Version 5.8.9600.18698)

vbscript.dll (ReactOS 0.4.9)

PowerShell 6.0.3"|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|3e2e119a8bd24302b0770c43c49051d7
"6600U CPU @ 2.60GHz

2GB

VBE7.dll (Version 7.1.10.48)

vbscript.dll (Version 5.8.9600.18698)

vbscript.dll (ReactOS 0.4.9)

PowerShell 6.0.3

hook and tap points. Note that the source code is only used for confirming the results, and STAGER did not use it for its analysis. Therefore, the analysis with STAGER is done in the same manner as that of proprietary script engines. In addition, proprietary engines are used to confirm the effectiveness of STAGER for real-world proprietary engines. For open source script engines, we used VBScript implemented in ReactOS project [38] and PowerShell Core [47], which is an open source version of the PowerShell implementation. We selected these script engines for the experiments because both have open source implementation of proprietary script engines and their supporting languages are frequently used by attackers for writing malicious scripts. For VBScript of ReactOS, we extracted vbscript.dll from ReactOS and transplanted it into the Windows of the experimental VM environment because Intel Pin used by STAGER does not work properly on ReactOS. For the proprietary script engines, we used Microsoft VBScript and VBA implemented in Microsoft Office. These script engines were also selected because they are widely used by attackers. When we analyze the script engine of VBA, we first execute Microsoft Office and observe its process during the execution of the attached script."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|97abe736bf3948b6a8189f7b4fb6d3b5
5.2 Detection Accuracy To answer RQ1, we evaluated the detection accuracy of the hook and tap point detection steps. We detected hook and tap points of VBA, VBScript, and PowerShell using STAGER. We selected script APIs that are widely used by malicious scripts for the target of hook and tap point detection. VBA and VBScript were designed to use COM objects for interacting with the OS, instead of directly interacting with it. Therefore, malicious scripts using VBA and VBScript use script APIs related to COM object handling. In addition, VBA has useful script APIs and VBScript has those of reflection such as Eval and Execute, used for obfuscation. PowerShell has script APIs called Cmdlets that provide various functionalities including OS interaction. We selected Cmdlets of object creation, file operation, process execution, internet access, reflection, and so on, which are often used by malicious scripts. We set 0.8 as the threshold of the similarity of subsequences used for differential execution analysis-based hook point detection. This threshold was defined on the basis of the manual analysis of the DP tables in a preliminary experiment conducted separately from this one. Because the DP tables had a similar pattern, we found this threshold could be used globally. Table 3 shows the results of the experiments. The Original Points column shows the number of branches obtained by the branch traces.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|6b5731a154474b1aaac2d1ec082818ca
"The Hook Point Candidates column shows the number of hook point candidates filtered by hook point detection. The Hook and Tap Point Detection column has ✓ if the final hook and tap points were obtained. The Log Availability column has ✓ if the obtained hook and tap points output the correct log corresponding to the known scripts. For VBA and VBScript, STAGER could accurately detect all hook and tap points that can output logs showing the script APIs and their arguments. Despite the large number of obtained branches, STAGER could precisely filter the branches that are irrelevant to the target script APIs. This showed that STAGER is applicable to real-world proprietary script engines to generate the corresponding script API tracers. Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:17

Table 3. Result of Hook and Tap Point Detection

Script

VBA

VBScript

VBScript

(ReactOS)

PowerShell

Script API

CreateObject

Invoke (COM)

Declare

Open

Print

CreateObject

Invoke (COM)

Eval

Execute

CreateObject

Invoke (COM)

Eval

Execute

New



Object

Import



Module

New



Item (File)

Set



Content (File)

Start



Process

Invoke



WebRequest

Invoke



Expression

Original Points

93,000,090

101,993,701

94,281,492

85,641,170

90,024,821

390,836

1,148,225

369,070

371,040

89,213

128,511

210,852

185,192

198,327

200,822"|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|7d170d3bb13345f7b1befa4be394f2fe
"101,993,701

94,281,492

85,641,170

90,024,821

390,836

1,148,225

369,070

371,040

89,213

128,511

210,852

185,192

198,327

200,822

152,841

315,380

271,054

Hook Point

Candidates

53

98

34

42

29

48

92

121

134

32

43

54

48

93

54

119

98

82

Hook and Tap

Point Detection

✓

✓

✓

✓

✓

✓

✓

✓

✓

✓

✓

Not applicable

Not applicable

✓

✓

✓

✓

✓

✓

✓

Log Availability

✓

✓

✓

✓

✓

✓

✓

✓

✓

✓

✓

Not applicable

Not applicable

✓

✓

✓

✓

✓

✓

✓"|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|6b40b9bebc9242939dbbc6c186d28105
"Not applicable

✓

✓

✓

✓

✓

✓

✓

Log Availability

✓

✓

✓

✓

✓

✓

✓

✓

✓

✓

✓

Not applicable

Not applicable

✓

✓

✓

✓

✓

✓

✓

STAGER could also detect CreateObject and Invoke on VBScript of ReactOS. However, it was not applicable for detecting the hook points of Eval and Execute because the VBScript in ReactOS has just mocks of them, which have no actual implementation. We checked the source code to confirm the corresponding location of the detected hook points. The hook was inserted into the local function of create_object, which definitely creates objects. We found that the hook was inserted into the local function of disp_call, which is responsible for invocation of the IDispatch::Invoke COM interface. As shown in Table 3, STAGER also detected proper hook and tap points for PowerShell. A notable difference among the script engines of PowerShell and the others is the existence of an additional layer: a common language infrastructure (CLI). PowerShell uses a CLI of the Microsoft .NET Framework, which is an additional layer between the OS and script engine. Since STAGER properly found the hook and tap points of PowerShell with bytecode analysis, we confirmed that it works even for script engines with an additional layer such as a CLI layer. Overall, STAGER could properly detect all hook and tap points in all VBA, VBScript, VBScript (ReactOS), and PowerShell script engines except Eval and Execute of VBScript (ReactOS), which were not implemented."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|32150ac0dc8d47ea8e230ecd1387aeb7
"5.3 Performance To answer RQ2, we evaluated the performance of STAGER by measuring the execution duration of each of its steps. Figure 8 shows the results. Note that the execution time in this figure does not include the time for preparing test scripts because it should be manually created before the execution. Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

5:18



T. Usui et al.

Fig. 8. Execution duration of our method.

Execution trace logging and tap point detection required about 10 seconds due to the overhead of execution and log output with Intel Pin. Backtrace performed just a little exploration of execution trace; therefore, it took little time. On the other hand, differential execution analysis took about 5 seconds. The computational complexity of the Smith-Waterman algorithm is O (MN ), where the length of one sequence is M and the other sequence is N . Thus, the longer the execution trace becomes, the longer the execution duration will be. Overall, hook and tap point detection for one script API took about 30 seconds. The total number of script APIs in a script language, for example in VBScript, is less than one hundred according to the language specifications, and the script APIs of interest for malicious script analysis are limited. Therefore, the proposed method could quickly analyze script engines and generate a script API tracer, which is sufficient for practical use."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|2dd176cd78284837be73cbb47e315502
5.4 Analysis of Real-world Malicious Scripts To answer RQ3, we applied the script API tracers generated by STAGER for analyzing malicious scripts in the wild. We collected 205 samples of malicious scripts that were uploaded to VirusTotal [1] between 2017/1 and 2017/7. We then analyzed them using the script API tracers. We found that the script API tracers could properly extract the called script APIs and their arguments executed by the malicious scripts. We investigated the URLs obtained as arguments of script APIs. All were identified as malicious (positives > 1). We also investigated the file streams of the script API arguments. The results of this investigation indicated that the streams were ransomware such as Dridex. We also confirmed that the script API tracers generated by STAGER are applicable to real-world malicious scripts. We selected four samples and their analysis logs as case studies. The first is a VBA Injector, the second is a VBScript downloader, the third is a PowerShell fileless malware module, and the last is an evasive malicious script. 5.4.1 Case Study 1: VBA Injector. Figure 9 shows the analysis log of a VBA injector generated by a script API tracer. This malicious script uses the Declare statement that loads a library and resolves a procedure in it to call Windows APIs. It first creates a process of rundll32.exe in a suspended state.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|f64134103fb4462c9164edb8bedae08b
"It then allocates 0x31c bytes of memory with write and execute permission and writes code of the size to the memory byte-by-byte. Finally, a remote thread that executes the written code in the process is created. As shown in the figure, the script API tracer could generate a log that only contains the APIs called from the input script through the Declare statement, Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:19

Fig. 9. Analysis log of VBA injector acquired with STAGER-generated script API tracer.

Fig. 10. Analysis log of VBScript downloader acquired with STAGER-generated script API tracer."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|c88f8155378047f9a922e2277ab8bbfb
"whereas the system API tracer in Figure 1 generated one containing APIs called from both the input script and script engine. This can significantly help analysts comprehend the behavior of malicious scripts. 5.4.2 Case Study 2: VBScript Downloader. Figure 10 shows the analysis log of a VBScript downloader generated by a script API tracer. Although this malicious script has 1,500+ lines of obfuscated code, the log consists of only 16 lines, which are responsible for the main behavior of downloading. Section (1) in the figure shows a part of the log in which the malicious script accessed a URL. Section (2) shows that the script saved the HTTP response to a specific file in the Temp folder. The saved buffer is also visible as a byte array of 0x3c 0x68 .... Section (3) shows that the saved file was executed through cmd.exe. As shown in this figure, the script API tracers generated by STAGER could successfully extract important indicators of compromise (IOCs) such as URLs, binaries, file paths and executed commands. Note that the log fulfills the requirement of the preservability of semantics mentioned in Section 2.2. 5.4.3 Case Study 3: PowerShell Fileless Malware. Figure 11 shows an excerpt of the analysis log of a module used by PowerShell fileless malware. This module seems to retrieve additional PowerShell modules from the Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

5:20



T. Usui et al."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|06d8abc0841a4ffa8b4e8e79ed6cef11
"5:20



T. Usui et al.

Fig. 11. Analysis log of PowerShell fileless malware acquired with STAGER-generated script API tracer.

Fig. 12. Analysis log of evasive malicious script acquired with STAGER-generated script API tracer."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|b4f2114f023845189bf3988416735521
C&C server and execute it. Section (1) in this figure shows the spawn of a new PowerShell process with commands used for Web access. We can see the executed command in deobfuscated form. Section (2) shows the simple downloading of the additional code using a system Web proxy. Section (3) shows the execution of the retrieved additional PowerShell code with the reflection function Invoke-Expression. In addition to Case Study 1, we can understand what code is dynamically evaluated by reflection functions. This will help malware analysts understand the behavior of malicious scripts. 5.4.4 Case Study 4: Evasive Malicious Script. Although STAGER-generated script API tracers have no antievasion feature, it can even help analysts understand the root cause of evasion. To demonstrate this, we chose an evasive malicious script obtained from VirusTotal and analyzed it with a STAGER-generated script API tracer. Figure 12 shows the analysis log of the evasive sample in VBA. Due to the evasion, the only behavior captured by the tracer was sending a ping to a host and obtaining its status code through winmgmts, which is WMI. However, the analyst can even obtain a clue that the status code may be relevant to the evasion mechanism. As Yokoyama et al. [54] suggested, evasive malware (including malicious scripts) have to obtain information of the executed environment (in this case, the status code) to determine whether they run or evade.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|ff60a07bb68347cea467df86d5f636d6
"In general, script API invocation is required for achieving it in terms of malicious scripts. Therefore, the tracer can help analysts to reveal evasive mechanisms of malicious scripts.

5.5 False Positives and False Negatives To answer RQ4, we tested the number of FPs and FNs produced by the hook and tap points of the STAGERgenerated script API tracers by analyzing known malicious scripts. We know we could evaluate only partial FPs and FNs; however, we conducted this because exhaustively evaluating the number of FPs and FNs is difficult. FPs indicate the log lines of called script APIs that are NOT actually called by the target script regarding the hook and tap points. FNs indicate the script APIs missing in the log lines, which are actually called by the target script regarding the hook and tap points. The script API tracers used for this experiment have tracing capability of the script APIs shown in Table 3. We used five samples whose called script APIs are known from manual analysis. The results indicated that the hook and tap points produced neither FPs nor FNs. Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:21

Table 4. Comparison with Existing Tracers

Tracer

API Monitor

ViperMonkey

STAGER



generated

Observed behaviors

0.25

0.8

1

Log lines

10,000+

16

20

Failure rate

0

0.6

0"|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|914668a06e9646da89dff0343213ab3a
"0.25

0.8

1

Log lines

10,000+

16

20

Failure rate

0

0.6

0

5.6 Comparison with Existing Tracer To answer RQ5, we compared STAGER-generated script API tracers with two existing tracers: API Monitor [5] and ViperMonkey [28]. API Monitor is a system API tracer based on system-level monitoring. We enabled all system API hooks of API Monitor and made it observe the target script engine process. ViperMonkey is a script API tracer for VBA based on script-level monitoring using the VBA emulator. To evaluate them under the same condition, we gathered VBA malicious scripts since ViperMonkey is a tracer of the scrip APIs of VBA. Therefore, we generated a script API tracer for VBA with STAGER (STAGER-generated tracer). We randomly chose five samples from the dataset and manually analyzed them to create ground truth. The evaluation was conducted from three viewpoints: amount of properly observed behavior, average number of log lines, and analysis failure rate. Table 4 shows the results of the experiment. Note that the results in the columns of observed behavior and log lines of ViperMonkey were calculated only with the samples that were analyzed successfully. API Monitor could only observe a small amount of behavior because some behavior such as COM method invocation and reflection cannot be directly observed through system APIs. In addition, it produced a large number of log lines that are irrelevant to the behavior of the samples because it cannot focus only on their behavior."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|e90e4a22c6fc4a63a35231160b967ddf
The log lines include the behavior derived from the script engines, as well as that derived from the samples. In other words, the avalanche effect mentioned in Section 2.3.2 occurred. ViperMonkey failed to analyze three samples due to insufficient implementation of the VBA emulator. When it failed to parse the samples, it terminated execution with an error. ViperMonkey missed some behavior because of the lack of the hooked script APIs. The STAGER-generated tracer did not fail to analyze the samples. This is because it uses the real script engine of VBA and its instrumentation does not ruin the functionality of the engine. It could observe the entire behavior with few lines of logs that properly focused on the script APIs of the samples.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|b6804a8d9f0146228b0c0177c7fed8fe
5.7 Performance of Generated Script API Tracer To answer RQ6, we evaluated the performance of the STAGER-generated script API tracers. We measured the execution duration of the script API tracers while analyzing the test and malicious scripts. In addition, we measured that of vanilla script engines for comparison. We measured the execution duration from the process start of the script engine until its end. Since VBA malicious scripts do not terminate the process even after script execution, we inserted the code that explicitly exits the process. Figure 13 shows the result of these measurement. The analysis with the STAGER-generated script API tracers took 1.51, 0.62, and 1.27 seconds per file (sec/file) on average for VBA, VBScript, and PowerShell malicious scripts. Overall, it takes about 1.2 sec/file in average. Therefore, the STAGER-generated script API tracers can analyze about 72,000 files per day per VM instance. Note that the time required for reverting the VM was not taken into account. The STAGER-generated script API tracers have only about 10% overhead compared with vanilla script engines. This result is natural because the STAGER-generated script API tracers require additional time only when the script APIs are called, which costs little overhead of memory and file input/output (I/O) operations for logging.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|4c4467df2f914db385fb3fd7b68526d0
"This shows that the STAGER-generated script API tracers can execute malicious scripts almost as quick as vanilla script engines, which in turn indicates that the STAGER-generated script API tracers are quick dynamic analysis tools. Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

5:22



T. Usui et al.

Fig. 13. Execution duration of STAGER-generated script API tracers and vanilla script engines. Table 5. Lines of Code (LOC) of Test Scripts

Script languages

VBA

VBScript

PowerShell

Average LOC

3.8

2.75

2"|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|c5caa158e0f74976aacf98efc7f4ee59
"PowerShell

Average LOC

3.8

2.75

2

5.8 Human Effort To answer RQ7, we conducted an experiment to evaluate the amount of human effort required to prepare test scripts. We evaluated this from two perspectives: lines of code (LOC) of test scripts and required time to create them. We gathered 10 people (eight graduate students, one technical staff member, and one visiting researcher) belonging to the computer science department as the participants of this experiment. We then explained the concept and requirements of the test scripts described in Section 3.2 to them. We asked them to write valid test scripts while measuring the required time. The list of script APIs to be written in the test scripts are provided to them in advance. The list, which is composed of script APIs frequently used by malicious scripts, is identical to the one used for the evaluation of the detection accuracy in Section 5.2. Many did not have experience of writing the script languages of VBA, VBScript, and PowerShell. Therefore, we asked them to spend some time learning the language specifications since we assume that test script writers have knowledge on the target language. Note that we confirmed that all the created test scripts argued below are valid with STAGER. Table 5 shows the average LOC of the created test scripts for each language. The LOC of the test scripts for each language are within the range of 2 to 3.8. This indicates that test scripts that our method uses are just simple ones."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|46de763d12de4a07b9fddf9ba0593063
"Figure 14 shows the average time required for creating test scripts for each language. The average required time per script API was 36.6 seconds for VBScript, 42.6 seconds for VBA, and 42.6 seconds for PowerShell. The average time for all languages was about 59.5 seconds. These results indicate that writing valid test scripts takes less time for programmers who have knowledge of the target script language. Therefore, the amount of human Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:23

Fig. 14. Required time for test script preparation.

effort required for using STAGER is much less than manual reverse-engineering of script engines since manual reverse-engineering requires weeks or months of analysis time."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|40cc444ee3da4e7a848a3fe9b9394edf
6 DISCUSSION 6.1 Limitations We discuss four cases in which our method cannot detect hook and tap points. The first is that in which the target script API does not have arguments to which we can set arbitrary values. Since tap point detection uses argument matching, which is based on setting unique arguments, this detection fails in principal if this matching is not available. The second is that in which the target script API contains only a small amount of program code. In this case, hook point detection by differential execution analysis might not be applicable because the difference is not well observed. However, since it is difficult for such simple script APIs to achieve significant functionality, they would not be interesting targets for malware analysts. The third is that the script engine is heavily obfuscated for software protection. For example, when the control flow graph is flattened to implement the script engine with one function, the proposed method cannot accurately detect hook points. Nevertheless, such obfuscated implementation is rarely seen in recent script engines, to the best of our knowledge. The last is script APIs that produce false positives and are rarely used in the real-world scripts. As described in Section 3.6, verification scripts are required to reduce the false positives. However, if the script APIs are rarely used, collecting the verification scripts from the Internet is difficult.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|24af219235e245189ac469f8a3d2858d
"6.2 Just-In-Time Compilation Many existing script engines have Just-In-Time (JIT) compilation functionality that translates repeatedly executed bytecode into native code for accelerating its execution. We investigated JIT compilation mechanisms of existing script engines to understand how this JIT compilation affects hook and tap points of script APIs. The mechanisms indicate that the existence of script API inlining is key. We thus discuss both patterns below: JIT compilation with and without inlining of script APIs. Figure 15 shows a generic mechanism of JIT compilation without inlining. As shown in the figure, this mechanism only translates bytecode regarding VM instructions into native code. In this case, the native code continues to call the script APIs implemented in the script engine. Therefore, the script API hooks properly work without changing the hook and tap points even after JIT compilation. Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

5:24



T. Usui et al.

Fig. 15. Generic mechanism of JIT compilation without inlining.

Fig. 16. Generic mechanism of JIT compilation with inlining."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|60b471a00b084eaca5c077d29fc57e38
"T. Usui et al.

Fig. 15. Generic mechanism of JIT compilation without inlining.

Fig. 16. Generic mechanism of JIT compilation with inlining.

Figure 16 shows a generic mechanism of JIT compilation with inlining. This mechanism inlines the called script APIs into the native code generated by JIT compilation. During JIT compilation, the code that is implementing the called script APIs is copied into the native code. When the inlined script APIs are executed, the script APIs in the script engine at which the script API hooks are set are not called. Therefore, hooking the hook and tap points generated with our method cannot acquire script API trace logs. This problem is solved by slight modification for tracking the copy of script APIs and propagating the corresponding script API hooks. Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:25

Overall, our method is not affected by JIT compilation, or even it is affected, we can handle it with a slight modification on the implementation of the generated script API tracers. Therefore, JIT compilation is not a limitation of our method."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|7bf94684a0544c5e98d3a6acc3548e1a
6.3 Human-assisted Analysis Although our method introduces automatic detection of hook and tap points, it is also helpful for its analysis to be assisted by humans. In particular, human-assisted analysis is beneficial for the case in which tap point detection does not work in principal. One such case is that human assistance can eliminate the first limitation discussed in the previous section. Our method identifies tap points by matching values in test scripts and functions arguments in script engines without taking into account any semantics regarding the values. However, manual analysis can take into account the semantics of values. Therefore, it is possible to discover tap points using the semantic information even when value matching is not available. In addition, since manual analysis by humans can provide better type information of variables by analyzing how the variables are used, the exploration for tap point detection becomes more accurate with human assistance. Note that the burden of manual analysis with our method is much less than complete manual analysis. This is because the number of functions that should be analyzed becomes much less by hook point detection, as described in Table 3. Without hook point detection, a reverse-engineer has to analyze thousands of functions to obtain tap points, whereas only tens of functions should be analyzed when it is performed with hook point detection.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|37460a49b52c4f8a842a3661b5c191a3
7 RELATED WORK 7.1 Script Analysis Tools There is a large amount of research on constructing script analysis tools. There are multiple script analysis tools that adopt script-level monitoring. The tool jAEk [36] hooks JavaScript APIs by overriding built-in functions. It inserts hooks on open/send methods of XMLHttpRequest objects and methods regarding HTMLElement.prototype to obtain URLs accessed by Ajax communication. Practical script analysis tools such as Revelo [24], box-js [7], jsunpack-n [19], and JSDetox [46] also use script-level monitoring. These tools offer strong script behavior analysis capability on JavaScript. However, they do not fulfill the requirements mentioned in Section 2.2 because they deeply depend on the language specifications of JavaScript. There are also script analysis tools based on script engine-level monitoring. Sulo [21, 22] is a instrumentation framework for Action Script of Adobe Flash using Intel Pin. It is based on the analysis of the source code of the Actionscript Virtual Machine (AVM). JSand [2] hooks built-in methods of JavaScript by implementing a specific emulator. FlashDetect [49] modifies an open source script engine of Flash for their hooks. These are examples of script engine-level monitoring. ViperMonkey [28] is an emulator of VBA, which can output logs of notable script APIs.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|bc1521f2410e461c882c35299770d317
"For system-level monitoring, many binary analysis tools that can hook system APIs and/or system calls such as API Chaser [26], Alkanet [35], Ether [12], Nitro [37], CXPInspector [51], IntroLib [11], and Drakvuf [30] are available. However, none of these tools can fulfill the requirements introduced in Section 2.2.

7.2 Script Engine Enhancement Chef [4, 6] is a symbolic execution engine for script languages. It uses a real script engine for building a symbolic execution engine. It achieves symbolic execution of the target scripts by symbolically executing the script engine binaries with a specific path exploration strategy. The design is similar to that of STAGER in that it reuses the target script engine for building a script analysis tool by instrumentation. On the other hand, the approaches and goals with Chef are different from those of STAGER. Its approach is based on manual source code analysis, whereas we used binary analysis. In addition, the goal with Chef is building symbolic execution engines, whereas ours is building script API tracers. Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

5:26



T. Usui et al."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|021206004ff946e5bc9cad102ee174a2
"5:26



T. Usui et al.

7.3 Virtual Machine Introspection Several techniques were developed for mitigating the semantic gap between the guest OSes and the VM monitor (VMM). Their goal is to observe the behavior within the guest OSes through the VM by mitigation, which is called VM introspection (VMI). Virtuoso [14] automatically creates VM introspection tools that can produce the same results as a reference tool executed in a VM from the out-of-VM. Virtuoso first acquires execution traces by executing the reference tool in the VM. This step is referred as training. It then extracts a program slice, which is only required for creating the tool. This method is similar to ours in that it extracts required information by analyzing formerly acquired execution traces. It differs from ours in its application target as well as the algorithm it uses to extract information from execution traces. VM-Space Traveler (VMST) [16] is a system that can automatically bridge the semantic gap for generating VMI tools. It achieved the automation of the VMI tools generation, while Virtuoso, one of the state-of-the-art studies at that time, is not fully automated. Its key idea is to redirect the code and data executed on the machine of introspection target to another machine prepared for VMI for obtaining the execution results. This idea depends on the key insight that the executed code for the same program is usually identical even across different machines."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|399732111cff469a92f85fad354a445c
To do this, VMST identifies the context of the system call execution and the data redirectable to the machine for VMI. Tappan Zee (North) Bridge [13], or TZB, discovers tap points effective for VM introspection. It monitors memory access of software inside a VM with various inputs for learning. It then finds tap points by identifying the memory location where the input value appears. It is used to monitor the tap points in real time from the outof-VM for achieving effective VM instrospection. Hybrid-Bridge [41] is a system that uses decoupled execution and training memorization for efficient redirection-based VMI. The decoupled execution is a technique to decouple heavy-weight online analysis that uses software-based virtualization from light-weight hardware-based virtualization. It uses two execution components: Slow-Bridge and Fast-Bridge. Slow-Bridge extracts meta-data using online data redirection like VMST on a VM with heavy-weight software-based virtualization for training and memorizes the trained meta-data (called training memorization). Fast-Bridge uses the meta-data for VMI on a VM with light-weight hardware-based virtualization. Only when the meta-data is incomplete, the execution on Fast-Bridge falls back to Slow-Bridge. AutoTap [55] automatically discovers tap points inside an OS kernel for monitoring various types of accesses to kernel objects such as creation, read, write, and deletion.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|23f1d8a953634118b8d6a33f361673e8
It dynamically tracks kernel objects and their propagation starting from its creation while resolving the execution context, the types of the arguments, and the access types. It then dumps these meta data into a log file. After the tracking, it analyzes the log file to discover the tap points of interest to introspection. Overall, the goal of the studies above, mitigating the semantic gap around the VM, is similar to ours. In addition, the approaches of some studies to find the tap points are similar to ours; however, their targets (i.e., OS kernels and VMMs) and algorithms are different from ours.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|5dfb9da5aebd42f591274584434cd01f
"7.4 Reverse Engineering of Virtual Machine Since our method analyzes VMs of script engines for obtaining hook and tap points, we present existing research regarding reverse engineering of VMs. Although no VM analysis study in terms of script engine VMs has been conducted, there have been studies conducted regarding software protection and malware analysis. Sharif et al. [42] proposed a method of automatically reverse engineering VMs used by malware for obfuscation. They used data flow analysis to identify bytecode syntax and semantics as well as the fundamental characteristics of VMs. Since script engines that our method analyzes are generally based on such VMs, their goal of automatically analyzing the VMs is similar to ours. However, their analysis target is different from ours. Their method identifies information about VMs and bytecode, whereas our method detects the local functions that corresponds to script APIs. Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:27"|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|2d28cabe989e42209bb32e11bb5ec8e9
Rolles [40] provided a method of circumventing virtualization-obfuscation used by malware with a running example of the common software protector VMProtect [45]. The method generates optimized x86 code that is equivalent to bytecode by reverse-engineering VMs, producing a disassembler for VM instructions, and optimizing with intermediate representation (IR). This study showed that protection by virtualization-obfuscations is evaded by such analysis. However, it assumed manual analysis implicitly and its automation was not considered in that article. Coogan et al. [9] proposed an approach to identify the bytecode instructions responsible for invoking system calls. Since system calls are strongly relevant to malware behavior, their goal was to approximate the behavior by the set of the identified bytecode instructions involved in the invocation of the system calls. Their goal, focus, and approach differed from ours mainly for the following three points. First, their goal was approximating the behavior of malware obfuscated by VMs, whereas ours is mitigating semantic gaps between script APIs and system APIs or system calls. Second, their focus was only on the bytecode instructions relevant to the invocation of system calls, whereas ours was all script APIs regardless of the existence of system calls. Finally, their approach strongly relied on the invoked system calls and arguments, whereas ours relied only on the branch instructions logged with test scripts. Kinder et al.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|55d01ec07e3e495da14fbe5daff6bf7c
extended static analysis to make it applicable to programs protected by virtualization-obfuscation. Their method, called VPC-sensitive static analysis, extended conventional static analysis with abstract interpretation whose states are location-sensitive (i.e., sensitive only to the program counter (PC)). Their analysis is sensitive to both PC and VPC and enables us to analyze VMs properly, whereas the conventional analysis suffers from over-approximation on states. Although their method of static analysis is different from ours of dynamic analysis, applying it combined with ours might be beneficial. VMAttack [25] deobfuscates virtualization-obfuscated binaries based on automated static and dynamic analysis. Its goal is to simplify the execution traces acquired from the target binaries. It first locates VM instruction handlers by dynamic program slicing; and clustering then maps bytecode instructions to the corresponding native assembly ones by analyzing the switch-case structure of the VM. The disassembled bytecode is optimized through stack based IR (SBIR) and only the important instructions are presented to reverse-engineers as simplified code. Nightingale [18] translates virtualization-obfuscated code into host code such as x86 via dynamic analysis. It locates the dispatcher and handlers of VM instructions by clustering acquired execution trace.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|52e8ef838bf34d2880703ad0cca04bb2
This approach is similar to ours in that the aim is to recognize specific functions implemented in a VM (i.e., VM instruction handlers in the Nightingale and script APIs in our method). However, it differs from ours regarding the two points. First, it discovers VM instruction handlers, while ours finds local functions corresponding to scrip APIs. Second, it only recognizes while ours clarifies what function corresponds to what scrip API. VMHunt [53] is a deobfuscation tool that first handles partially virtualized binaries. It first detects the boundaries between the virtualized snippets and the native snippets by finding context switch instructions in the acquired execution trace and identifies VM instructions by clustering. It then extracts the virtualized kernels, which have the global behavior that affects beyond the boundaries, and symbolically execute them with multiple granularities for reverse engineering them. The analysis of partially virtualized binaries is significantly important for analyzing real-world malware. However, since such binaries are rarely seen among script engines, their motivation differs from ours. Overall, most of existing studies on reverse-engineering VMs focused on virtualization-obfuscation mainly used by malware. The virtualization-obfuscators only translate instructions of original binaries into VM instructions and rarely provide APIs to the binaries.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|26e0fe0b467941fbb56ce761fda5ed26
"Therefore, none of the existing studies focused on API function identification while many were conducted to recognize VM instructions. In addition, the bytecode of script engine VMs is arbitrarily operable by changing input scripts while that of virtualization-obfuscated binaries is not. To the best of our knowledge, our research is the first that proposes a reverse-engineering method taking such operable case into account.

Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

5:28



T. Usui et al."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|fadecf0784d24af3aa65780d4811a29e
"Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

5:28



T. Usui et al.

7.5 Differential Execution Analysis Carmony et al. [8] proposed a method that uses differential analysis of multiple execution and memory traces for identifying tap points of Adobe Acrobat Reader. The traces are logged on condition that PDFs with JavaScript, Well-Formed PDFs, and Malformed PDFs are input to the reader. Based on the differential analysis of the traces, the method identifies tap points that enable the extraction of JavaScript as well as those that represent the termination and error of input file processing. Zhu et al. [57] used differential execution analysis to identify the blocking conditions used by anti-adblockers. They accessed websites and logged the traces of JavaScript execution with and without an adblocker. They then analyzed the traces to discover branch divergences caused by the adblocker and identified the branch conditions that cause the divergences. Although they used differential execution analysis the same as with our method, their focus (Adobe Acrobat Reader and JavaScript in websites) was different from ours (i.e., script engines). In addition, our differentiation algorithm (i.e., the modified Smith-Waterman algorithm) is different from those used in the above studies because their target problems to solve were also different from ours (i.e., identification of the commonly appeared sequences)."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|bef159aab07b410dad3a0d5410590f53
"7.6 Feature Location Feature location techniques aim to locate the module implementing a specific software feature, which are studied in software engineering. Although their target (i.e., source code) is different from ours (i.e., binaries), some studies use differential analysis of execution traces the same as ours. Wilde et al. [50] proposed a method called software reconnaissance, which locates software features by comparing execution traces obtained on condition that the feature of interest is active and inactive. Wong et al. [52] presented an approach that compares execution slices instead of execution traces. Because the slices include data related to a feature of interest, their approach takes data flow into account in addition to control flow. Eisenbarth et al. [15] presented an approach that addresses a problem of the difficulty of defining a condition that activates exactly one feature. Their approach uses the dynamic analysis of binaries combined with the formal static analysis of the program dependency graph and source code. Koschke et al. [27] extended their work by enabling them to handle statement-level analysis instead of their method-level one. Asadi et al. [3] proposed a method that adopts techniques of natural language processing to analyze source code and comments in it, in addition to the analysis of execution traces.

8

CONCLUSION"|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|9ece5db9a9254985a4826f708d8c5a27
"8

CONCLUSION

In this article, we focused on the problems of current dynamic script analysis tools and proposed a method for automatically generating script API tracers by automatically analyzing the binaries of script engines. The method detects appropriate hook and tap points in script engines through dynamic analysis using test scripts. Through the experiments with a prototype system implemented with our method, we confirmed that the method can properly append script behavior analysis capability to the script engines for generating script API tracers. Our case studies also showed that the generated script API tracers can analyze malicious scripts in the wild. Appending more effective script analysis capabilities is for future work.

Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:29

ACKNOWLEDGMENTS The authors would like to thank Tomoya Matsumoto, Yuki Kimura, and the members of Matsuura Laboratory for their kind support as the participants in the experiment. We also thank the anonymous reviewers for their insightful comments."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|ed5b7407e3764ccaa2335bd26cfcad70
REFERENCES [1] VirusTotal. [n.d.]. Retrieved March 9, 2017 from https://www.virustotal.com/. [2] Pieter Agten, Steven Van Acker, Yoran Brondsema, Phu H Phung, Lieven Desmet, and Frank Piessens. 2012. JSand: Complete client-side sandboxing of third-party JavaScript without browser modifications. In Proceedings of the 28th Annual Computer Security Applications Conference (ACSAC’12). ACM, 1–10. [3] Fatemeh Asadi, Massimiliano Di Penta, Giuliano Antoniol, and Yann-Gaël Guéhéneuc. 2010. A heuristic-based approach to identify concepts in execution traces. In Proceedings of the 14th European Conference on Software Maintenance and Reengineering (CSMR’10). IEEE, 31–40. [4] The Dependable Systems Lab at EPFL in Lausanne. [n.d.]. Chef. Retrieved January 1, 2018 from https://github.com/S2E/s2e-old/tree/ chef. [5] Rohitab Batra. [n.d.]. API Monitor. Retrieved February 15, 2019 from http://www.rohitab.com/apimonitor. [6] Stefan Bucur, Johannes Kinder, and George Candea. 2014. Prototyping symbolic execution engines for interpreted languages. In ACM SIGPLAN Notices, Vol. 49. ACM, 239–254. [7] CapacitorSet. [n.d.]. box.js. Retrieved February 15, 2019 from https://github.com/CapacitorSet/box-js. [8] Curtis Carmony, Xunchao Hu, Heng Yin, Abhishek Vasisht Bhaskar, and Mu Zhang. 2016. Extract me if you can: Abusing PDF parsers in malware detectors. In Proceedings of the 23rd Annual Network and Distributed System Security Symposium (NDSS’16). Internet Society, 1–15.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|398eb49e3b2d458fa43309d8058a5c17
[9] Kevin Coogan, Gen Lu, and Saumya Debray. 2011. Deobfuscation of virtualization-obfuscated software: A semantics-based approach. In Proceedings of the 18th ACM Conference on Computer and Communications Security (CCS’11). ACM, 275–284. [10] Anthony Cozzie, Frank Stratton, Hui Xue, and Samuel T. King. 2008. Digging for data structures. In Proceedings of the 8th USENIX Symposium on Operating Systems Design and Implementation (OSDI’08), Vol. 8. 255–266. [11] Zhui Deng, Dongyan Xu, Xiangyu Zhang, and Xuxiang Jiang. 2012. Introlib: Efficient and transparent library call introspection for malware forensics. Digital Investigation 9 (2012), S13–S23. [12] Artem Dinaburg, Paul Royal, Monirul Sharif, and Wenke Lee. 2008. Ether: Malware analysis via hardware virtualization extensions. In Proceedings of the 15th ACM Conference on Computer and Communications Security (CCS’08). ACM, 51–62. [13] Brendan Dolan-Gavitt, Tim Leek, Josh Hodosh, and Wenke Lee. 2013. Tappan Zee (north) bridge: Mining memory accesses for introspection. In Proceedings of the 2013 ACM SIGSAC Conference on Computer and Communications Security (CCS’13). ACM, 839–850. [14] Brendan Dolan-Gavitt, Tim Leek, Michael Zhivich, Jonathon Giffin, and Wenke Lee. 2011. Virtuoso: Narrowing the semantic gap in virtual machine introspection. In Proceedings of the IEEE Symposium on Security and Privacy 2011 (SP’11). IEEE, 297–312. [15] Thomas Eisenbarth, Rainer Koschke, and Daniel Simon. 2003. Locating features in source code.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|b9acdf0aa28a45bdabaf0297be45d6a7
IEEE Transactions on Software Engineering 29, 3 (2003), 210–224. [16] Yangchun Fu and Zhiqiang Lin. 2012. Space traveling across VM: Automatically bridging the semantic gap in virtual machine introspection via online kernel data redirection. In Proceedings of the 33rd IEEE Symposium on Security and Privacy (SP’12). IEEE, 586–600. [17] Inc. GitHub. [n.d.]. GitHub. Retrieved May 14, 2020 from https://github.com/. [18] Xie Haijiang, Zhang Yuanyuan, Li Juanru, and Gu Dawu. 2017. Nightingale: Translating embedded VM code in x86 binary executables. In Proceedings of the 20th International Conference on Information Security (ISC’17). Springer, 387–404. [19] Blake Hartstein. [n.d.]. jsunpack-n. Retrieved February 15, 2019 from https://github.com/urule99/jsunpack-n. [20] Jingxuan He, Pesho Ivanov, Petar Tsankov, Veselin Raychev, and Martin Vechev. 2018. Debin: Predicting debug information in stripped binaries. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security (CCS’18). ACM, 1667–1680. [21] Timo Hirvonen. [n.d.]. Sulo. Retrieved February 15, 2019 from https://github.com/F-Secure/Sulo. [22] Timo Hirvonen. 2014. Dynamic Flash instrumentation for fun and profit. Blackhat USA briefings 2014, Retrieved February 15, 2019 from https://www.blackhat.com/docs/us-14/materials/us-14-Hirvonen-Dynamic-Flash-Instrumentation-For-Fun-And-Profit.pdf. [23] Ralf Hund. 2016. The beast within—Evading dynamic malware analysis using Microsoft COM.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|a08dad493e4a45efa6aec85c8979bd9b
Blackhat USA briefings 2016. [24] KahuSecurity. [n.d.]. Revelo Javascript Deobfuscator. Retrieved February 15, 2019 from http://www.kahusecurity.com/posts/revelo_ javascript_deobfuscator.html. [25] Anatoli Kalysch, Johannes Götzfried, and Tilo Müller. 2017. VMAttack: Deobfuscating virtualization-based packed binaries. In Proceedings of the 12th International Conference on Availability, Reliability and Security (ARES’17). 1–10. [26] Yuhei Kawakoya, Makoto Iwamura, Eitaro Shioji, and Takeo Hariu. 2013. API Chaser: Anti-analysis resistant malware analyzer. In Proceedings of the 16th International Symposium on Research in Attacks, Intrusions and Defenses (RAID’15). Springer, 123–143. Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|5d3fbc98369f4620ac08433284ea070b
5:30 • T. Usui et al. [27] Rainer Koschke and Jochen Quante. 2005. On dynamic feature location. In Proceedings of the 20th IEEE/ACM International Conference on Automated Software Engineering (ASE’05). 86–95. [28] Philippe Lagadec. [n.d.]. ViperMonkey. Retrieved September 20, 2019 from https://github.com/decalage2/ViperMonkey. [29] JongHyup Lee, Thanassis Avgerinos, and David Brumley. 2011. TIE: Principled reverse engineering of types in binary programs. In Proceedings of the 18th Annual Network and Distributed System Security Symposium (NDSS’11). Internet Society, 1–18. [30] Tamas K. Lengyel, Steve Maresca, Bryan D. Payne, George D. Webster, Sebastian Vogl, and Aggelos Kiayias. 2014. Scalability, fidelity and stealth in the DRAKVUF dynamic malware analysis system. In Proceedings of the 30th Annual Computer Security Applications Conference (ACSAC’14). ACM, 386–395. [31] Zhiqiang Lin, Xiangyu Zhang, and Dongyan Xu. 2010. Automatic reverse engineering of data structures from binary execution. In Proceedings of the 17th Annual Network and Distributed System Security Symposium (NDSS’10). Internet Society, 1–18. [32] Chi-Keung Luk, Robert Cohn, Robert Muth, Harish Patil, Artur Klauser, Geoff Lowney, Steven Wallace, Vijay Janapa Reddi, and Kim Hazelwood. 2005. Pin: Building customized program analysis tools with dynamic instrumentation. In ACM Sigplan Notices, Vol. 40. ACM, 190–200. [33] Alwin Maier, Hugo Gascon, Christian Wressnegger, and Konrad Rieck. 2019.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|87d9d855adb5456191429e449dfe5b4c
TypeMiner: Recovering types in binary programs using machine learning. In Proceedings of the 16th International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment (DIMVA’19). Springer, 288–308. [34] Microsoft. [n.d.]. Antimalware Scan Interface. Retrieved August 16, 2018 from https://docs.microsoft.com/en-us/windows/desktop/ amsi/antimalware-scan-interface-portal. [35] Yuto Otsuki, Eiji Takimoto, Shoichi Saito, Eric W. Cooper, and Koichi Mouri. 2015. Identifying system calls invoked by malware using branch trace facilities. In International MultiConference of Engineers and Computer Scientists (IMECS’15). Newswood Limited. [36] Giancarlo Pellegrino, Constantin Tschürtz, Eric Bodden, and Christian Rossow. 2015. jäk: Using dynamic analysis to crawl and test modern web applications. In Proceedings of the 18th International Symposium on Research in Attacks, Intrusions and Defenses (RAID’15). Springer, 295–316. [37] Jonas Pfoh, Christian Schneider, and Claudia Eckert. 2011. Nitro: Hardware-based system call tracing for virtual machines. In Proceedings of the 6th International Workshop on Security (IWSEC’11). Springer, 96–112. [38] ReactOS Project. [n.d.]. ReactOS. Retrieved August 16, 2018 from https://www.reactos.org/. [39] Microsoft Research. [n.d.]. Detours. Retrieved April 8, 2020 from https://github.com/microsoft/Detours. [40] Rolf Rolles. 2009. Unpacking virtualization obfuscators.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|a90f0a2555d64784ae9280be18f7b7a8
In Proceedings of the 3rd USENIX Workshop on Offensive Technologies (WOOT’09). USENIX. [41] Alireza Saberi, Yangchun Fu, and Zhiqiang Lin. 2014. Hybrid-bridge: Efficiently bridging the semantic gap in virtual machine introspection via decoupled execution and training memoization. In Proceedings of the 21st Annual Network and Distributed System Security Symposium (NDSS’14). Internet Society. [42] Monirul Sharif, Andrea Lanzi, Jonathon Giffin, and Wenke Lee. 2009. Automatic reverse engineering of malware emulators. In Proceedings of the 2009 30th IEEE Symposium on Security and Privacy. IEEE, 94–109. [43] Asia Slowinska, Traian Stancescu, and Herbert Bos. 2011. Howard: A dynamic excavator for reverse engineering data structures. In Proceedings of the 18th Annual Network and Distributed System Security Symposium (NDSS’11). Internet Society, 1–20. [44] Temple F. Smith, Michael S. Waterman, et al. 1981. Identification of common molecular subsequences. Journal of Molecular Biology 147, 1 (1981), 195–197. [45] VMProtect Software. [n.d.]. VMProtect. Retrieved April 27, 2020 from https://vmpsoft.com/. [46] T. Sven. [n.d.]. JSDetox. Retrieved September 20, 2019 from http://relentless-coding.org/projects/jsdetox/. [47] PowerShell Team. [n.d.]. PowerShell. Retrieved August 16, 2018 from https://github.com/powershell. [48] Toshinori Usui, Yuto Otsuki, Yuhei Kawakoya, Makoto Iwamura, Jun Miyoshi, and Kanta Matsuura. 2019.|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|98ec59ea12314ae3a3a510bc172db19c
"My script engines know what you did in the dark: Converting engines into script API tracers. In Proceedings of the 35th Annual Computer Security Applications Conference (ACSAC’19). ACSA, 466–477. [49] Timon Van Overveldt, Christopher Kruegel, and Giovanni Vigna. 2012. FlashDetect: ActionScript 3 malware detection. In Proceedings of the 15th International Symposium on Research in Attacks, Intrusions and Defenses (RAID’12). Springer, 274–293. [50] Norman Wilde and Michael C. Scully. 1995. Software reconnaissance: Mapping program features to code. Journal of Software Maintenance: Research and Practice 7, 1 (1995), 49–62. [51] Carsten Willems, Ralf Hund, and Thorsten Holz. 2013. CXPInspector: Hypervisor-based, hardware-assisted system monitoring. Technical Report TR-HGI-2012-002 (2013), 24. [52] W. Eric Wong, Swapna S. Gokhale, Joseph R. Horgan, and Kishor S. Trivedi. 1999. Locating program features using execution slices. In Proceedings of the 1999 IEEE Symposium on Application-Specific Systems and Software Engineering and Technology (Cat. No. PR00122) (ASSET’99). IEEE, 194–203. [53] Dongpeng Xu, Jiang Ming, Yu Fu, and Dinghao Wu. 2018. VMHunt: A verifiable approach to partially-virtualized binary code simplification. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security (CCS’18). ACM, 442–458.

Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|1d8128e7b3b24d629c110cee2f528aea
"Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021.

Automatic Reverse Engineering of Script Engine Binaries for Building Script API Tracers

5:31

[54] Akira Yokoyama, Kou Ishii, Rui Tanabe, Yinmin Papa, Katsunari Yoshioka, Tsutomu Matsumoto, Takahiro Kasama, Daisuke Inoue, Michael Brengel, Michael Backes, et al. 2016. SandPrint: Fingerprinting malware sandboxes to provide intelligence for sandbox evasion. In Proceedings of the 19th International Symposium on Research in Attacks, Intrusions, and Defenses (RAID’16). Springer, 165–187. [55] Junyuan Zeng, Yangchun Fu, and Zhiqiang Lin. 2016. Automatic uncovering of tap points from kernel executions. In Proceedings of the 19th International Symposium on Research in Attacks, Intrusions and Defenses (RAID’16). Springer, 49–70. [56] Junyuan Zeng and Zhiqiang Lin. 2015. Towards automatic inference of kernel object semantics from binary code. In Proceedings of the 18th International Symposium on Research in Attacks, Intrusions and Defenses (RAID’15). Springer, 538–561. [57] Shitong Zhu, Xunchao Hu, Zhiyun Qian, Zubair Shafiq, and Heng Yin. 2018. Measuring and disrupting anti-adblockers using differential execution analysis. In Proceedings of the 25th Annual Network and Distributed System Security Symposium (NDSS’18). Internet Society.

Received May 2020; accepted August 2020

Digital Threats: Research and Practice, Vol. 2, No. 1, Article 5. Publication date: January 2021."|data_input/Akira_reports/entry_c51dc02d-33c3-43bd-8d06-82abe33b182b.text|b8c1b086a0734dcd99a12d33a819a763
"A Deep Dive

into Defacement:

How Geopolitical Events

Trigger Web Attacks

Marco Balduzzi, Ryan Flores, Lion Gu, and Federico Maggi with Vincenzo Ciancaglini, Roel Reyes, and Akira Urano

Trend Micro Forward-Looking Threat Research (FTR) Team

A TrendLabs Research Paper

Contents TREND MICRO LEGAL DISCLAIMER The information provided herein is for general information and educational purposes only. It is not intended and should not be construed to constitute legal advice. The information contained herein may not be applicable to all situations and may not reflect the most current situation. Nothing contained herein should be relied on or acted upon without the benefit of legal advice based on the

5

Our Approach to the

Investigation

particular facts and circumstances presented and nothing herein should be construed otherwise. Trend Micro reserves the right to modify the contents of this document at any time without prior notice. Translations of any material into other languages are intended solely as a convenience. Translation accuracy is not guaranteed nor implied. If any questions arise related to the accuracy of a translation, please refer to the original language official version of the document. Any

7

Targets and Methods

of Website Defacers"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|be417e4b96d04173becdec595dd66b01
"7

Targets and Methods

of Website Defacers

discrepancies or differences created in the translation are not binding and have no legal effect for compliance or enforcement purposes. Although Trend Micro uses reasonable efforts to include accurate and up-to-date information herein, Trend Micro makes no warranties or representations of any kind as to its accuracy, currency, or completeness. You agree that access to and use of and reliance on this document and the content thereof is at your own risk. Trend Micro disclaims all warranties of any kind, express or implied.

11

Real World Conflicts

Reflected in Cyberspace

Neither Trend Micro nor any party involved in creating, producing, or delivering this document shall be liable for any consequence, loss, or damage, including direct, indirect, special, consequential, loss of business profits, or special damages, whatsoever arising out of access to, use of, or inability to use, or in connection with the use of this document, or any errors or omissions in the content thereof. Use of this information constitutes acceptance for use in an “as is” condition.

54

Auxiliary Activities of

Defacement Groups

58

Conclusion

for Raimund Genes (1963



2017)"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|b5af2f0c40c14c98880751673956307a
"58

Conclusion

for Raimund Genes (1963



2017)

Web attacks—attacks that compromise internet assets like mail servers, cloud infrastructures, and websites—are troubling phenomena. The research community has put considerable effort into investigating these incidents but has mostly focused on detecting attacks and not delving into the reasons behind these attacks. Of course, the typical cybercriminal's goal is to profit. They might compromise websites to push ransomware, or they could try and steal data—recent breaches show that information is an increasingly valuable commodity. But, as this paper discusses, more emotional motivations, such as patriotism, specific real-world events or simply hacktivism, can also trigger compromises. Web defacement hacktivism is the practice of subverting a website with the goal of promoting a specific agenda or political ideology. Methods may vary, but when hacktivists compromise a website, the usual tactic involves replacing the original page with their version—a practice that is called web defacement. Hacktivism is mainly linked to web defacement, but a hacktivist (the attacker) can also be involved in traffic redirection (from a legitimate site to an attackerowned site), denial of service (a form of service disruption), and malware distribution to support their particular cause. Dedicated websites like Zone-H1 collect evidence of web defacements and defacers can voluntarily advertise their compromise by submitting a report."|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|c66efbf0d3e548ebb3109d330c12fd9b
Elaborating on the reasons behind web defacements at scale is not as easy as it seems. While someone could theorize that geopolitical events and conflicts influence cybercriminals’ attacks against websites and their choice of victims, corroborating this phenomenon requires large-scale analysis.|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|d7ffe6ffad6d4821b24209b670cb57a0
Our examination of over 13 million web defacement reports against websites spans over 18 years, covering multiple continents. We designed an internal system that gathers, analyzes, and clusters these millions of reports. As we identify the major campaigns of these defacers, we can provide further insights into how geopolitical events are reflected in web defacements. We also look at how different factors, such as the political beliefs and the decafers' religious inclination, can trigger and affect these attacks. Our first two sections provide high-level insights into our dataset of defacements, as well as some defining facts about the targets and tactics used by the defacers. Our next section on Real World Impact breaks down seven top campaigns that have affected Israel, France, India, Syria, Kosovo, and countries surrounding the South China Sea. We delve into specific conflicts in those areas and the defacements that happened in the aftermath. The succeeding sections cover the hacking groups' affiliations and how their collectives are organized—some collectives are formed across continents, and some are a loose collection of local hackers. Recruitment tools and the methods used to distribute hacking techniques are also discussed. The final sections discuss other activities that defacers take part in, and how the current activities may evolve. Recently, there have been incidents of hackers who have gone from simple web defacement to activities supporting cybercrime.|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|4f1f2894189442b5866783e29c514d32
Our Approach to the Investigation Our objectives include exploring motivations and influences behind website defacements, focusing on how geopolitical events act as triggers for web defacement activities. To better understand these dynamics globally, we gathered web defacement reports from third-party sources and processed them with an automated system we designed specifically for this purpose. Each web defacement report consists of: 1. Meta-information on the defacement, such as timestamp, website URL, the defacer's name, vulnerability, and more. 2. The deface page planted by the defacer (or modified, if this is the case). The deface page comes in the form of a source code (HTML/JS/CCS) and may contain small-sized external resources such as images. Additional content is fetched dynamically at analysis-time. Our system automatically analyzes each deface page via two components: 1. A static-code analyzer that extracts representative features (i.e., characteristics) from the page (like title, length, and encoding) in an offline manner. 2. A dynamic-code analyzer that renders the page with a headless browser and extracts additional features in an online fashion. This analyzer works better with dynamically generated pages (e.g., when a link is generated via JavaScript) or pages with external content like embedded streams of songs. The output of these components is a set of features that describe the page at high-level.|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|41caff12885d4c9694d9a37f9771276a
"These features are used as input for the following component: the campaign detector. The campaign detector looks for defacements that—we believe—are conducted by the same actor or criminal group. This is often the case with campaigns wherein multiple actors unite and conduct defacements that relate to each other, such as those with similar target choices or deface pages. In fact, defacers enlisted on the same campaign are usually provided with a template for rendering similar

5 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|270830b98f664aca820acbf61212205e
"5 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

deface pages. These templates provide consistency in promoting the criminal group and spreading the campaign's propaganda and motivations. This component groups similar pages accordingly, and represents them in form of clusters of web defacement campaigns. For this process, we make use of machine learning. We apply unsupervised learning to a set of features that well represents a summary of the pages — these are received from the static and dynamic analyzers mentioned before. The process automatically detects new campaigns and labels them for inspection. The result of this processing is indexed in an elastic-search back end and visualized via a web console. For each campaign, the console allows the analyst to inspect information like the lifespan of the campaign, the composition of the deface pages, as well as that of their actors. The console also allows analysis on how criminal groups are organized and if/when a certain actor belongs to multiple groups or moves from one to another. We will discuss the details of our system in a follow-up paper that will be released later in the year.

6 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Targets and Methods of Website Defacers As previously stated, our work is based on a large-scale analysis of 13 million website defacements that we collected from the following data sources: •

Zone



H2: 12,303,240 defacement incidents"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|72e6765a6f1249aaa37a0d8f094e1cf2
"Zone



H2: 12,303,240 defacement incidents



Hack



CN3: 386,705 defacement incidents



Mirror Zone4 (now offline): 195,398 defacement incidents



Hack Mirror5: 68,980 defacement incidents



MyDeface6 (now offline): 37,843 defacement incidents 2M

1.5M

1M

500K

0

1998

1999

2000

2001

2002

2003

2004

2005

2006

2007

2008

2009

2010

2011

2012

2013

2014

2015

2016

Figure 1. The rate of web defacement records per year

The total number of unique defacers is 104,135, and the total number of unique compromised domains is 9,929,484. Note that one domain can have multiple incidents recorded.

7 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Linux

9,074,567

Win 2003

Unknown

1,548,583

637,392

Win 2000

402,076

Win 2008

338,306

Figure 2. Operating systems of defaced web sites

Apache

IIS/6.0

Unspeciﬁed nginx

8,541,048

1,525,578

757,306

IIS/5.0

334,898

Unknown

244,402

Figure 3. Web servers of defaced websites

8 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Based on the metadata voluntarily provided by the defacers (which we cannot validate), here is a visual representation of the class of vulnerabilities leveraged by the attackers:

File Inclusion Vulnerabilities

2,384,043

SQL Injection

1,268,272

Known Vulnerability (i.e. unpatched system)

1,167,414

Attack Against the Administrator/user

(password stealing/snifﬁng)

1,114,541

Not Available

1,087,984

Other Server Intrusion"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|2f8f2762e7a2456bbaeb7ab9e2810d4d
"1,167,414

Attack Against the Administrator/user

(password stealing/snifﬁng)

1,114,541

Not Available

1,087,984

Other Server Intrusion

842,693

Other Web Application Bug

809,062

Conﬁguration/Administrative Error

493,698

Undisclosed Vulnerability

417,961

Web Server Intrusion

276,443

Brute Force Attack

257,069

FTP Server Intrusion

252,612

Social Engineering

163,579

URL Poisoning

135,700

Access Credentials through Man In the Middle Attack

126,368

SSH Server Intrusion

114,470

Remote Administrative Panel

Access through Bruteforcing

107,890

Shares Misconﬁguration

88,403

Web Server External Module Intrusion

88,038

RPC Server Intrusion

80,013

Other Modes

393,361

Figure 4. The methods of hacking as reported by defacers, based on defacement ID Information

9 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|e0b1a748b5c14f958c43c6cecfe54912
"9 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

The Role of Social Media We observed that defacers voluntarily leave contact information upon compromise, based on the features (i.e., characteristics) automatically extracted during the analysis of the deface pages. It seems to be common practice for attackers that push propaganda to advertise their beliefs and refer their “viewers” to social networking sites or provide contact emails of the group. Overall, we found that emails and Twitter are the primary forms of advertisement, with 25% (email) and 8% (Twitter) of pages displaying at least one of these. In fact, 6% of pages have multiple contact emails. In contrast, the telephone seems to be an unloved form of contact—only 3% of our attack records have telephone information. Not a surprising percentage since it may expose the defacer to attribution. Another interesting aspect of propaganda-driven attacks on websites is the addition of streaming—songs played in the background of the page or even visual aspects. Our data found that 32% of the defacements have an embedded URL referencing either a streaming provider (like YouTube) or an audio file hosted on an external resource that is most likely another compromised machine. We manually investigated some of these cases and confirmed that most of these songs are related to religion.

10 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|ffa2d1051aec4090b26ed6eb8345b807
"10 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Real-World Conflicts Reflected in Cyberspace Mass attacks, or attacks that typically use automated hacking tools to compromise as many websites as possible indiscriminately, are common across the web. But in the course of our research, we noted a more coordinated form of attack that we labeled “campaigns”. In a campaign, the attackers launch specific attacks as a reaction to certain events, to push an agenda, make known their grievances, or spread political messages. Our system allowed us to identify the top seven campaigns connected to and motivated by real-world conflicts. In the graph below, the horizontal (X) axis pertains to the number of attackers participating in a particular campaign, while the vertical (Y) axis maps the number of hacktivism-related defacements on record. The data shows that the #OpIsrael campaign garnered the most number of attackers, while Free Kashmir has the most number of defacements. We will delve deeper into these campaigns in the succeeding sections.

number of defacements

20K

15K

Free Kashmir

#opisrael

#savesyria

10K

#antiserbs

#opindia

5K

#opfrance

South China Sea

0

0

100

200

300

400

500

number of attackers

Figure 5. Overview of the top seven defacement campaigns from collected data

11 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|dfc0a602bb5c4b359dbeaccc16c52efe
"11 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Conflicts Spark Anti-Israel Defacement Campaigns So far, we've identified three major anti-Israel web defacement campaigns. The first (and the longest) is #OpIsrael, which is composed of several campaigns supported by different groups. Then there is the #OpSaveGaza campaign, which is a short, but highly effective defacement campaign in reaction to Israel's Operation Protective Edge. Last is #OpBader / #ElectronicBader / #BaderOperation, a loosely organized campaign with multiple groups participating that has gained traction since May 2016. 1,200

1,000

800

600

400

200

0

30/09/2011

31/05/2013

31/12/2013

#OpIsrael

30/07/2014

#opsavegaza

28/02/2015

30/09/2015

30/04/2016

#opelectronicbader...

Figure 6. #OpIsrael, #opsavegaza and #opbader / #electronicbader / #baderoperation timelines

The struggle between Israel and Palestine is one of the longest modern-day conflicts, starting in 1948 and continuing to this day7. Israel's continued occupation of the West Bank and military operations in Gaza only serve as fuel to the anger of Palestinians and other groups sympathetic to Palestine.

12 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

31/08/2016"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|1902dbf367774e48b3c54d7764f7449f
"12 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

31/08/2016

Target TLDs of #OpIsrael Defacements These defacements are not random. As much as possible, the hacking groups target Israeli websites, as co.il and org.il top-level domains (TLDs) rank second and sixth respectively in the distribution of defaced websites carrying anti-Israel messages. 6K

3K

0

com

co.il

org

co.uk

net

ru

com.au com.br

de

info

nl

fr

ca

it

pl

gov.gh

hu

in

org.il

co.za

Figure 7. Target sites for #OpIsrael

#OpIsrael The very first #OpIsrael web defacement was made by ""imLulzPirate"" on August 26, 2012. The website myisrael.us fell victim to the defacement, with the main page of the website altered to display a politically charged message against Israel and Zionism. The defacement embeds a YouTube video uploaded by Canadians for Justice and Peace in the Middle East, condemning the Gaza War in December 2007 – January 2008.

13 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 8. The first #OpIsrael defacement made by imLulzPirate"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|19b3f4533b464e04b47755ca67f874df
"13 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 8. The first #OpIsrael defacement made by imLulzPirate

#OpIsrael did not gain any traction after the initial defacement made by imLulzPirate. It took several months for members of the Anonymous collective to support the cause and organize a campaign against Israeli websites. The first organized large-scale defacement campaign happened on April 7, 2013, a date chosen because it coincides with Holocaust Remembrance Day. This attack has been repeated every year since then, with 326 defacers executing 11,000 plus defacements on more than 5,400 domains.

#OpIsrael Sub-campaigns #OpIsrael Engaged is a sub-campaign that started in 2015 and continued up to 2016. Similar to the main #OpIsrael campaign, it peaked every April 7. The AnonGhost team, a tight-knit group that claims to have members from Mauritania, Morocco, Malaysia, Indonesia, Tunisia, USA, and Ireland, mostly did the 2015 campaign. Anonymous Arabe, a loose group of hackers from Arabic-speaking countries in the Middle East and North Africa, was responsible for the majority of the 2016 campaign.

14 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 9. Defaced pages by AnonGhost Team and Anonymous Arabe showing identical wording for the #OpIsrael Engaged campaign"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|7b9a81b0d6a34c02969c8f35694d0d9c
"Figure 9. Defaced pages by AnonGhost Team and Anonymous Arabe showing identical wording for the #OpIsrael Engaged campaign

It is worth noting that AnonGhost seems to have either branched out to other countries or has subgroups, with AnonGhost being the umbrella group. So far we've seen AnonGhostDz, which is the Algerian sub-group, AnonGhost Indonesia, AnongGhost Gaza, AnonGhost Tunisia, AnonGhost Maldives, and AnonGhost Vietnamese. #OpIsrael Decided is another sub-campaign that started around the same time as #OpIsrael Engaged, and uses a similar message. It is supported mostly by an AnonCoders team that is a loose association of hackers from Albania, Tunisia, Morocco, Lebanon, Bangladesh, Indonesia, and France, among others.

15 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 10. #OpIsrael Decided defacement pages shows similar wording to #OpIsrael Engaged"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|0935ec0e0bbb4ba5a26a782542ead1fc
"Figure 10. #OpIsrael Decided defacement pages shows similar wording to #OpIsrael Engaged

#OpBader / #ElectronicBader / #BaderOperation This is a larger campaign with 2,759 defacement records, which is as many as the #OpIsrael Engaged and #OpIsrael Decided sub-campaigns combined. While #OpIsrael Engaged and #OpIsrael Decided had standard templates (and the participating hackers did not do much to alter these templates), #OpBader is loosely organized, with templates and messages that vary quite significantly. The only common identifiable string we can find related to this campaign is the use of these hashtags: #opisrael #alfallagaTeam #fallaga #fallagateam #tunisianfallagateam #opbader #electronicBader #baderoperation #hackers #fallagahackers ""Bader"" is a reference to the Battle of Badr, a significant battle won by the Prophet Muhammad in the early years of Islam8. These historical references strongly indicate that these hacking groups view themselves as cyber-jihadists, viewing their actions as part of a digital jihad."|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|d0c169318f89455aaeff472bf926b4e3
"#OpSaveGaza The #OpSaveGaza/#SaveGaza campaign is related to #OpIsrael since both target Israel and Israeli actions in Palestinian territories, but #OpSaveGaza/#SaveGaza is mostly influenced by events in the Gaza region specifically. On July 2014, Israel launched Operation Protective Edge, which included airstrikes and a land invasion aimed at destroying tunnels from Gaza to Israel9. Not surprisingly, the first instance of #OpSaveGaza/#SaveGaza appeared in response to the land invasion. The defacements continued until October, and only when hostilities in the Gaza strip subsided significantly did the 2014 campaign die down. #OpSaveGaza had 3,415 defacements within that short period, making it one of the most active web defacement campaigns.

16 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 11. Sample defacement pages of the #OpSaveGaza campaign

#Save Gaza #Save Gaza started in July of 2016 as a sub-campaign under #opBader, primarily driven by Anonymous Ghost Gaza. Among the sub-campaigns discussed, it has been the most vocal and the most forceful. While #OpIsrael Decided and #OpIsrael Engaged use relatively tame language, #Save Gaza incites violence and puts direct pressure on Israelis, threatening to steal credit card information, bank credentials, and other website credentials.

17 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 12. Forceful language in the defacement campaign #Save Gaza"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|22a3c6fa44d24495b1aeb8f698250b90
"17 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 12. Forceful language in the defacement campaign #Save Gaza

It is worth noting that Anonymous Ghost Gaza followed through on their threat to steal the personal information of Israeli citizens. Members of Anonymous Ghost Gaza posted Israeli citizens' credit card information and online account credentials on their Facebook page and Pastebin.

18 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 13. Hacking groups publicly expose Israeli citizens’ information and financial details

19 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Groups behind the Campaigns Hackers and hacking groups participating in #OpIsrael campaigns are mostly from Arabic-speaking countries in the Middle East and North Africa, with other groups from Bangladesh, Malaysia, and Indonesia also participating. Note that these are countries that do not recognize the validity of Israel as a state. AnonGhost

CapoO_TunisiAnoO

fallaga team

Anonymous Arabe

Dr.T3rr0r

Hitch

Memberal_Force

|N|ewbieC27 VandaThe

God

MrHax

GAZA

Fallaga Team

Black

Worm

Mohamad DexmoD

Bseso

Figure 14. Top 15 participating hacking groups and hackers"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|eff8b10a276640b3a54f12158f86c6f4
"|N|ewbieC27 VandaThe

God

MrHax

GAZA

Fallaga Team

Black

Worm

Mohamad DexmoD

Bseso

Figure 14. Top 15 participating hacking groups and hackers

The common use of the name ""fallaga"" by hackers and hacking groups in North Africa is a reference to ""felaghas"" or ""fellagha"", armed groups that were instrumental in driving out the French from Algeria in the Algerian War that lasted from the 1950s to early 1960s.

Charlie Hebdo Aftermath Results in #OpFrance On January 7, 2015, two men attacked Charlie Hebdo, a French magazine that caused controversy several times in the past through its satirical cartoons about Islam and the prophet Muhammad. The attack left 12 people dead and 11 injured10. In the aftermath, France was a target of other attacks, this time in cyberspace. The smaller campaigns under #OpFrance include #OpCharlie, #OPCHARLIEHEBDO, and #AntiCharlieHebdo.

20 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

350

175

6

6

6

01

01

/2

/2

28

25

9/

8/

6

01

/2

17

6

01

/2

24

7/

01

/2

10

1/

1/

15

3/

7/

/2

16

20

0/

/2

12

1/

3/

/1

12

20

15

20

5

15

20

15

01

/2

/6

12

12

15

20

20

2/

9/

/2

/2

5/

11

/1

11

11

5

15

01

20

5

01

/8

/2

/1

11

5/

/2

11

10

/2

5

15

01

/2

19

20

5

01

/2

12

7/

7/

7/

5

15

20

01

/2

5/

5

01

/2

28

6/

31

5

5

01

/2

24

5/

5/

15

01

20

/2

5/

12

4/

5

5

01

/2

22

3/

4/

15

01

20

/2

8/

15

3/

5

15

20

1/

3/

3/

5"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|51bc9d94af714dae9cb9187452d2c321
"/2

28

6/

31

5

5

01

/2

24

5/

5/

15

01

20

/2

5/

12

4/

5

5

01

/2

22

3/

4/

15

01

20

/2

8/

15

3/

5

15

20

1/

3/

3/

5

01

/2

22

2/

8/

20

15

01

/2

15

2/

2/

5

15

01

20

/2

25

2/

1/

5

01

/2

18

1/

01

1/

/2

4/

1/

1/

11

20

15

5

0

Figure 15. Timeline of #OpFrance—activity peaked January to March 2015, right after the Charlie Hebdo attacks

Target TLDs of #OpFrance Defacements Similar to the attacks against Israel, #OpFrance hackers were trying to target French websites, as evidenced by .fr domains having the second-most domains that had sites defaced. 500

250

0

com

fr

org

ru

dk

net

nl

com.br

de

info

com.ua

eu

co.uk

pl

be

ca

gr

com.ar gouv.fr

in

Figure 16. Target sites for #OpFrance

This campaign focused on French websites, with defacers targeting sites of companies like the French supermarket Carrefour, or sites with .fr TLDs. From our data, 36% of #OpFrance defacements have .fr TLDs.

21 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 17. Defacement pages for the #OpFrance campaign"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|563e9207fd194ea68e964c741d1d9e1f
"21 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 17. Defacement pages for the #OpFrance campaign

Hacking groups from Muslim-majority countries such as Tunisia, Syria, Mauritania, Morocco, Bangladesh and Indonesia began targeting French websites in an #OpFrance web defacement campaign that appear to be in support of the attacks. Some of the defacements even paraphrased Saudi-Australian Islamic preacher Junaid Thorne's statement on the matter, “If you want to enjoy 'freedom of speech' with no limits, expect others to exercise 'freedom of action. '”

22 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 18. Defaced page promoting Islamic preachers’ statement on Charlie Hebdo

Even though several groups were part of #OpFrance, the Middle East Cyber Army was particularly active and did the majority of the defacements. This group includes members that belong to other hacking groups such as Anonymous Arabe and some hackers from North Africa. It is worth noting that one suspected member of the Middle East Cyber Army was arrested several months after the January – March #OpFrance campaign. The Bulgarian police arrested a 21-year-old Syrian student residing in Bulgaria, believed to be the leader of the group11. Based on the defacement pages of Middle East Cyber Army, the hacker with the alias ""The Greatest"" was arrested. The group modified their defacement pages to include #OPSaveTheGreatest after the arrest."|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|684029992497452a9900f8febf406096
"Figure 19. Defaced page modified to support “The Greatest”, who was supposedly arrested in Bulgaria

23 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Groups Behind the Campaigns The visualization below shows the Middle East Cyber Army to be the most active group behind #OpFrance. AnonGhost, which was active in the anti-Israel defacements, also widely participated, as well as hackers from Mauritius (Mauritania Coder), and some from Bangladesh and Indonesia. Middle East Cyber Army

Mauritania

coder

Prosox

MrAhSan

HaXor

Mr.bz

Hani Xavi

Owner Dzz

ZeSn

Rexal

Scooterist

AnoaGhost

BL4CKT3RRORIST

Amine

Moodz

AnonGhost

Casablanca

Haxorz

Hexlook

Figure 20. Top 15 participating hacking groups and hackers

Indian Border Disputes Trigger Campaigns Like Israel, India has unresolved territorial disputes with its neighbors and sees frequent clashes along its borders. The unresolved dispute with Pakistan regarding Kashmir and Jammu, as well as the challenges of patrolling and enforcing the border between India and Bangladesh (the fifth longest land border in the world), makes for a volatile situation. It's further exacerbated by constant defacements between Pakistani and Indian hacking groups, and between Bangladeshi and Indian hacking groups.

24 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Target TLD’s of #OpIndia

500

250

0

com

in

ac.in

co.in

org

net

org.in edu.in gov.in

co

info

net.in

biz

lk"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|88d46411f825486babab6526c4c5336f
"Target TLD’s of #OpIndia

500

250

0

com

in

ac.in

co.in

org

net

org.in edu.in gov.in

co

info

net.in

biz

lk

ch

com.ar

hu

Other

biz.id

by

Figure 21. Target sites of #OpIndia

The hackers targeted Indian websites, as evidenced by the TLD's .in, ac.in, co.in, org.in, edu.in and gov. being in the top nine domains with websites defaced.

Cricket leads to #riseofthetigers Even cricket teams became a trigger for defacement campaigns, illustrating the degree of tension between India and its two neighbors. The campaign #OpIndia started on March 2015, executed by Bangladeshi hackers, after Indian politician Shashi Tharoor tweeted that he preferred to face the Bangladesh cricket team (called The Tigers) in the Cricket World Cup quarterfinals. Tharoor reportedly felt Bangladesh was a weaker team that would give India an easier path to the finals.

25 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 22. Defacement page for #OpIndia with an image of the Bangladesh cricket team featured

Figure 23. The Tharoor tweet that started the controversy"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|e15d9ee7b52f44ee83d8040ef96cea5b
"Figure 23. The Tharoor tweet that started the controversy

Free Kashmir Led by Pakistani hacking groups ZCompany Hacking Crew (ZHC) and Muslim Liberation Army, Free Kashmir is a long-standing campaign that started in 2011. The attacks began with the calling out of the illegal occupation and human rights abuses the Indian Armed Forces committed against Kashmiris12. Free Kashmir has the most number of defacements out of all the campaigns studied, despite having only around half the number of attackers that #OpIsrael had.

26 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Pakistan is India's rival claimant to the disputed territory of Kashmir, and the defacement pages of both ZHC and Muslim Liberation Army commonly quote India's Penal Code Act No. 45 of 1860, which does not include the State of Jammu and Kashmir as part of India. However, the ruler of Jammu and Kashmir, Maharaja Hari Singh, acceded both territories to India in 194713.

Figure 24. Free Kashmir campaign defacements

The messages of ZHC and the Muslim Liberation Army have a Pakistani slant and do not necessarily reflect the sentiments of the Kashmiri people. However, they may gain traction with younger Kashmiris as ZHC and Muslim Liberation Army also highlight the human rights abuses and disappearances of Kashmiri activists and militants14, an issue that has not received international attention."|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|2dfa3314bc27415ca6337ddcec029092
"Nationalism Inspires Retaliatory Hacking It is also quite common for hacking groups in India, Pakistan, and Bangladesh to start defacement campaigns against their rival country's websites. The presence of active hacking groups in neighboring, conflicting countries makes for a volatile situation, and these ""turf wars"" or ""nationalistic defacements"" can easily be triggered, and in a lot of cases, get out of hand.

27 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

One such incident happened in 2015 when a Pakistani hacker named Faisal 1337 hacked into multiple Indian websites. The government website of the state of Kerala was the most prominent website defaced.

Figure 25. Indian local government websites hacked

Immediately, hacking groups from India launched #op_pak_cyber_space, defacing hundreds of Pakistani websites in retaliation.

Figure 26. Retaliatory attack from Indian hackers

The defacement of Mumbai Airport Customs website by Pakistani defacer Alone Injector is another example. After the incident, Indian hackers retaliated with a campaign defacing the websites for Islamabad, Peshawar, Multan and Karachi airports in Pakistan.

28 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 27. Mumbai Airport Customs defacement

Figure 28. The defacement page seen on Islamabad, Peshawar, Multan and Karachi airport websites

29 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|33273753e2ce41fc960d26f26df449bc
"29 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Fallout of the Attacks between India and its Neighbors Aside from ongoing campaigns by Indian, Pakistani and Bangladeshi hackers (against or in response to each other's hacking), the real-world conflict between the three countries has significantly increased in the past two years. One event happened on January 2, 2016, when several terrorists attacked India's Pathankot Air Force base, killing several Indian military men and one civilian. The attack was later claimed and attributed to Jaish-e-Mohammed, a separatist group in Kashmir15. After the attack, Indian hacking groups retaliated by targeting Pakistani websites.

Figure 29. Retaliatory defacements made by Team Indian Black Hats aka Indian Cyber Devils

On September 18, 2016, attackers from Jaish-e-Mohammed, the same terror group responsible for the Pathankot Air Base attack a few months prior, launched another attack on an Indian army headquarters in Uri that left 17 army members dead, as well as all four attackers16. A few days later, the Indian government launched surgical strikes targeting locations in Kashmir. These series of incidents sparked back and forth campaigns between Indian and Pakistani hacking groups, with defacements containing politically charged messages, freedom slogans, or just plain hate speech.

30 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|3a147e7f45d348d79b399b2593e00f99
"30 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 30. Defacements generated by conflict with India

Another event that triggered a sizeable defacement campaign was the drafting of Nepal’s new constitution in September 2015. Some in India believed that the constitution marginalized certain ethnic groups; an issue that was highlighted when the Indian Express reported that India requested Nepal to make seven amendments to its constitution17. The report triggered an outrage in Nepal, as the message was seen as a foreign country meddling in the internal affairs of an independent sovereignty. The outrage triggered the #BackOffIndia campaign during October 2015, supported by DQN hacker and craXerbikash from Nepal, BloodSecurity from the Philippines, and several Pakistani hackers.

Figure 31. A campaign triggered by India’s involvement with Nepalese matters

31 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Groups behind the Attacks The most prominent anti-India defacements came from RiseOfTheTigers, a collective that was created just for the #OpIndia campaign in March 2015. Several Bangladeshi hacking groups joined RiseOfTheTigers: Bangladesh Grey Hat Hackers, Bangladesh Cyber Army, Team_CC, Bangladesh Script Kiddie Hackers, Blacksmith Hackers Team, 3xp1re Cyber Army, Bangladesh Black Hat Hackers, and others. RiseOfTheTigers

Criminal.BD

Mr Anonymous

Red Lizard

rootheater

Mr Anon

Xl33tX_Sn4p3R

MrAhSan HaXor"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|1772211ca86d4b40b70862bfea5cef08
"Criminal.BD

Mr Anonymous

Red Lizard

rootheater

Mr Anon

Xl33tX_Sn4p3R

MrAhSan HaXor

Zero Cool

Ghost_Root

Zain

Mr.Sh4hz3b



HaXoR Haxor

pk_Robot dulava!

Mr. Bangladesh

Figure 32. Top 15 participating hacking groups and hackers

Military Actions prompt a #SaveSyria Campaign On April 22, 2016, the Syrian government launched airstrikes targeting residential areas in Aleppo during Friday scheduled prayers. The attacks happened despite a ceasefire agreement by both sides in February 2016. There were several more airstrikes, the worst of which hit the al-Quds hospital, killing 50 people18. The incident inspired a #SaveSyria campaign that exposed graphic images of wounded civilians in Aleppo.

32 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Target TLDs of #SaveSyria

1,500

750

0

ru

com

de

it

net

org

fr

gr

nl

com.br co.uk

kz

by

ch

com.ua

pl

ﬁ

eu

be

info

Figure 33. Targeted domains of #SaveSyria

Most of the #SaveSyria defacements targeted Russian websites because many suspected that Russia was behind the April 2016 airstrikes. Russia is seen as supportive of Syrian president Bashar al-Assad, and the country has reinforced Assad's regime through air superiority assets.

Figure 34. Defaced sites showing graphic images of Aleppo

33 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|2c6cd40b55ef4a2d846314c97702b911
"Figure 34. Defaced sites showing graphic images of Aleppo

33 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

The Fallaga Team formed a loose collective called the Tunisian Cyber Resistance Al Fallaga Team, composed of Tunisian hackers and actively supported by hackers from Anonymous Arabe, Algeria, and Indonesia. They launched a defacement campaign with the hashtags #StopTheHolocaust, #AleppoIsBurning, #SaveAleppo and #SaveSyria.

Campaigns Provoked by Kosovo Disputes Kosovo is a disputed territory and partially recognized state that declared its independence from Serbia in 2008. The majority of its population is of Albanian descent, and the country enjoys friendly relations with Albania stemming from common history and traditions. In Northern Kosovo, near Serbia, there are communities of Serbian descent that refuse to acknowledge Kosovo's independence. This tension reached a boiling point in 2011 when Kosovo Police clashed with ethnic Serbian rioters who refused to remove roadblocks going into enclaves of Serbian control19. Albanian hacking groups KSG-CREW, kwgdeface and AlbanianHackers launched the #AntiSerbs campaign a few months after the initial clashes. The campaign died down before the Brussels Agreement, which involved the integration of Northern Kosovo into Kosovo and had Kosovo Serbs manning the police and judiciary, was concluded. 400

200

4

01

4

31

3/

/2

28

2/

/2

01

4

01

3

31

1/

/2

01

3

30

/2

01

6/

/2

31

3/"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|7bbbb5791ecb439fb5f7240a7d26cb94
"200

4

01

4

31

3/

/2

28

2/

/2

01

4

01

3

31

1/

/2

01

3

30

/2

01

6/

/2

31

3/

/2

01

3

12

31

1/

1/

20

12

12

/3

20

12

11

/3

20

0/

2

1/

/3

10

31

7/

/2

01

2

31

5/

/2

01

2

01

2

/2

19

4/

/2

01

2

01

31

3/

/2

29

2/

/2

01

2

11

31

1/

1/

20

11

/3

20

12

0/

/3

11

10

/3

1/

20

11

0

Figure 35. Timeline of anti-Serbs campaign

The defacement pages showed support for Kosovo independence, and also mentioned contested towns commonly involved in civil unrest. They listed Serbian-controlled territories bordering Kosovo with an Albanian majority and declared their desire to separate from Serbia and join Kosovo.

34 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 36. Web defacement pages supporting Kosovo

Disputes in the South China Sea OpPhilippines and OpTaiwan On May 9, 2013, a maritime incident involving the Taiwanese fishing boat Guang Da Xing No. 28 and the Philippine Coast Guard resulted in the death of Taiwanese fisherman Hung Shih-cheng (洪石成)20. This incident led to many consequences, including sanctions and a military drill from Taiwan government, protests in Taiwan, and several cyberattacks. On May 10, 2013, people in Taiwan called for DDoS attacks against .gov.ph to force the Philippine government into issuing an official apology. Many hackers responded, attacking more than 30 .gov.ph sites21."|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|0a55b43c22a64a5cadb82359c955c744
"35 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 37. Forum post mobilizing visitors to launch DDoS attack

On May 11, Filipino hacker ""Pinoy Vendetta""22 sent a warning message to Taiwanese hackers by defacing one Taiwan government site and several commercial sites. In response, AnonTaiwan launched #OpPhilippines the next day.

36 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 38. Web defacement page from ""PinoyVendetta""

After the attack, AnonTaiwan posted leaked data from .gov.ph sites on Pastebin. One noteworthy victim was dns.gov.ph, which is the .gov.ph domain registry website. More than 2,300 accounts, which were possible admin accounts for .gov.ph domains, were leaked. These government sites faced a huge risk. Potentially, attackers could change the name servers of domain names, government domain names would have resolved to invalid IP addresses, and important sites would have been inaccessible to the public.

37 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 39. Information leaked on Pastebin

On May 25, 2013, Filipino hackers attacked 31 .tw sites in a campaign titled #OpTaiwan as a response to #OpPhilippines. The defaced pages displayed the messages, ""Stop attacking our cyberspace"" and ""Let our government handle this problem.""

38 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 40. Web defacement pages for #OpTaiwan"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|3aab939918634dd2bf887ce5c0675b51
"38 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 40. Web defacement pages for #OpTaiwan

Defacements over Territory Six countries—China, Taiwan, Philippines, Vietnam, Malaysia, and Brunei—are contesting several islands and features, rock outcrops, sandbars, and reefs in the South China Sea. Over the last few years, the tension between China and Vietnam, and China and Philippines has increased. China has taken aggressive action, from coast guard patrols to building facilities and installations in various contested areas. This has sparked defacement activities by several groups from Philippines, Vietnam, and China against their rival countries' websites.

Attacker

Team

越南国宰相

1937cn

oaddah

1937cn

ZeSn

Anonymous Philippines

YoCo Smart

Silic Group

Nama Defacer

Anonymous Philippines

AnonReaper

Anonymous Philippines

BloodSecurity

BloodSecurity

HukbalaHack

Anonymous Philippines

Anonymous Philippines

Anonymous Philippines

AlfabetoVirtual

1937cn

Figure 41. Top defacers participating in South China Sea defacements, and the groups they belong to

39 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|a6ed1eb5bd044c3d80d311bc1e5b6810
"39 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Early Attacks in 2011 Chinese marine surveillance vessels cut the cables of Vietnamese oil survey vessels in the South China Sea23. This incident triggered defacement attacks that started on June 3, 2011. A Vietnamese defacer 'Mr.N - Cubi11' attacked Chinese government websites. The page displayed Vietnamese patriotic slogans like ""Vietnamese People is Willing to Sacrifice to Protect the Sea, Sky, and Nation."" More Vietnamese defacers joined this campaign after24.

Figure 42. Vietnamese defacer page

From June 4, 2011, Chinese defacers started to retaliate by attacking .vn websites. Hongke Union (HUC), a well-known Chinese hacktivist group, mobilized its members and launched a series of attacks. Over 30 .gov.vn sites were defaced.

40 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 43. Chinese defacers retaliate"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|1bb5e78a6d8e461eaf9848c70cf819fc
"40 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 43. Chinese defacers retaliate

After completing the attacks, the HUC sent out a summary reporting that their attacks were from June 4 to June 5, two function groups were created (one for DDoS, one for defacement), and several QQ chat groups and YY chat channels were created to coordinate attacks25. Some non-HUC hackers also joined the attack, compromising over 1,000 sites. Most of the victims suffered DDoS attacks and defacement. One popular Vietnamese search engine site was inaccessible for five hours. During the attacks, HUC found Vietnamese defacers attacking .cn sites. Chinese hacker group Silic also joined the retaliation. In their deface pages, Silic claimed that ""(Vietnamese defacers) first stir up trouble, we just attack back."" This group attacked 98 .vn websites on June 8. Most victims were .gov.vn sites26.

41 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 44. Silic Group defacement page

OpChinaDown, 2012 On April 10, 2012, a standoff between the Philippine Navy and Chinese maritime surveillance ships over the disputed Scarborough Shoal (Huangyan in Chinese) in the South China Sea caused tension between the two countries. In response, Chinese defacers compromised the website of the University of the Philippines on April 20, 2012, leaving a message that claimed, “We come from China! Huangyan Island is Ours”."|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|ef72e182790d4acdaf2bf603d012a26a
"42 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 45. Defaced page of University of the Philippines

The defacer group ""Anonymous #OccupyPhilippines"" responded on the same day, compromising several .cn sites. The statement ""Scarborough Shoal is ours!"" was prominent on the deface page27. Three days later, on April 23, the government of the Philippines claimed that two of its sites suffered DDoS attacks coming from Chinese IP addresses—an apparent retaliatory attack from China. Defacements escalated quickly, triggered by the DDoS attacks28.

43 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 46. Page from #OccupyPhilippines

On the same day, OccupyPhilippines and PrivateX launched a joint attack operation ""#OpChinaDown"". They attacked .gov.cn sites and posted DB schema and login credentials of victim sites on Pastebin. On April 25, the Silic group (the same organization that attacked .vn sites in 2011) joined the web defacement campaign and targeted .gov.ph sites. Besides derogatory statements against Philippine defacers, the page allowed visitors to leave messages on it. Over the course of 3 hours, over 30 visitors left messages on the defaced pages29.

44 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 47. Silic defacement page, where you can leave messages"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|b6dd85e7c26a4d7d87696d64e5d8392c
"44 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 47. Silic defacement page, where you can leave messages

Chinese hacktivism group 1937cn joined the defacement war on June 1, 2012. This group created a very long deface page to convince viewers to believe in their message. 1937cn spread that page across 173 sites in five days.

StopReclamation and OpChina, 2015 China started reclamation and building on the Spratly archipelago of the South China Sea in April 201530. This action caused a wave of defacement attacks. BloodSec, a Philippine defacer group, launched a #StopReclamation campaign on April 26, 2015.

45 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 48. BloodSec defacement page

Tensions escalated a month later. Posting on Pastebin31, defacers from the Philippines and Vietnam declared the beginning of an #OpChina campaign on May 28, 2015. In the announcement, they called themselves ""the united hackers from the Philippines and Vietnam,"" aiming to ""protest your (China) unjust actions over the South China Sea"". At the end of the announcement, they left a note that read ""Expect us! 5/30/2015"".

Figure 49. Joint message from Vietnamese and Filipino hackers, and their defacement pages"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|538e7b08706544fe98be66d3b4e40018
"Figure 49. Joint message from Vietnamese and Filipino hackers, and their defacement pages

This is the first time defacers from the two South East Asian countries united for a common political cause. A series of attacks hit .cn sites on the date stated in their warning message—August 30, 2015. Most of the victims were .gov.cn sites. The message left by the group Anonymous Philippines asked the Chinese

46 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

government to ""stop the reclamation, do not put or establish any structure in that location."" At the same time, ""AnonGhost"" from Vietnam put out the message, ""Stop the infringements of sovereignty island.""

Figure 50. Retaliation from Chinese hackers

On the same day, Chinese defacer team ""1937cn"" retaliated by defacing .vn sites, and blamed it on the joint action of defacers from Philippines and Vietnam. 1937cn also claimed that ""South China Sea is China's inherent territory."" 1937cn's response was very quick—they likely noted the joint announcement of the defacers from the Philippines and Vietnam, and carefully prepared the retaliation."|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|770938c1b7a84dc793494583d2cea05f
"Attacks on Vietnamese Airports, 2016 On July 12, 2016, the Hague Permanent Court of Arbitration ruled in favor of the Philippines against China in an arbitration case about the disputes in the South China Sea. The ruling triggered a series of cyberattacks against Vietnam32. On July 29, 2016, the Chinese hacker group 1937cn attacked two major airports in Vietnam and the website of Vietnam Airlines33. They defaced the home page with the same page used in 2015 during the #OpChina defacement campaign. Then the hacker group leaked client information of Vietnam Airlines34. This was not the first time 1937cn attacked Vietnam Airlines; the group also launched a similar attack on May 30, 2015.

47 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 51. Client information from Vietnam Airlines"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|f0a9e4f8006745c9ab7b974a67b916d4
"47 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Figure 51. Client information from Vietnam Airlines

The Civil Aviation Administration of Vietnam reported several attacks, supposedly from 1937cn team, on two Vietnam airports within the same day. The IT system for the check-ins of Vietnam Airlines at Tan Son Nhat International Airport was attacked and stopped working. The deface page, which was the same page used on the Vietnam Airlines website, replaced the flight information screens at Noi Bai International Airport. The speaker system at Noi Bai airport was also compromised by hackers for a few minutes, during which the speakers broadcast an announcement against territory dispute. According to the Civil Aviation Administration of Vietnam, the attack caused the delay of 100 flights, affecting thousands of passengers35. This incident might hint at future hacktivism trends: to reach a wider audience, hacktivists could potentially broaden their targets from traditional websites to critical infrastructures such as airports.

48 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Hacking Groups’ Connections and Campaigns Deface groups are formed by a loose affiliation between hackers. They can be defined as ""loose"" since hackers can be affiliated with one or more of these hacking groups, even across territories.

Indonesian

Code Party

gunz_berry

AnonCoders

Moroccan Ethical

Hackers

Myanmar Noob

Hackers

Virus Noir"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|306b161672c34e848cc5a3b9da4f5b8e
"Indonesian

Code Party

gunz_berry

AnonCoders

Moroccan Ethical

Hackers

Myanmar Noob

Hackers

Virus Noir

darkshadow



tn

Albania

Attacker

dr.t3rror

Fallaga Team

Anonymous

Albania

Arab Warriors

Team

Anonghosts

Figure 52. The hacking group AnonCoders

As an example, see the group AnonCoders, which lists gunz_berry, Virus Noir, darkshadow-tn, Albania Attacker and dr.t3rr0r as its core members. However, gunz_berry is also affiliated with Indonesian Code Party, while Virus Noir is affiliated with Moroccan Ethical Hackers, darkshadow-tn with Fallaga Team, and dr.t3rr0r with Myanmar Noob Hackers. Albania Attacker is affiliated with three other groups—Anonymous Albania, Arab Warriors Team, and Anonghosts. AnonCoders shows how hackers can also be members of various groups, and how hackers from different countries can form a group. Other examples showing the liquidity of group membership are Pakistan's two biggest hacking groups: ZCompany Hacking Crew and Muslim Liberation Army. Both have fairly large teams; ZCompany Hacking Crew has at least 30 members, and Muslim Liberation Army has around 26. Below you can see seven hackers who are members of both groups simultaneously, as we've seen defacements made by both teams acknowledging the hackers in their defacement pages within the same time frame.

49 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Bozz error

Zolo

Silent Hell

Toshiro

RoCk

Dropper

Gen

HardHunter

Sniper

Zarrar

Radical"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|34309709c92a46debfe7924b4b78d962
"Bozz error

Zolo

Silent Hell

Toshiro

RoCk

Dropper

Gen

HardHunter

Sniper

Zarrar

Radical

Assassin

Metallic

Xenon

Syed Zadaa

(Mindy)

Papaas

PCCS

MongoOse

Hard Hunter

Chf Code

Dorian

Gray

Zology

PCF

Velocity

Bozz Hacker

Don

ZCompany

Hacking Crew

Hothead

Zulﬁ

Ibrar Buttz

Madni

Muslim Liberation

Army

Milan Milo

Killer Mind

Tazii

TriCk aka

Saywhat?

MasterMind

Nabeel

Unknown

Xaha

Silence

Destiny

Unknown

Hax

Cobra Black

Zarb



E



Momin

De Decorum

Angel

XtreMiSt

Pak Jaguars

KillerMind

Haxor

Nabeel

(Master Mind)

Hawk

fAchO

HyP3r



Boy

Jerry

Hassan

Faisy Ali

Laghari

Figure 53. Members of the ZCompany Hacking Crew and the Muslim Liberation Army"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|718f160a525346f79a6ff87f6411f98d
"Hawk

fAchO

HyP3r



Boy

Jerry

Hassan

Faisy Ali

Laghari

Figure 53. Members of the ZCompany Hacking Crew and the Muslim Liberation Army

Collectives Hacking groups can also band together to form bigger groups or collectives. The well-known group Anonymous is a model for this. They can rightly be considered the biggest hacking collective in the world based on the numerous hacking groups who identify and associate themselves with the name “Anonymous”. On a smaller scale, a collective can be formed simply to support a campaign. Take, for example, the defacements done by Bangladeshi hackers against Indian websites, triggered by the Cricket World Cup. The collective Rise of the Tigers was borne out of various Bangladeshi hacking groups working together: 3xp1r3 Cyber Army, Blacksmith Hacker's Team, Cyb3r Command0S, Bangladesh Grey Hat Hackers, Bangladesh Black HAT Hackers, Cyber Sword and Bangladesh Script Kidde Hackers.

50 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Campaign Recruitment and Tools Certain individuals or groups loosely organize hacktivism campaigns. They set time frames for a particular campaign, and even use social media to coordinate and launch these campaigns.

Figure 54. Facebook calendar used to schedule defacement activities

Figure 55. Social media post used to spread templates for defacement scripts

51 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|9c41a851d2f54ce68e55ed8e762ddbdc
"51 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

They use calendar event features like Facebook Events to organize campaigns. They also advertise campaigns on their team pages and actively recruit other hackers and hacking groups to participate. Tools, targets, and defacement page templates are also shared openly by those participating in a campaign.

Figure 56. Tools spread through social media and sharing sites

52 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Certain groups also set up team websites to host content, post announcements, and facilitate discussions through forums. These commonly have sections for tutorials, tools, and kits.

Figure 57. Different community sites hosting forums, downloads, news and more

53 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Auxiliary Activities of Defacement Groups Besides tools and defacement templates, these groups also share attack techniques. For example, groups post hacking tutorials on GitHub and upload tutorial videos to streaming sites.

Figure 58. Tools and tutorials for different hacking activities shared by defacers

54 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|567b367e1c044e05b781a5f8b4499d7d
"54 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Defacers are also contributing to Exploit-DB, which is is an open-source database for sharing exploit codes and security papers. To find the number of defacers that are also active on Exploit-DB, we compared our list of known defacers against this list of authors36 from Exploit-DB: •

Total defacer/hacker alias that are also listed as Exploit-DB authors: 790 of 7,858 (10.05%)



PoC submitted by possible defacers: 6,380 of 36,576 (17.44%) indoushka

294

ZoRLu

221

ajann

204

cr4wl3r

130

Hussin X

121

CWH Underground

115

t0pP8uZz

105

AtT4CKxT3rR0r1ST

96

JosS

HACKERS PAL

74

69

Mr.SQL

68

EgiX

67

bd0rk

65

CoBRa_21

64

InjEctOr5

63

Figure 59. Top 15 defacers who shared exploit codes

Web Apps

83.53%

Remote

5.72%

DOS

5.63%

Local

4.26%

Shellcode

0.86%

Figure 60. Breakdown of exploit types submitted by possible defacers

55 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Escalating into Real-World Terrorism Activities Hackers who participate in defacement and also other forms of hacking can also segue into more serious crimes, possibly also driven by real-world disputes and political agendas. An example would be the case of Team P0ison's founder Junaid Hussain (TriCk), who started notable defacements in 2010.

Figure 61. Sample of defaced pages done by TriCk supporting Free Kashmir"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|cafe75a9605248fdba206ab062e19dba
"Figure 61. Sample of defaced pages done by TriCk supporting Free Kashmir

Hussain was arrested in 2014 for hacking into Katie Kay's (special advisor to British Prime Minister Tony Blair) email account and leaking PM Blair's personal information37. After six months in jail, Junaid Hussain traveled to Syria and joined ISIS. He took the name Abu Hussain al-Britani, and is believed to be the person behind the hack of U.S. Central Command's Twitter and YouTube accounts. He is also believed to have been killed in a US air strike in Syria in 201538.

Defaced Sites as Unwitting Infection Sources Aside from actively committing criminal activities, defacement pages can unwitting carriers of malware code. In the course of our research, we saw the malware Ramnit distributed through malicious websites or packaged as fake software installers. Ramnit is an actively developed malware family whose main goal is to steal banking credentials. It also evolved to include worm propagation capabilities, as well as the ability to infect files, including HTML files. Ramnit does this by appending a VBscript code at the end of the HTML file found in the affected machine. The infected HTML file contains code to install a copy of the Ramnit malware. Unfortunately, some defacers’ machines were infected by Ramnit and had their web defacement templates infected to include the malicious VBscript. This, in turn, made their defacement pages unwitting distributors of the Ramnit malware."|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|729206c7ab5440c7903783e3f1ce9a39
"56 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Based on our records, 9,726 defacements were seen to include the Ramnit VBscript. Below are the top 30 defacers who were infected by Ramnit and had their compromised web defacement pages distribute the malware. Most of the defacers were either from Arabic-speaking countries in the Middle East and North Africa or from China. In a serendipitous turn of events, the top defacer that unwittingly spread Ramnit goes by the nickname ""stupid"". stupid

1,708

Cyb3r_Sw0rd

1,289

Fallaga Team

399

H.M.L



小北

310

gunz_berry

279

By：小康

276

Med Max

258

Anwar Dreno

236

BlackVirus

152

AnonGhost

145

Baws



DZ

136

Zalim

129

SnIpEr_SA

127

chinafans

127

UMCA

118

Owner Dzz

116

Turkhackteam.Org

95

By 刺心

93

MrCyberError404

87

HakANT

79

Team_CC

78

by:大

76

Sp@rK CoD3R

73

Anonymous Arabe

68

dulava!

62

fallaga team

61

xamd

56

KkK1337

55

ll_azab_siyah_ll

53

星

51

Figure 62. Defacers who were unknowingly spreading Ramnit through their defacement pages

57 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|3ac39f6d13394f09869a7ccb830dbaa1
"57 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Conclusion As seen in the examples above, real-world conflict can trigger web defacement on a large scale. One event can lead to a campaign that brings hacking groups together, and large collectives can sustain defacement campaigns for long periods of time. Most are politically or religiously motivated, and attackers are typically keen to express fervent patriotism over specific causes. While these web defacement activities seem relatively benign, it is plausible for defacers to move on to other hacking activities and criminal behavior.

Web Defacements and IoT Web defacements are going to continue in the foreseeable future, and may even become more prevalent as more Internet of Things (IoT) devices are connected online.

Figure 63. Router control panel replaced with a hacker’s page

58 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|28f0b8f5f3ae4948ae47e2f9cf063af2
"Figure 63. Router control panel replaced with a hacker’s page

58 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

The above screenshot shows a defaced router control panel, changing the title of the HTML page to ""You hacked from iraq(fb\arakan"". A lot of people may not realize that IoT devices have stripped down versions of web servers that host their control panels and management consoles. The setup is something that would be relatively easy for a defacer to exploit and compromise. In the case of the router defacement above, the attacker might not even have known that he was able to deface a non-traditional/IoT website. Exploits for vulnerabilities of common web applications or server components are also applicable and effective on non-traditional/IoT websites. It would be simple for a defacer to transition into compromising connected IoT devices. With the growing number of IoT devices, it might be appealing for defacers to continue down that route."|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|887dc17314ab4b7cab0989aeec168a97
Hacktivism in the Future There are various vulnerabilities that attackers exploit to deface websites to push their specific agenda. But despite compromising these web sites that contain potentially sensitive data (PII, account credentials, transaction histories, etc), most defacers have yet to abuse their access further. They are seemingly content just to deface the site. However, the delineation between pure web defacement and cybercriminal or cyberespionage activity is disappearing. Hackers are now increasingly involved in developing web shells (backdoors to maintain access to compromised web servers), and also delving into doxing and leaking stolen data. After defacing websites, the next step would seem to be capitalizing on the available information on compromised sites. Apart from individuals, defacement groups have yet to monetize their activities. According to our data, 99.9% of the web defacement pages are harmless. Pages found containing malicious code are mostly infected by VBS_RAMNIT.SMC. These pages were unknowingly infected, and not intentionally put online to spread malicious code. These defacers had their templates infected by the malware and unwittingly spread the Ramnit malware. A troubling scenario is if these defacement groups decide to monetize their successful hacks by, for example, installing malicious redirections or exploit code in the defacement pages that would then install ransomware.|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|acd4e7aa923545a2b741276d24cbf912
"As previously mentioned, so far these defacements have been benign and motivated by real-world conflicts or political agendas. However, cybercriminals could easily use hacks for profit-driven criminal activities. We have already seen some instances of this. There were reports of Indian hackers targeting Pakistani servers and users to install ransomware for ""patriotic"" purposes39. If this continues and escalates, then the line between defacers, hacktivists, and cybercriminals will become even more blurred.

59 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

How can enterprises protect their sites? Based on the major vulnerabilities used by defacers, there are simple steps that can secure servers against these threats. If practiced and deployed consistently, these tips can help enterprises have long-term security: •

Ensure that basic security policies are employed and maintained longterm: strong passwords, proper administration security policies, and correct configuration.



Use web application firewalls to filter, monitor, and block malicious traffic. Security is necessary at the web application level.



Practice secure coding. Organizations must implement secure coding standards on all their sites.



Regularly use testing tools to ensure deployed codes are secure.



Make patching systems and networks a part of standard policy. This prevents cybercriminals from exploiting vulnerabilities in unpatched/ outdated software."|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|e02b1695265e4253abfe4bde6c367d1e
"Regularly scan web applications for vulnerabilities: Organizations need to check their web apps for vulnerabilities as these can lead to SQL injection and cross-site scripting attacks.



Use multi-layered protection that secures vulnerable websites from the common attacks used by defacers. Solutions like Trend Micro™ Deep Security™ and Vulnerability Protection provides virtual patching that protects servers and endpoints from threats that may abuse vulnerabilities.

60 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

References

1.

Zone-H archives. (n.d.) Zone-H Unrestricted Information. Last accessed on 11 November 2017 at http://www.zone-h.org/

2.

Ibid

3.

Hack CN. (n.d.). 全球被黑站点统计|黑客技术检测|黑客入侵攻击. Last accessed on 17 November 2017 at http://www.hack-cn. com/.

4.

http://www.mirror



zone.org (offline)

5.

H4ck Mirror. (n.d.) Hack Mirror. Last accessed on 16 November 2017 at http://www.hack-mirror.com/.

6.

http://www.mydeface.com (offline)

7.

BBC Newsround. (20 February 2015). BBC Newsround. “Guide: Why are Israel and the Palestinians fighting over Gaza?” Last accessed 16 November 2017 at http://www.bbc.co.uk/newsround/20436092.

8.

Al-Islam. (n.d.) AI-Islam.org. “The Battle of Badr”. Last accessed 14 Nov 2017 at https://www.al-islam.org/articles/battle-badr.

9."|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|8b2b5bf0439f4d06846a73d70108bd22
"8.

Al-Islam. (n.d.) AI-Islam.org. “The Battle of Badr”. Last accessed 14 Nov 2017 at https://www.al-islam.org/articles/battle-badr.

9.

Yifa Yaakov. (5 August 2014). The Times of Israel. “After 29 days, Operation Protective Edge by the numbers”. Last accessed 17 November 2017 at https://www.timesofisrael.com/after-29-days-operation-protective-edge-by-the-numbers/."|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|2709523140484500892d782788987f73
10. ABC. (8 January 2015). ABC News. “Charlie Hebdo shooting: 12 people killed, 11 injured, in attack on Paris offices of satirical newspaper”. Last accessed 14 November 2017 at http://www.abc.net.au/news/2015-01-07/charlie-hebdo-satiricalnewspaper-shooting-paris-12-killed/6005524. 11. AFP/Reuters. (16 July 2017). Deutsche Welle. “'Cyber Army' hacker arrested, says Bulgaria”. Last accessed 17 November 2017 at http://www.dw.com/en/cyber-army-hacker-arrested-says-bulgaria/a-18586433. 12. Rifat Fareed. (27 Ovtober 2017) Al Jazeera. “'Black day' in Kashmir marks 1947 Indian army arrival”. Last accessed 17 November 2017 at http://www.aljazeera.com/news/2017/10/day-kashmir-marks-1947-indian-army-arrival-171027122649223.html. 13. Maps of India. (n.d.) Maps of India. “26th October 1947: Maharaja Hari Singh agrees to the accession of Jammu and Kashmir to India” Last accessed 16 November 2017 at https://www.mapsofindia.com/on-this-day/26th-october-1947-maharaja-harisingh-agrees-to-the-accession-of-jammu-and-kashmir-to-india. 14. Aijaz Hussain. (10 December 2013). The San Diego Union Tribune. “Activists, families protest Kashmir disappearances”. Last accessed 13 November 2017 at http://www.sandiegouniontribune.com/sdut-activists-families-protest-kashmirdisappearances-2013dec10-story.html. 15. Rupam Jain. (19 December 2016) Reuters.|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|5be1ab5f0cae45d89aee0c0ec5455693
"“India indicts Pakistan-based militants over Pathankot air base attack” Last accessed 17 November 2017 at http://in.reuters.com/article/india-pakistan-attack/india-indicts-pakistan-based-militantsover-pathankot-air-base-attack-idINKBN1480QO. 16. Hari Kumar and Geeta Anand. (18 September 2016). The New York Times. “17 Indian Soldiers Killed by Militants in Kashmir” Last accessed 17 November 2017 at https://www.nytimes.com/2016/09/19/world/asia/17-indian-soldiers-killed-by-militantsin-kashmir.html. 17. Shubhajit Roy. (24 September 2015). The Indian Express. “Make seven changes to your Constitution: India tells Nepal”. Last accessed 2 November 2017 at http://indianexpress.com/article/world/neighbours/make-seven-changes-to-your-constitutionaddress-madhesi-concerns-india-to-nepal/. 18. Medecins Sans Frontieres. (26 April 2016). MSF.org. “Syria: Update on airstrike at Al Quds hospital”. Last accessed 17 November 2017 at http://www.msf.org/en/article/syria-update-airstrike-al-quds-hospital.

61 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|b0d11c6026d24d29bfe73eaf7ab44c8c
19. Die Morina. (2 Match 2017) Balkan Transitional Justice. “Mitrovica’s Flashpoint Bridge Symbolises Kosovo’s Divisions”. Last accessed 17 November 2017 at http://www.balkaninsight.com/en/article/mitrovica-s-flashpoint-bridge-symbolises-kosovo-sdivisions-03-01-2017. 20. Tarra Quismundo. (16 April 2016). Inquirer. “PCG men ordered to pay Taiwan family”. Last accessed 17 November 2017 at http://globalnation.inquirer.net/138653/pcg-men-ordered-to-pay-taiwan-family. 21. Sofia Wu. (13 May 2013) Focus Taiwan. “Shooting ignites Taiwan-Philippines cyber war “, Last accessed 16 November 2017 at http://focustaiwan.tw/news/atod/201305130041.aspx. 22. Clifford Trigo. (11 May 2013). Pinoy Hack News. “Pinoy Vendetta sends warning message to Taiwan, defaces 5 websites”. Last accessed 17 November 2017 at https://www.pinoyhacknews.com/pinoy-vendetta-sends-warning-message-to-taiwandefaces-5-websites. 23. Petro Vietnam. (1 June 2011) PetroVietnam. “Chinese ships destroy Vietnam sea cable”. Last accessed 17 November 2017 at https://www.youtube.com/watch?v=w1H6zcuXjJ8. 24. ChinaAZ. (8 June 2011). Cheng Cold Blog. “Many websites in the South China Sea were attacked by Vietnamese hackers and Chinese hijackers counterattacked”. Last accessed 17 November 2017 at http://www.bj3gweb.com/Link201106_WebAttack_ ChinaAndVietnam.html. 25. Ibid 26. Kafan. (5 June 2011) Kafan.cn. “Many domestic websites were attacked by Vietnamese hackers”.|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|fc0a5cf049c44a289219409e12d3f013
Last accessed on 16 November 2017 at http://bbs.kafan.cn/thread-999960-1-1.html. 27. Xiao Bian. (6 May 2012). Freebuf. “My Filipino Maid is a Hackers - China and the Philippines network war”. Last accessed 16 November 2017 at http://www.freebuf.com/news/913.html. 28. Edwin Lacierda. (23 April 2012). Official Gazette. “Statement of Presidential Spokesperson Edwin Lacierda”. Last accessed on 16 November 2017 at http://www.officialgazette.gov.ph/2012/04/23/statement-of-the-presidential-spokesperson-on-thedenial-of-service-attack-on-pcdspo-maintained-websites-april-23-2012/. 29. Rappler. (25 April 2012) Rappler. “DBM website hacked”. Last accessed on 24 November 2017 at https://www.rappler.com/ nation/4341-dbm-website-hacked. 30. Reuters. (9 April 2015) CNBC. “China mounts detailed defence of South China Sea reclamation”. Last accessed on 223 November 2017 at http://www.cnbc.com/2015/04/09/china-mounts-detailed-defence-of-south-china-sea-reclamation.html. 31. Pastebin. (28 May 2015) #OpChina Official Index. Last accessed 15 November 2017 at https://pastebin.com/xii97KNy. 32. Anni Piiparinen. (22 July 2016). The Diplomat. “China’s Secret Weapon in the South China Sea: Cyber Attacks”. Last accessed 18 November 2017 at https://thediplomat.com/2016/07/chinas-secret-weapon-in-the-south-china-sea-cyber-attacks/. 33. Vietnam News (29 July 2016). Vietnam News. “Chinese hackers attack VN’s airports and Vietnam Airlines’ website”.|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|66d2f45fe7044382814ffbe937c4d9cb
"Last accessed 16 November 2017 at http://vietnamnews.vn/society/300416/chinese-hackers-attack-vns-airports-and-vietnamairlines-website.html#vecZdAWfcqd8iKGz.97. 34. Tara Seals. (29 July 2016). Info-Security Magazine. “Chinese Hackers Attack Airports Across Vietnam”. Last accessed 15 November 2017 at https://www.infosecurity-magazine.com/news/chinese-hackers-attack-airports/. 35. Vietnam News (29 July 2016). Vietnam News. “Chinese hackers attack VN’s airports and Vietnam Airlines’ website”. Last accessed 16 November 2017 at http://vietnamnews.vn/society/300416/chinese-hackers-attack-vns-airports-and-vietnamairlines-website.html#vecZdAWfcqd8iKGz.97.

62 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|332b9a2a910c41a58634fa14815558d1
"62 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

36. GitHub. The Official Exploit Database Repository. Last accessed on 16 November 2017 at https://github.com/offensivesecurity/exploit-database. 37. Gianlucca Mezzofiore. (2 July 2014). International Business Times. “Team Poison's Junaid Hussain Jailed for Tony Blair Hack and Phone Bombing Anti-Terror Hotline”. Last accessed on 20 November 2017 at http://www.ibtimes.co.uk/team-poisonphone-bomb-hacker-anti-terror-367660. 38. Spencer Ackerman, Ewan MacAskillin and Alice Ross. (27 August 2015). The Guardian. “Junaid Hussain: British hacker for Isis believed killed in US air strike”. Last accessed 16 November 2017 at https://www.theguardian.com/world/2015/aug/27/junaidhussain-british-hacker-for-isis-believed-killed-in-us-airstrike. 39. India Defense News. (7 October 2016). India Defense News. ""‘Patriotic’ Indian Hackers Lock Pakistani Websites and Refuse to Give Back the Key"". Last accessed on November 17 at http://www.indiandefensenews.in/2016/10/patriotic-indian-hackerslock-pakistani.html.

63 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Created by:"|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|48055d16402047be93f53e47ccfc694f
"63 | A Deep Dive into Defacement: How Geopolitical Events Trigger Web Attacks

Created by:

The Global Technical Support and R&D Center of TREND MICRO TREND MICROTM Trend Micro Incorporated, a global cloud security leader, creates a world safe for exchanging digital information with its Internet content security and threat management solutions for businesses and consumers. A pioneer in server security with over 20 years experience, we deliver top-ranked client, server, and cloud-based security that fits our customers’ and partners’ needs; stops new threats faster; and protects data in physical, virtualized, and cloud environments. Powered by the Trend Micro™ Smart Protection Network™ infrastructure, our industry-leading cloud-computing security technology, products and services stop threats where they emerge, on the Internet, and are supported by 1,000+ threat intelligence experts around the globe. For additional information, visit www.trendmicro.com.

www.trendmicro.com

©2018 by Trend Micro, Incorporated. All rights reserved. Trend Micro and the Trend Micro t-ball logo are trademarks or registered trademarks of Trend Micro, Incorporated. All other product or company names may be trademarks or registered trademarks of their owners."|data_input/Akira_reports/entry_71730c99-c9ff-4295-b4d8-71f8d77e13dc.text|395e3340137047dead26265c0d97fa8d
