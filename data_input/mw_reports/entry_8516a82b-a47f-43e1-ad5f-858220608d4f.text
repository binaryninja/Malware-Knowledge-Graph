Evolution of Malware Sandbox Evasion Tactics – A
Retrospective Study
mcafee.com/blogs/other-blogs/mcafee-labs/evolution-of-malware-sandbox-evasion-tactics-a-retrospective-study/
September 9, 2019

Executive Summary
Malware evasion techniques are widely used to circumvent detection as well as analysis and
understanding. One of the dominant categories of evasion is anti-sandbox detection, simply
because today’s sandboxes are becoming the fastest and easiest way to have an overview
of the threat. Many companies use these kinds of systems to detonate malicious files and
URLs found, to obtain more indicators of compromise to extend their defenses and block
other related malicious activity. Nowadays we understand security as a global process, and
sandbox systems are part of this ecosystem, and that is why we must take care with the
methods used by malware and how we can defeat it.
Historically, sandboxes had allowed researchers to visualize the behavior of malware
accurately within a short period of time. As the technology evolved over the past few years,
malware authors started producing malicious code that delves much deeper into the system
to detect the sandboxing environment.

1/14

As sandboxes became more sophisticated and evolved to defeat the evasion techniques, we
observed multiple strains of malware that dramatically changed their tactics to remain a step
ahead. In the following sections, we look back on some of the most prevalent sandbox
evasion techniques used by malware authors over the past few years and validate the fact
that malware families extended their code in parallel to introducing more stealthier
techniques.
The following diagram shows one of the most prevalent sandbox evasion tricks we will
discuss in this blog, although many others exist.

Delaying Execution
Initially, several strains of malware were observed using timing-based evasion techniques
[latent execution], which primarily boiled down to delaying the execution of the malicious
code for a period using known Windows APIs like NtDelayExecution, CreateWaitTableTImer,
SetTimer and others. These techniques remained popular until sandboxes started identifying
and mitigating them.

2/14

GetTickCount
As sandboxes identified malware and attempted to defeat it by accelerating code execution,
it resorted to using acceleration checks using multiple methods. One of those methods, used
by multiple malware families including Win32/Kovter, was using Windows API GetTickCount
followed by a code to check if the expected time had elapsed. However, we observed several
variations of this method across malware families.

This anti-evasion technique could be easily bypassed by the sandbox vendors simply
creating a snapshot with more than 20 minutes to have the machine running for more time.

API Flooding
Another approach that subsequently became more prevalent, observed with Win32/Cutwail
malware, is calling the garbage API in the loop to introduce the delay, dubbed API flooding.
Below is the code from the malware that shows this method.

Inline Code
We observed how this code resulted in a DOS condition since sandboxes could not handle it
well enough. On the other hand, this sort of behavior is not too difficult to detect by more
involved sandboxes. As they became more capable of handling the API based stalling code,

3/14

yet another strategy to achieve a similar objective was to introduce inline assembly code that
waited for more than 5 minutes before executing the hostile code. We found this technique in
use as well.

Sandboxes are now much more capable and armed with code instrumentation and full
system emulation capabilities to identify and report the stalling code. This turned out to be a
simplistic approach which could sidestep most of the advanced sandboxes. In our
observation, the following depicts the growth of the popular timing-based evasion techniques
used by malware over the past few years.

Hardware Detection
Another category of evasion tactic widely adopted by malware was fingerprinting the
hardware, specifically a check on the total physical memory size, available HD size / type
and available CPU cores.
These methods became prominent in malware families like Win32/Phorpiex,
Win32/Comrerop, Win32/Simda and multiple other prevalent ones. Based on our tracking of
their variants, we noticed Windows API DeviceIoControl() was primarily used with specific
4/14

Control Codes to retrieve the information on Storage type and Storage Size.
Ransomware and cryptocurrency mining malware were found to be checking for total
available physical memory using a known GlobalMemoryStatusEx () trick. A similar check is
shown below.
Storage Size check:

Illustrated below is an example API interception code implemented in the sandbox that can
manipulate the returned storage size.

Subsequently, a Windows Management Instrumentation (WMI) based approach became
more favored since these calls could not be easily intercepted by the existing sandboxes.

5/14

6/14

Here is our observed growth path in the tracked malware families with respect to the Storage
type and size checks.

CPU Temperature Check
Malware authors are always adding new and interesting methods to bypass sandbox
systems. Another check that is quite interesting involves checking the temperature of the
processor in execution.
A code sample where we saw this in the wild is:

7/14

The check is executed through a WMI call in the system. This is interesting as the VM
systems will never return a result after this call.

CPU Count
Popular malware families like Win32/Dyreza were seen using the CPU core count as an
evasion strategy. Several malware families were initially found using a trivial API based
route, as outlined earlier. However, most malware families later resorted to WMI and
stealthier PEB access-based methods.
Any evasion code in the malware that does not rely on APIs is challenging to identify in the
sandboxing environment and malware authors look to use it more often. Below is a similar
check introduced in the earlier strains of malware.

8/14

There are number of ways to get the CPU core count, though the stealthier way was to
access the PEB, which can be achieved by introducing inline assembly code or by using the
intrinsic functions.

9/14

One of the relatively newer techniques to get the CPU core count has been outlined in a
blog, here. However, in our observations of the malware using CPU core count to evade
automated analysis systems, the following became adopted in the outlined sequence.

User Interaction
Another class of infamous techniques malware authors used extensively to circumvent the
sandboxing environment was to exploit the fact that automated analysis systems are never
manually interacted with by humans. Conventional sandboxes were never designed to
emulate user behavior and malware was coded with the ability to determine the discrepancy
between the automated and the real systems. Initially, multiple malware families were found
to be monitoring for Windows events and halting the execution until they were generated.
Below is a snapshot from a Win32/Gataka variant using GetForeGroundWindow and
checking if another call to the same API changes the Windows handle. The same technique
was found in Locky ransomware variants.

Below is another snapshot from the Win32/Sazoora malware, checking for mouse
movements, which became a technique widely used by several other families.

10/14

Malware campaigns were also found deploying a range of techniques to check historical
interactions with the infected system. One such campaign, delivering the Dridex malware,
extensively used the Auto Execution macro that triggered only when the document was
closed. Below is a snapshot of the VB code from one such campaign.

11/14

The same malware campaign was also found introducing Registry key checks in the code for
MRU (Most Recently Used) files to validate historical interactions with the infected machine.
Variations in this approach were found doing the same check programmatically as well.
MRU check using Registry key:
\HKEY_CURRENT_USER\Software\Microsoft\Office\16.0\Word\User MRU

Programmatic version of the above check:

Here is our depiction of how these approaches gained adoption among evasive malware.

Environment Detection
Another technique used by malware is to fingerprint the target environment, thus exploiting
the misconfiguration of the sandbox. At the beginning, tricks such as Red Pill techniques
were enough to detect the virtual environment, until sandboxes started to harden their
architecture. Malware authors then used new techniques, such as checking the hostname
against common sandbox names or the registry to verify the programs installed; a very small
number of programs might indicate a fake machine. Other techniques, such as checking the

12/14

filename to detect if a hash or a keyword (such as malware) is used, have also been
implemented as has detecting running processes to spot potential monitoring tools and
checking the network address to detect blacklisted ones, such as AV vendors.
Locky and Dridex were using tricks such as detecting the network.

Using Evasion Techniques in the Delivery Process
In the past few years we have observed how the use of sandbox detection and evasion
techniques have been increasingly implemented in the delivery mechanism to make
detection and analysis harder. Attackers are increasingly likely to add a layer of protection in
their infection vectors to avoid burning their payloads. Thus, it is common to find evasion
techniques in malicious Word and other weaponized documents.

McAfee Advanced Threat Defense
McAfee Advanced Threat Defense (ATD) is a sandboxing solution which replicates the
sample under analysis in a controlled environment, performing malware detection through
advanced Static and Dynamic behavioral analysis. As a sandboxing solution it defeats
evasion techniques seen in many of the adversaries. McAfee’s sandboxing technology is
armed with multiple advanced capabilities that complement each other to bypass the evasion
techniques attempted to the check the presence of virtualized infrastructure, and mimics
sandbox environments to behave as real physical machines. The evasion techniques
described in this paper, where adversaries widely employ the code or behavior to evade from
detection, are bypassed by McAfee Advanced Threat Defense sandbox which includes:

13/14

Usage of windows API’s to delay the execution of sample, hard disk size, CPU core
numbers and other environment information .
Methods to identify the human interaction through mouse clicks , keyboard strokes ,
Interactive Message boxes.
Retrieval of hardware information like hard disk size , CPU numbers, hardware vendor
check through registry artifacts.
System up time to identify the duration of system alive state.
Check for color bit and resolution of Windows .
Recent documents and files used.
In addition to this, McAfee Advanced Threat Defense is equipped with smart static analysis
engines as well as machine-learning based algorithms that play a significant detection role
when samples detect the virtualized environment and exit without exhibiting malware
behavior. One of McAfee’s flagship capability, the Family Classification Engine, works on
assembly level and provides significant traces once a sample is loaded in memory, even
though the sandbox detonation is not completed, resulting in enhanced detection for our
customers.

Conclusion
Traditional sandboxing environments were built by running virtual machines over one of the
available virtualization solutions (VMware, VirtualBox, KVM, Xen) which leaves huge gaps for
evasive malware to exploit.
Malware authors continue to improve their creations by adding new techniques to bypass
security solutions and evasion techniques remain a powerful means of detecting a sandbox.
As technologies improve, so also do malware techniques.
Sandboxing systems are now equipped with advanced instrumentation and emulation
capabilities which can detect most of these techniques. However, we believe the next step in
sandboxing technology is going to be the bare metal analysis environment which can
certainly defeat any form of evasive behavior, although common weaknesses will still be
easy to detect.
Thomas Roccia
Thomas Roccia is senior security researcher on the Advanced Threat Research team. He
works on threat intelligence, tracking cybercrime campaigns and collaborating with law
enforcement agencies. In a previous role,...

14/14