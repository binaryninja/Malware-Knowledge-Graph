Calypso APT
2019
ptsecurity.com

Содержание

1

Calypso APT

2

Исходный вектор

3

Продвижение по сети

4

Атрибуция

4

Анализ вредоносного кода Calypso RAT

6

Дроппер

6

Установочный BAT-скрипт

7

Shellcode x86 — Stager

9

Модули

10

Команды

11

Сетевой код

13

Shellcode x64 – Stager (Base backdoor)

13

Модули

14

Команды

15

Сетевой код

18

Другие варианты

20

Дроппер-stager

20

Hussar

20

Инициализация

20

Модули

22

FlyingDutchman

23

Заключение

26

Индикаторы компрометации

26

Файловые индикаторы

26

MITRE ATT&CK

28

Calypso APT
Впервые активность группы Calypso была выявлена
специалистами PT Expert Security Center в марте 2019 года,
в ходе работ по обнаружению киберугроз. В результате
было получено множество образцов ВПО данной группы, выявлены пострадавшие организации и контрольные
серверы злоумышленников.
По нашим данным, группа активна как минимум с сентября 2016 года. Основной целью группы является кража
конфиденциальных данных, основные жертвы — государственные учреждения из Бразилии, Индии, Казахстана,
России, Таиланда, Турции.
Полученные нами данные позволяют считать, что группа
имеет азиатские корни1.

1.

См. раздел «Атрибуция».

2

Исходный вектор
Злоумышленники получали доступ к внутренней сети скомпрометированной организации
через ASPX-веб-шелл. Они загружали веб-шелл посредством эксплуатации уязвимости
или же могли взломать одну из стандартных учетных записей для сервисов удаленного
доступа. Нам удалось получить живой трафик между злоумышленниками и веб-шеллом.

Рисунок 1. Часть записанного трафика

Трафик показывает, что подключение осуществлялось с IP-адреса 46.166.129.241. На этом
узле располагается домен tv.teldcomtv.com, который является контрольным сервером для
трояна данной группы. Таким образом, контрольные серверы используются не только для
управления ВПО, но и для доступа к узлам скомпрометированных инфраструктур.
Через веб-шелл злоумышленники загружали утилиты1 и ВПО2, исполняли различные
команды, а также распространяли ВПО внутри сети. Примеры команд из трафика можно
увидеть ниже.

Рисунок 2. Команды, посланные на веб-шелл

1.

См. раздел «Продвижение по сети».

2.

См. раздел «Анализ вредоносного кода Calypso RAT».

3

Продвижение по сети
Для продвижения внутри скомпрометированной сети группа использовала общедоступные утилиты и эксплойты:


SysInternals,





Nbtscan,



EarthWorm,



Mimikatz,



OS_Check_445,

WmiExec,



ZXPortMap,



DoublePulsar,



TCP Port Scanner,



EternalBlue,



Netcat,



EternalRomance.



QuarksPwDump,

Для хранения ВПО и утилит на скомпрометированных машинах группа использовала либо
C:\RECYCLER, либо C:\ProgramData. Первый вариант использовался только на машинах с
системами Windows XP или Windows Server 2003 с NTFS на диске C.
Злоумышленники продвигались внутри сети либо с помощью эксплуатации уязвимости
MS17-010, либо с помощью украденных учетных данных. В одном случае через 13 дней
после получения доступа внутрь сети злоумышленники с помощью DCSync через Mimikatz
получили Kerberos ticket доменного администратора и с его помощью перемещались по
сети и заражали новые машины.

Рисунок 3. Получение данных учетной записи через DCSync

Использование многих названных выше утилит является стандартным для многих APTгрупп; большинство этих утилит являются легитимными и используются специалистами
для администрирования сети. Этот фактор позволяет злоумышленникам дольше оставаться незамеченными.

Атрибуция
В одной из атак группа использовала ВПО Calypso RAT, PlugX и троян Byeby. Calypso RAT
является уникальным ВПО для данной группы и его детальный анализ будет приведен ниже.
PlugX

традиционно

используют

многие

APT-группы

азиатского

происхождения.

Использование PlugX не указывает на какую-то конкретную группировку, но в целом свидетельствует в пользу ее азиатских корней.
Троян Byeby1 использовался в атаках во время кампании SongXY5 в 2017 году. Используемая
здесь версия является модифицированной. Группа, которая проводила данную кампанию,
также имеет азиатские корни и проводила целевые атаки на организации ВПК и правительственные структуры России и стран СНГ. Однако явной связи между данными вредоносными кампаниями мы не обнаружили.
Во время анализа трафика между сервером злоумышленников и веб-шеллом мы обнаружили, что злоумышленники использовали не анонимный прокси-сервер. В заголовке
X-Forwarded-For передавался, предположительно, реальный (то есть первый в цепи прокси-серверов) IP-адрес злоумышленников (36.44.74.47).

1.

unit42.paloaltonetworks.com/unit42-threat-actors-target-government-belarus-using-cmstar-trojan/

2.

ptsecurity.com/upload/corporate/ru-ru/analytics/Cybersecurity-threatscape-2017-Q4-rus.pdf

4

Рисунок 4. Заголовки запроса к веб-шеллу

IP-адрес принадлежит провайдеру China Telecom. Мы предполагаем, что злоумышленники по неосторожности неверно настроили прокси-сервер, чем выдали свой реальный
IP-адрес. Это первое свидетельство азиатского происхождения группы.

Рисунок 5. Информация о найденном IP-адресе

Злоумышленники также оставили множество системных артефактов, следов в конфигурациях утилит и вспомогательных скриптах, по которым можно сделать вывод о происхождении группы.
Так, например, в одном из конфигурационных файлов DoublePulsar был указан внешний
IP-адрес 103.224.82.47, предположительно — для тестирования; при этом во всех остальных конфигурационных файлах были внутренние адреса.

Рисунок 6. IP-адрес, найденный в конфигурации DoublePulsar

Указанный IP-адрес, также как и предыдущий, принадлежит китайскому провайдеру и,
скорее всего, был оставлен злоумышленниками по невнимательности. Это второе свидетельство азиатского происхождения группы.

Рисунок 7. Информация о найденном IP-адресе

5

Мы также обнаружили BAT-скрипты, которые запускали утилиты для проброса портов
ZxPortMap и EarthWorm. Внутри них были обнаружены сетевые индикаторы www.sultris.
com и 46.105.227.110.

Рисунок 8. Сетевые индикаторы, найденные в BAT-скриптах

Указанный домен не только использовался для туннелирования трафика, но и являлся
контрольным сервером для ВПО PlugX, которое также было обнаружено нами в скомпрометированной системе. Как мы уже упоминали, PlugX традиционно используют группы
азиатского происхождения; это третье свидетельство.
Итак, используемое злоумышленниками ВПО, а также используемая ими сетевая инфраструктура — свидетельствуют об азиатском происхождении группы.

Анализ вредоносного кода Calypso RAT
Структура ВПО и процесс его установки на узлы скомпрометированной сети выглядят
следующим образом.

Рисунок 9. Общая структура ВПО и его установка

Дроппер
Дроппер извлекает из себя полезную нагрузку в виде установочного BAT-скрипта и CABархива и сохраняет ее на диск. Встроенная внутрь дроппера полезная нагрузка имеет
magic-заголовок, поиск которого осуществляет дроппер. Пример структуры пейлоада
можно видеть на рисунке ниже.

6

Рисунок 10. Структура полезной нагрузки, зашитой в дроппере

Для шифрования и расшифровки данных дроппер использует собственный алгоритм, в
котором использует CRC32 как PRNG. Алгоритм выполняет арифметические операции
сложения (вычитания) между генерируемыми данными и данными, которые необходимо
зашифровать (расшифровать).

Рисунок 11. Собственный алгоритм дроппера для шифрования и расшифровки

Расшифрованная полезная нагрузка сохраняется на диск по пути %ALLUSERSPROFILE;\
TMP_%d%d, где два последних числа заменяются на случайные, получаемые с помощью
вызовов функции rand(). В зависимости от конфигурации в CAB-архиве содержатся либо
DLL и зашифрованный шеллкод, либо DLL c закодированным загрузчиком в ресурсах,
либо EXE-файл. Последний вариант нам обнаружить не удалось.

Установочный BAT-скрипт
Используемый BAT-скрипт закодирован с помощью метода подстановки из заранее заданного словаря символов, который инициализирован в одной из переменных установочного
скрипта.

Рисунок 12. Пример обфускации установочного скрипта

В раскодированном скрипте можно увидеть комментарии, которые дают подсказки об
основных функциях скрипта:


REM Goto temp directory & extract file (пойти в директорию TEMP и извлечь туда
файлы),



REM Uninstall old version (удалить старую версию),



REM Copy file (скопировать файл),

7



REM Run pre-install script (запустить установочный BAT-скрипт),



REM Create service (создать сервис для запуска ВПО при старте системы),



REM Create Registry Run (создать значение в ветке реестра для автозапуска).

В начале каждого скрипта можно увидеть набор переменных, которые скрипт использует
для сохранения файлов, модификации сервисов, модификации ключей реестра.

Рисунок 13. Инициализирующие переменные в деобфусцированном скрипте

В одном из самых ранних образцов ВПО, скомпилированном в 2016 году, мы обнаружили
скрипт, в котором присутствовали комментарии для конфигурации всех переменных.

Рисунок 14. Ранний вариант скрипта с комментариями

8

Shellcode x86 — Stager
В большинстве проанализированных семплов дроппер был сконфигурирован для выполнения шеллкода. Дроппер сохранял на диск DLL и зашифрованный шеллкод. Название
шеллкода всегда повторяло название DLL, но имело расширение .dll.crt. Шеллкод зашифрован таким же алгоритмом, что и полезная нагрузка в дроппере. Шеллкод выполняет роль
стейджера, который предоставляет интерфейс для взаимодействия с С2 и для загрузки
модулей. Имеет два способа взаимодействия с С2 через TCP и SSL. SSL реализуется через
библиотеку mbed_tls.
Начальный анализ шеллкода показал, что помимо динамического поиска API-функций
выполняется еще одна операция, повторяющая процесс настройки адресов PE-файла.
Структура таблицы настройки адресов также повторяет схожую таблицу из PE-файла.

Рисунок 15. Структура релокаций шеллкода

Так как процесс настройки адресов шеллкода повторяет процесс настройки адресов PE-файла, можно выдвинуть предположение, что изначально ВПО компилируется в
PE-файл, и после этого билдером превращается в шеллкод. В пользу этого говорит и то,
что внутри шеллкода обнаружена отладочная информация.

Рисунок 16. Отладочная информация внутри шеллкода

После динамического поиска API-функций и настройки адресов происходит разбор конфигурации, которая зашита внутри шеллкода. Конфигурация содержит информацию об
адресе контрольного сервера, используемом протоколе и типе подключения.

Рисунок 17. Пример конфигурации шеллкода

Далее создается подключение к С2. Генерируется случайный заголовок пакета, который
отправляется на С2. В ответ ВПО получает сетевой ключ, который сохраняется и впоследствии используется при каждом взаимодействии с С2. Далее собирается информация о
зараженной машине и отправляется на С2.
Затем запускаются три потока. Один представляет собой heartbeat, который раз в 54 секунды
отправляет пустой пакет на С2. Другой занимается непосредственной обработкой команд
от С2 и их выполнением. Назначение третьего установить доподлинно невозможно, так как
вырезан участок кода, отвечающий за его функциональность. Можно лишь сказать, что этот
поток, аналогично первому, должен был «просыпаться» раз в 54 секунды.

9

Модули
На данный момент нам не удалось обнаружить какие-либо модули. Но по анализу кода
взаимодействия шеллкода и модулей мы можем сказать об их функциональности.Каждый
модуль представляет собой шеллкод, которому передается управление по нулевому
смещению. Также каждый модуль существует в отдельном контейнере. Под контейнером
подразумевается процесс, внутрь которого внедряется загруженный модуль. По умолчанию таким процессом является svchost.exe. При создании контейнера в него внедряется
небольшой шеллкод, который осуществляет бесконечный sleep. Он также зашит внутрь
основного шеллкода, и, вероятно, JustWait.pdb относится именно к нему.
Модуль внедряется внутрь с помощью обычного writeprocess и запускается либо с помощью NtCreateThreadEx, либо — если ВПО запущенно на ОС с версией ниже чем Vista — с
помощью CreateRemoteThread.
Также для каждого модуля создаются два пайпа: один для передачи данных от модуля
на С2 и другой для получения данных от С2. Вероятно, модули не имеют своего сетевого
кода и используют пайпы для взаимодействия с внешним управляющим сервером через
основной шеллкод.

Рисунок 18. Создание пайпов для модулей

Каждый модуль обладает своим уникальным идентификатором, который назначается С2.
Контейнеры также отличаются по способу запуска. Контейнер может быть запущен в конкретной сессии, открытой в ОС, или в той, в которой запущен stager. Запуск контейнера
в конкретной сессии осуществляется путем получения хендла токена, авторизованного
в сессии пользователя, с последующим запуском процесса от имени этого пользователя.

10

Рисунок 19. Создание процесса контейнера в другой сессии

Команды
Исследованное ВПО может обработать 12 команд. Все они так или иначе относятся к работе с модулями. Ниже перечислены все идентификаторы команд, обнаруженные ВПО, вместе с теми, что отправляет само ВПО в различных ситуациях.

Идентификатор

Направление

Тип

Описание
Создать описатель модуля. Данная команда
содержит информацию о размере модуля и его

0x401

От С2

Команда

идентификаторе, а также выделяет память под
данные модуля. Эта команда, вероятно, должна быть первой в цепочке команд, приводящих
к загрузке модуля
Принять данные модуля, и если все данные

0x402

От С2

Команда

приняты, то осуществить запуск модуля внутри
контейнера, запущенного в той же сессии,
что и stager
То же, что и 0x402, только запуск модуля

0x403

От С2

Команда

осуществляется в контейнере, запущенном
в другой сессии
Записать данные в пайп для модуля,

0x404

От С2

Команда

запущенного внутри контейнера,
работающего в той же сессии, что и stager

0x405

От С2

Команда

Записать данные в пайп для модуля,
запущенного в контейнере в другой сессии
Сгенерировать константу с помощью вызова

0x409

От С2

Команда

GetTickCount() и сохранить ее. Данная константа
используется в описанном выше третьем потоке,
назначение которого установить не удалось

11

Запустить модуль, если размер буфера хранящегося в описателе модуля равен размеру моду0х201

От С2

Команда

ля. Не осуществляет прием данных, в отличие
от команд 0х402 и 0х403. Модуль запускается
в контейнере, работающем в той же сессии,
что и stager
То же, что и 0х201, только запуск модуля осу-

0х202

От С2

Команда

ществляется в контейнере, работающем в другой сессии
Закрыть все пайпы, связанные с конкретным

0х203

От С2

Команда

модулем, работающим в контейнере, который
запущен в той же сессии, что и stager
То же, что и 0х203, только для модуля, работаю-

0х204

От С2

Команда

щего в контейнере, который запущен в другой
сессии
Собрать информацию о сессиях, открытых

0x206

От С2

Команда

в системе, и отправить ее на С2 (идентификаторы сессий, имена машин и т. п.)
Назначить идентификатор сессии. Данный иден-

0х207

От С2

Команда

тификатор будет использоваться для запуска
контейнеров в этой сессии
Данный идентификатор используется в пустых

0x409

От ВПО

Ответ

heartbeat-пакетах (описанный выше первый
поток)

0x103

От ВПО

Ответ

0x302

От ВПО

Ответ

Идентификатор пакета, содержащего информацию о зараженной машине
Идентификатор пакета, отправляемого после
сохранения принятого идентификатора сессии
(команда 0х207)
Идентификатор пакета, отправляемого после

0х304

От ВПО

Ответ

успешного внедрения модуля внутрь контейнера. Данный код отправляется после запуска
модуля в другой сессии

0х303

От ВПО

Ответ

То же, что 0х304, только модуль был запущен
внутри той же сессии, что и stager
Идентификатор пакета, который содержит дан-

0x406

От ВПО

Ответ

ные, которые записал в свой пайп модуль, работающий в контейнере, который запущен в той же
сессии, что и stager

12

0x407

От ВПО

Ответ

Аналогично 0х406, только от модуля,
запущенного в другой сессии

0x308

От ВПО

Ответ

если не удалось получить хендл токена автори-

Идентификатор пакета, отправляемого в случае,
зованного пользователя в сессии
Идентификатор пакета, отправляемого в случае,
если невозможно получить информацию о сессиях. Перед отправкой пакета осуществляется
0x408

От ВПО

Ответ

проверка версии ОС, и если она ниже, чем Vista,
то считается, что реализованным в ВПО способом получить информацию невозможно, так как
используемые API-функции Windows появились
начиная с версии Vista

Сетевой код
Инициализация сетевого взаимодействия происходит после получения сетевого ключа
от С2. Для этого ВПО отправляет на С2 случайную последовательность из 12 байт. В ответ
оно ожидает также 12 байт, где по нулевому смещению должно располагаться то же значение (_DWORD), что и перед отправкой. Если эта проверка проходит, то из ответа берутся
4 байта по смещению 8 и затем выполняется их расшифровка с помощью RC4. В качестве
ключа выступают 4 байта, которые были отправлены ранее, располагающиеся также по
смещению 8. Полученные в результате этого данные и являются сетевым ключом, который
сохраняется и впоследствии используется при отправке данных.
Все передаваемые пакеты имеют следующую структуру:
struct Packet{
struct PacketHeader{
_ DWORD key;
_ WORD cmdId;
_ WORD szPacketPayload;
_ DWORD moduleId;
};
_ BYTE [max 0xF000] packetPayload;
};
Для каждого пакета генерируется случайный 4-байтовый ключ, которым впоследствии
зашифровывается часть заголовка начиная с поля cmdId; с его же помощью шифруется и
полезная нагрузка пакета. Для шифрования используется алгоритм RC4. Сам ключ шифруется с помощью операции XOR c сетевым ключом и сохраняется в соответствующее
поле заголовка пакета.

Shellcode x64 — Stager (Base backdoor)
Данный шеллкод очень похож на предыдущий, однако его стоит описать отдельно, так как
он обладает рядом отличий в сетевом коде, а также в способе, которым запускаются модули. Этот шеллкод имеет базовые функции по взаимодействию с файловой системой, которых нет в ранее описанном шеллкоде. Также данный шеллкод имеет сходство по формату
конфигурации, сетевому коду и сетевым адресам, используемым в качестве С2, с кодом из
поста в блоге NCC Group от 2018 года о вариации Gh0st RAT 1. Однако связи с Gh0st RAT мы
не обнаружили.
1.

nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2018/april/
decoding-network-data-from-a-gh0st-rat-variant/

13

В данном варианте шеллкода реализован всего один канал взаимодействия через SSL.
Шеллкод имплементирует его с помощью двух легитимных библиотек libeay32.dll и ssleay32.
dll, зашитых непосредственно внутрь шеллкода.
Вначале происходит динамический поиск API-функций и загрузка SSL-библиотек. SSLбиблиотеки не сохраняются на диск, а сразу вычитываются из шеллкода и маппятся в
память. Затем ВПО ищет в размеченном образе функции, необходимые для его работы.
Далее происходит разбор конфигурационной строки, также зашитой внутрь шеллкода.
Конфигурация содержит информацию об адресах серверов управления, а также расписание, по которому оно будет работать.

Рисунок 20. Пример конфигурационной строки

После запускается основной цикл работы ВПО. Осуществляется проверка того, является
ли текущее время рабочим временем ВПО, если это не так, то ВПО засыпает примерно на
7 минут и затем проводит проверку еще раз. И так до тех пор, пока текущее время не окажется рабочим, и только тогда ВПО продолжит свою работу. Обратите внимание на рис.
20, в данном примере ВПО будет активно во все дни недели и во все часы.
Когда наступило рабочее время, ВПО начинает последовательно пытаться подключиться
ко всем указанным в конфигурации С2. Первый, к которому удалось подключиться, будет
принят в качестве рабочего.
Далее отправляется информация о зараженной машине (имя компьютера, текущая дата,
версия ОС, разрядность процессора, разрядность ОС, IP-адреса на сетевых интерфейсах, а также их MAC-адреса). Отправив информацию о зараженной машине, ВПО ожидает
ответа от С2, и если С2 возвращает необходимый код, то операция отправки информации
о зараженной машине считается успешной, и ВПО продолжает свою работу, а иначе ВПО
возвращается к этапу последовательного перебора адресов С2. Далее запускается процесс обработки команд, приходящих от С2.

Модули
Каждый модуль — это валидный MZPE-файл, который размечается в адресном пространстве того же процесса, в котором работает шеллкод. Также модуль может экспортировать символ GetClassObject, на который передается управление при его запуске (если это
необходимо).
Каждый модуль имеет свой описатель, который создается в результате выполнения команды от контрольного сервера. Контрольный сервер присылает массив байтов, описывающий модуль (размером 0x15). Данный массив содержит информацию о модуле: необходимо ли его запускать через экспорт, тип модуля (по факту — нужны ли ему пайпы для
обратной связи), размер модуля, RVA точки входа (используется, если не установлен флаг
запуска через экспорт) и ключ для расшифровки данных модуля. Этот ключ представляет
собой, по большому счету, данные, которые используются для форматирования настоящего ключа.

14

Рисунок 21. Расшифровка модуля

Также отметим, что расшифровка производится — только если modKey не равен зашитой
внутрь шеллкода константе 7AC9h. Эта проверка влияет только на процесс дешифровки.
Если все же modKey будет равен константе, ВПО перейдет сразу к загрузке модуля. Это
будет означать, что модуль не зашифрован.
Для запуска каждого модуля создается отдельный поток, внутри которого и запускается
модуль. Процесс запуска с пайпами следующий:


ВПО создает поток для модуля, начинается процесс маппинга модуля и передача ему
управления внутри созданного для него потока;



ВПО создает новое подключение до текущего рабочего С2;



ВПО создает пайп с именем, получаемым по форматной строке \\.\pipe\
windows@#%02XMon (значение, которое будет вставлено вместо %02X,
передается с С2 вместе с командой на запуск модуля);



ВПО запускает два потока, транслирующие данные из пайпа на С2 и с С2
в пайпы с использованием подключения, созданного на предыдущем этапе.
Внутри потоков создаются еще два пайпа — \\.\pipe\windows@#%02Xfir и \\.\pipe\
windows@#%02Xsec. Пайп с окончанием fir используется для передачи данных от
модуля до С2. Пайп с окончанием sec используется для передачи данных и команд от
С2 до модулей.

Второй поток, который обрабатывает команды от С2 до модулей, имеет свой собственный
обработчик. О нем подробнее написано в разделе команд, но сейчас отметим только то,
что одна из команд может запустить локальный асинхронный TCP-сервер. Он будет принимать данные от того, кто у нему подключится, передавать их на С2 и пересылать их с
С2 обратно. Он биндится на адрес 127.0.0.1 и на тот порт, на который получится, начиная с
5000, последовательно перебирая их.

Команды
Ниже приведены идентификаторы команд, которые может принимать ВПО, а также те, что
отправляет само ВПО в различных ситуациях.

Идентификатор

Направление

Тип

Описание

0x294C

От С2

Команда

Создать описатель модуля

15

0x2AC8

От С2

Команда

Принять данные, содержащие модуль,
и сохранить их

0x230E

От С2

Команда

Запустить модуль без создания
дополнительных пайпов

0x2D06

От С2

Команда

Разрушить объект описателя модуля

0x590A

От С2

Команда

Запустить встроенный модуль работы
с файловой системой

0x3099

От С2

Команда

Запустить модуль, а также создать
дополнительные пайпы для взаимодействия

0x1C1C

От С2

Команда

Самоудаление. Выполняется BAT-скрипт,
удаляющий persistence и очищающий созданные
директории

0x55C3

От С2

Команда

Загрузить файл с машины на С2

0x55C5

От С2

Команда

Рекурсивный листинг директории

0x55C7

От С2

Команда

Загрузить файл с С2 на машину

0x3167

От С2

Команда

Записать данные в пайп с окончанием «Mon»

Записать в пайп с окончанием «Mon» команду
0x38AF

От С2

Команда

0x38AF. После этого завершается открытое
соединение для модуля. Возможно, означает
«завершить работу модуля»

0x3716

От С2

Команда

Переслать данные модуля другому модулю

0x3A0B

От С2

Команда

То же, что и 0x3099

0x3CD0

От С2

Команда

Запустить асинхронный TCP-сервер,
транслирующий данные между С2 и клиентом,
который подключится к нему

0x129E

От ВПО

0x132A

От С2

Ответ

Ответ

Данный идентификатор имеет пакет,
содержащий информацию о машине

Данный идентификатор имеет пакет,
приходящий от С2 в ответ на отправку данных
о зараженной машине. Получение такого пакета
расценивается ВПО как успешная отсылка
информации о машине

16

0x155B

От ВПО

Ответ

Данный идентификатор имеет
пакет, содержащий информацию
об инициализированных описателях модулей.
Пакет выполняет роль “GetCommand”.
Ответ на него содержит одну из возможных
команд

0x2873

От ВПО

Ответ

Данный идентификатор имеет пакет,
отправляемый в случае, если инициализация
описателя модуля прошла успешно (0x294C)

Ответ

Данный идентификатор имеет пакет,
отправляемый в случае, если инициализация
описателя модуля завершилась с ошибкой
(0x294C)

Данный идентификатор имеет пакет,
отправляемый после принятия данных
модуля(0x2AC8). Содержит в себе количество
уже сохраненных байтов

0x2D06

От ВПО

0x2873

От ВПО

Ответ

0x2743

От ВПО

Ответ

0x2D06

От ВПО

Ответ

Данный идентификатор имеет пакет,
отправляемый после того, как описатель модуля
был разрушен (0x2D06)

0x3F15

От ВПО

Ответ

Данный идентификатор имеет пакет,
отправляемый после того, как запущен
модуль с пайпами

Данный идентификатор имеет пакет, отправляемый после запуска модуля без пайпов (0x230E)

0x32E0

От ВПО

Ответ

Данный идентификатор имеет пакет,
отправляемый в случае, если имеет место
повторная попытка инициализации уже
созданных пайпов для модуля

0x34A7

От ВПО

Ответ

Данный идентификатор имеет пакет,
содержащий данные, пересылаемые
из пайпа на С2

0x9F37

От ВПО

Ответ

Данный идентификатор имеет пакет,
содержащий данные, пересылаемые
с TCP-сервера на С2

17

Сетевой код
Каждый пакет имеет следующую структуру:
Struct Packet{
Struct Header{
_ DWORD rand _ k1;
_ DWORD rand _ k2;
_ DWORD rand _ k3;
_ DWORD szPaylaod;
_ DWORD protoConst;
_ DWORD packetId;
_ DWORD unk1;
_ DWORD packetKey;
};
_ BYTE [max 0x2000] packetPayload;
};
Каждый пакет имеет уникальный ключ, определяемый как szPayload + GetTickCount() %
hardcodedConst. Данный ключ сохраняется в соответствующее поле заголовка packetKey.
Из него генерируется другой ключ, который используется для шифрования алгоритмом
RC4 заголовка пакета (без поля packetKey, оно не зашифровывается). Генерация RC4ключа для заголовка представлена на рисунке ниже.

Рисунок 22. Генерация RC4-ключа для заголовка

Далее из зашифрованных полей szPayload, packetId, protoConst, rand_k3 генерируется
еще один RC4-ключ, который используется для шифрования полезной нагрузки пакета.

18

Рисунок 23. Генерация RC4-ключа для полезной нагрузки пакета

Далее формируются HTTP-заголовки и сформированный пакет отправляется на С2. Кроме
того, каждый пакет снабжается своим номером, который фигурирует в URL. Модули могут
передавать свой идентификатор, который используется для нахождения подключения,
созданного на этапе запуска модуля. Идентификатор модуля 0 зарезервирован для основного подключения стейджера.

Рисунок 24. Формирование HTTP-заголовков

19

Другие варианты
Как мы уже упоминали, дроппер может быть сконфигурирован на запуск не только шелл­
кода, но и исполняемых файлов. Мы обнаружили один и тот же дроппер-stager с разной
полезной нагрузкой на борту: это Hussar и FlyingDutchman.

Дроппер-stager
Основными задачами данного дроппера являются распаковка и маппинг полезной нагрузки, хранящейся в закодированном виде в ресурсах. Также дроппер хранит закодированные конфигурационные данные, которые он передает как параметр полезной нагрузке.

Рисунок 25. Процесс распаковки полезной нагрузки

Hussar
Hussar по смыслу похож на те шеллкоды, что описаны выше. Он позволяет загружать модули и собирать базовую информацию о машине, а также может добавлять себя в список
авторизированных приложений брандмауэра Windows.

Инициализация
Первым делом ВПО осуществляет разбор переданной ему из загрузчика конфигурации.

Рисунок 26. Пример конфигурации

Структура конфигурации следующая:
Struct RawConfig{
_ DWORD protocolId;
_ BYTE c2Strings [0x100];
};

20

Поле protocoId показывает, по какому протоколу будет вестись взаимодействие с С2. Всего
их реализовано три:


protocolId равно 1 — будет использован протокол на основе TCP;



protocolId равно 2 — на основе HTTP;



protocolId равно 3 — на основе HTTPS.

Затем генерируется идентификатор машины. Он состоит из имени компьютера и временной метки. Временная метка может быть просчитана из реестра из ключа SOFTWARE\
Microsoft\Windows\CurrentVersion\Telephony (значение Perf0). В случае если прочитать ее
не удалось, к идентификатору машины добавляется temp.

Рисунок 27. Генерация идентификатора машины

Далее создается окно, которое впоследствии используется для обработки приходящих
сообщений.

Рисунок 28. Создание окна диспетчера

Затем ВПО добавляет себя в список авторизованных приложений брандмауэра Windows с
помощью COM-интерфейса INetFwMgr.
Инициализация заканчивается созданием потока, который осуществляет подключение к С2 и периодическую отправку запроса на команду. Функция, работающая в потоке, использует API WSAAsyncSelect для оповещения ранее созданного окна о том, что
над созданным подключением возможно выполнить действия (сокет «готово для чтения»,
«подключен», «закрыто»).
21

Рисунок 29. Связь между открытым сокетом и окном

В общем окно и механизм сообщений Windows используются ВПО как способ передачи
команд. Так как хендл окна передается модулям, а в диспетчере есть не используемые
самим стейджером ветви, можно предположить, что модули могут использовать окно для
взаимодействия С2.

Модули
Каждый модуль представляет собой MZPE-файл, который загружается в то же адресное
пространство, что и стейджер. Модуль должен экспортировать функцию GetModulInfo,
которая вызывается стейджером после маппинга образа.

Идентификатор

Направление

Тип

Описание

Собрать информацию о зараженной машине (версия ОС, имя пользователя, имя
0x835

От С2

Команда

компьютера, строка, содержащая текущее
время, имя процессора из реестра, а также — является ли ОС 64-разрядной)

0x9CA4

От С2

Команда

???

Команда

???

Команда

Загрузить модуль. Данные модуля приходят от С2

0xC358
(Window MSG

Передать данные из LPARAM на С2

Code)

0xC359
(Window MSG

Передать конфигурацию С2 модулю.

Code)

Идентификатор модуля передается
в LPARAM

0x834,
0x835, 0x838,
0x9CA4, ни
один из пере-

???

Команда

Передать принятый пакет модулю.
Идентификатор модуля передается от С2

численных

22

FlyingDutchman
Полезная нагрузка предоставляет удаленный доступ к зараженной машине. Включает в
себя функции по захвату скриншотов с экрана, удаленный шелл, операции с файловой
системой, позволяет управлять процессами и сервисами в системе. Состоит из нескольких
модулей.

Идентификатор
модуля

Идентификатор
CMD

Направление

Тип

Описание

0xafc8

0xAFD3

От С2

Команда

Ping модуля

0xAFD4

От С2

Команда

Отправляет информацию о зараженной машине (версию операционной
системы, включая установленные
сервис-­п аки, наименование процессора, строку, содержащую текущее время,
разрешение экрана, информацию
о свободном и занятом месте на дисках)

0xAFD5

От С2

Команда

Отправляет список процессов, запущенных в системе

0xAFD7

От С2

Команда

Завершить процесс. PID процесса передается от С2

0xAFD9

От С2

Команда

Отправляет список окон, существующих в системе, вместе с заголовками

0xAFDA

От С2

Команда

Отправить заданному окну сообщение
WM_CLOSE

0xAFDB

От С2

Команда

Развернуть окно

0xAFDC

От С2

Команда

Свернуть окно

0xAFDD

От С2

Команда

Показать окно

0xAFDE

От С2

Команда

Скрыть окно

23

0xAFE0

0xabe0

0xa7f8

От С2

Команда

Отправляет список сервисов, существующих в системе

0xAFE1

От С2

Команда

Осуществляет модификацию состояния
существующего сервиса. Имя сервиса
получается от С2. Может запустить сервис или перевести его в одно из состояний STOP, PAUSE, CONTINUE. Данные
о том, какое состояние необходимо
применять, также получаются с С2

0xAFE2

От С2

Команда

Удалить существующий сервис.
Имя сервиса получается с С2

0xAFE3

От С2

Команда

Изменить тип старта сервиса. Имя сервиса получается с С2

0xABEB

От С2

Команда

Ping модуля

0xABEC

От С2

Команда

Запустить процесс передачи скриншотов с экрана зараженной машины.
Скриншоты снимаются раз в секунду

0xABED

От С2

Команда

Приостановить процесс создания
скриншотов

0xABF1

От С2

Команда

Остановить процесс создания скриншотов. Модуль завершает свою работу

0xA803

От С2

Команда

Запустить cmd.exe, а также поток,
который будет считывать из связанного
пайпа данные вывода консоли и отправлять их на С2

0xA804

От С2

Команда

Записать команду в пайп, связанный
с STDIN ранее созданного cmd.exe

0xA805

От С2

Команда

Завершить работу процесса cmd.exe,
а также всех ассоциированных с ним
пайпов. Модуль завершает свою работу

24

0xa410

0xA41B

От С2

Команда

Отправляет информацию о дисках,
установленных в системе, и их типах

0xA41C

От С2

Команда

Отправляет листинг директории. Путь
до необходимой директории передается с С2

0xA41E

От С2

Команда

Загрузить файл с машины на С2

0xA41F

От С2

Команда

Запустить файл

0xA420

От С2

Команда

Удалить файл

0xA421

От С2

Команда

Загрузить файл с С2

0xA424

От С2

Команда

Переместить файл

0xA425

От С2

Команда

Создать директорию

0xA426

От С2

Команда

File Touch

0xA428

От С2

Команда

Отправляет на С2 размер переданного
файла. Путь до файла передается от С2

25

Заключение
Группа уже имеет за спиной несколько успешных взломов, однако допускает ошибки,
позволяющие судить о ее происхождении. По всем приведенным данным, группа происходит из Азии и использует ранее никем не описанное ВПО. Троян Byeby связывает эту
группу с обнаруженной нами ранее группой SongXY, пик активности которой пришелся
на 2017 год.
Мы продолжаем тщательно следить за активностью группы Calypso и прогнозируем новые
атаки с ее участием.

Индикаторы компрометации
Сетевые
23.227.207.137
45.63.96.120
45.63.114.127
r01.etheraval.com
tc.streleases.com
tv.teldcomtv.com
krgod.qqm8.com

Файловые индикаторы
Дропперы и полезная нагрузка
C9C39045FA14E94618DD631044053824

Dropper

E24A62D9826869BC4817366800A8805C

Dll

F0F5DA1A4490326AA0FC8B54C2D3912D

Shellcode

CB914FC73C67B325F948DD1BF97F5733

Dropper

6347E42F49A86AFF2DEA7C8BF455A52A

Dll

0171E3C76345FEE31B90C44570C75BAD

Shellcode

17E05041730DCD0732E5B296DB16D757

Dropper

69322703B8EF9D490A20033684C28493

Dll

22953384F3D15625D36583C524F3480A

Shellcode

1E765FED294A7AD082169819C95D2C85

Dropper

C84DF4B2CD0D3E7729210F15112DA7AC

Dll

ACAAB4AA4E1EA7CE2F5D044F198F0095

Shellcode

26

Дропперы с одинаковой полезной нагрузкой

85CE60B365EDF4BEEBBDD85CC971E84D

dropper

1ED72C14C4AAB3B66E830E16EF90B37B

dropper

CB914FC73C67B325F948DD1BF97F5733

dropper

Полезная нагрузка без дроппера
E3E61F30F8A39CD7AA25149D0F8AF5EF

Dll

974298EB7E2ADFA019CAE4D1A927AB07

Shellcode

AA1CF5791A60D56F7AE6DA9BB1E7F01E

Dll

05F472A9D926F4C8A0A372E1A7193998

Shellcode

0D532484193B8B098D7EB14319CEFCD3

Dll

E1A578A069B1910A25C95E2D9450C710

Shellcode

2807236C2D905A0675878E530ED8B1F8

Dll

847B5A145330229CE149788F5E221805

Shellcode

D1A1166BEC950C75B65FDC7361DCDC63

Dll

CCE8C8EE42FEAED68E9623185C3F7FE4

Shellcode

Hussar

43B7D48D4B2AFD7CF8D4BD0804D62E8B
617D588ECCD942F243FFA8CB13679D9C

FlyingDutchman
5199EF9D086C97732D97EDDEF56591EC
06C1D7BF234CE99BB14639C194B3B318

27

MITRE ATT&CK
Tactic

ID

Name

Execution

T1059

Command-Line Interface

Persistence

T1060

Registry Run Keys / Startup Folder

T1053

Scheduled Task

T1158

Hidden Files and Directories

T1027

Obfuscated Files or Information

T1085

Rundll32

T1064

Scripting

Credential Access

T1003

Credential Dumping

Discovery

T1087

Account Discovery

T1046

Network Service Scanning

T1135

Network Share Discovery

T1082

System Information Discovery

Lateral Movement

T1097

Pass the Ticket

Collection

T1114

Email Collection

T1113

Screen Capture

T1005

Data from Local System

T1043

Commonly Used Port

T1024

Custom Cryptographic Protocol

T1001

Data Obfuscation

Defense Evasion

Command And Control

О компании

ptsecurity.com
pt@ptsecurity.com
facebook.com/PositiveTechnologies
facebook.com/PHDays

Positive Technologies — один из лидеров европейского рынка систем анализа защищенности и соответствия стандартам,
а также защиты веб-приложений. Организации во многих странах мира используют решения Positive Technologies для
оценки уровня безопасности своих сетей и приложений, для выполнения требований регулирующих организаций
и блокирования атак в режиме реального времени. Благодаря многолетним исследованиям специалисты Positive
Technologies заслужили репутацию экспертов международного уровня в вопросах защиты SCADA- и ERP-систем,
крупнейших банков и телеком-операторов.
Деятельность компании лицензирована Минобороны России, ФСБ России и ФСТЭК России, продукция сертифицирована
Минобороны России и ФСТЭК России.

Calypso APT_A4.RUS.0003.02.OCT.23.2019

28