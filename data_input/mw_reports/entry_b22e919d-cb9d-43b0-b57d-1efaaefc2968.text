ESET Research Whitepapers // January 2018 // Author: Filip Kafka

ESET’S GUIDE TO
DEOBFUSCATING
AND
DEVIRTUALIZING
FINFISHER

2

ESET’s guide to deobfuscating and devirtualizing FinFisher

CONTENTS
Introduction

3

Anti-disassembly

4

FinFisher’s virtual machine

7

Terms and definitions

8

Vm_start

8

FinFisher’s interpreter

10

1. Creating an IDA graph

10

2. Vm_dispatcher

11

3. Vm_context

12

4. Virtual instruction implementations – vm_handlers

14

5. Writing your own disassembler

17

6. Understanding the implementation of this virtual machine

19

7. Automating the disassembly process for more FinFisher samples

20

8. Compiling disassembled code without the VM

20

Conclusion

22

Appendix A: IDA Python script for naming FinFisher vm_handlers

23

3

ESET’s guide to deobfuscating and devirtualizing FinFisher

INTRODUCTION
Thanks to its strong anti-analysis measures, the

We have also analyzed Android versions of

FinFisher spyware has gone largely unexplored.

FinFisher, whose protection mechanism is based

Despite being a prominent surveillance tool,

on an open source LLVM obfuscator. It is not as

only partial analyses have been published on its

sophisticated or interesting as the protection

more recent samples.

mechanism used in the Windows versions, thus

Things were put in motion in the summer

we will not be discussing it in this guide.

of 2017 with ESET’s analysis of FinFisher

Hopefully, experts from security researchers to

surveillance campaigns that ESET had

malware analysts will make use of this guide to

discovered in several countries. In the course of

better understand FinFisher’s tools and tactics,

our research, we have identified campaigns where

and to protect their customers against this

internet service providers most probably played

omnipotent security and privacy threat.

the key role in compromising the victims with
FinFisher.
When we started thoroughly analyzing this
malware, the main part of our effort was
overcoming FinFisher’s anti-analysis measures
in its Windows versions. The combination
of advanced obfuscation techniques and
proprietary virtualization makes FinFisher very
hard to de-cloak.
To share what we learnt in de-cloaking this
malware, we have created this guide to help
others take a peek inside FinFisher and analyze
it. Apart from offering practical insight into
analyzing FinFisher’s virtual machine, the
guide can also help readers to understand
virtual machine protection in general – that
is, proprietary virtual machines found inside a
binary and used for software protection. We
will not be discussing virtual machines used in
interpreted programming languages to provide
compatibility across various platforms, such as
the Java VM.

4

ESET’s guide to deobfuscating and devirtualizing FinFisher

A N T ID I S A S S E M B LY

This protection is very effective at fooling the
disassembler – many parts of the code aren’t
disassembled properly. And of course, it is
impossible to use the graph mode in IDA Pro.
Our first task will be to get rid of this anti-

When we open a FinFisher sample in IDA Pro,

disassembly protection.

the first protection we notice in the main

The code was clearly not obfuscated manually

function is a simple, yet very effective, anti-

but with an automated tool and we can observe

disassembly trick.

a pattern in all the jump pairs.

FinFisher uses a common anti-disassembly

There are two different types of jump pairs –

technique – hiding the execution flow by

near jump with a 32-bit offset and short jump

replacing one unconditional jump with two

with an 8-bit offset.

complementary, conditional jumps. These
conditional jumps both target the same
location, so regardless of which jump is made,
the same effective code execution flow results.
The conditional jumps are then followed by
garbage bytes. These are meant to misdirect the
disassembler, which normally will not recognize
that they are dead code, and will steam on,
disassembling garbage code.
What makes this malware special is the way
in which it uses this technique. In most other
malware we’ve analyzed, it is only used a few
times. FinFisher, however, uses this trick after
every single instruction.

The opcodes of both conditional near jumps
(with a dword as a jump offset) start with a
0x0F byte; while the second bytes are equal
to 0x8?, where ? in both jump instructions
differs only by 1 bit. This is because x86 opcodes
for complementary jumps are numerically
consecutive. For example, this obfuscation
scheme always pairs JE with JNE (0x0F 0x84 vs
0x0F 0x85 opcodes), JP with JNP (0x0F 0x8A vs
0x0F 0x8B opcodes), and so on.
These opcodes are then followed by a 32bit argument specifying the offset to the
destination of the jump. Since the size of
both instructions is 6 bytes, the offsets in two
consequent jumps differ exactly by 6. (Figure 1)

Figure 1 // Screenshot showing instructions followed by two conditional near jumps every time

5

ESET’s guide to deobfuscating and devirtualizing FinFisher

For example, the code below can be used to detect two of these consecutive conditional jumps:

def is_jump_near_pair(addr):
jcc1 = Byte(addr+1)
jcc2 = Byte(addr+7)
# do they start like near conditional jumps?
if Byte(addr) != 0x0F || Byte(addr+6) != 0x0F:
return False
# are there really 2 consequent near conditional jumps?
if (jcc1 & 0xF0 != 0x80) || (jcc2 & 0xF0 != 0x80):
return False
# are the conditional jumps complementary?
if abs(jcc1-jcc2) != 1:
return False
# do those 2 conditional jumps point to the same destination?
dst1 = Dword(addr+2)
dst2 = Dword(addr+8)
if dst1-dst2 != 6:
return False
return True

Deobfuscation of short jumps is based on the

After detecting one of these conditional jump

same idea, only the constants are different.

pairs, we deobfuscate this code by patching the

The opcode of a short conditional jump equals
0x7?, and is followed by one byte – the jump
offset. So again, when we want to detect two
consecutive, conditional near jumps, we have to

first conditional jump to unconditional (using
the 0xE9 opcode for the near jump pairs and
0xEB for the short jump pairs) and patch the
rest of the bytes with NOP instructions (0x90)

look for opcodes: 0x7?; offset; 0x7? ± 1; offset -2.
The first opcode is followed by one byte, which
differs by 2 in two consequent jumps (which is,
again, the size of both instructions). (Figure 2)
For example, this code can be used to detect
two conditional short jumps:

def is_jcc8(b):
return b&0xF0 == 0x70
def is_jump_short_pair(addr):
jcc1 = Byte(addr)
jcc2 = Byte(addr+2)
if not is_jcc8(jcc1) || not
is_jcc8(jcc2):
return False
if abs(jcc2–jcc1) != 1:
return False
dst1 = Byte(addr+1)
dst2 = Byte(addr+3)
if dst1 – dst2 != 2:
return False
return True

def patch_jcc32(addr):
PatchByte(addr, 0x90)
PatchByte(addr+1, 0xE9)
PatchWord(addr+6, 0x9090)
PatchDword(addr+8,
0x90909090)
def patch_jcc8(addr):
PatchByte(addr, 0xEB)
PatchWord(addr+2, 0x9090)

In addition to these two cases, there might be
some places where a jump pair consists of a
short and a near jump, rather than two jumps of
the same category. However, this only occurs in
a few cases in the FinFisher samples and can be
fixed manually.
With these patches made, IDA Pro starts to
“understand” the new code and is ready (or at
least almost ready) to create a graph. It may be
the case that we still need to make one more
improvement: append tails, i.e. assign the node
with the destination of the jump to the same

6

ESET’s guide to deobfuscating and devirtualizing FinFisher

Figure 2 // Examples of instructions followed by two conditional short jumps every time

graph where the node with the jump instruction
is located. For this, we can use the IDA Python
function append_‌func_‌tail.
The last step of overcoming the anti-disassembly
tricks consists of fixing function definitions. It may
still occur that the instruction after the jumps is
push ebp, in which case IDA Pro (incorrectly)
treats this as the beginning of a function and
creates a new function definition. In that case, we
have to remove the function definition, create the
correct one and append tails again.
This is how we can get rid of FinFisher’s first
layer of protection – anti-disassembly.

7

ESET’s guide to deobfuscating and devirtualizing FinFisher

FINFISHER’S
V I RT U A L
MACHINE
After a successful deobfuscation of the first

assembly level. The protection process includes

layer, we can see a clearer main function whose

translating instructions of the original binary

sole purpose is to launch a custom virtual

into virtual instructions and then creating a

machine and let it interpret the bytecode with

new binary that contains the bytecode and the

the actual payload.

virtual CPU. Native instructions from the original

As opposed to a regular executable, an
executable with a virtual machine inside uses
a set of virtualized instructions, rather than

binary are lost. The protected, virtualized
sample must have the same behavior as a nonprotected sample.

directly using the instructions of the processor.

To analyze a binary protected with a virtual

Virtualized instructions are executed by a

machine, one needs to:

virtual processor, which has its own structure

1. Analyze the virtual CPU.

and does not translate the bytecode into a

2. Write one’s own disassembler for this custom

native machine code. This virtual processor as

virtual CPU

well as the bytecode (and virtual instructions)

and parse the bytecode.

are defined by the programmer of the virtual
machine. (Figure 3)
As mentioned in the introduction, a well-known
example of a virtual machine is the Java Virtual
Machine. But in this case, the virtual machine
is inside the binary, so we are dealing with a
virtual machine used for a protection against
reverse engineering. There are well-known
commercial virtual machine protectors, for
example VMProtect or Code Virtualizer.
The FinFisher spyware was compiled from
source code and the compiled binary was
then protected with a virtual machine at the

Figure 3 // Bytecode interpreted by the virtual CPU

3. Optional step: compile the disassembled code
into a binary file to
get rid of the virtual machine.
The first two tasks are very time-consuming,
and the first one can also get quite difficult.
It includes analyzing every vm_‌h andler and
understanding how registers, memory access,
calls, etc. are translated.

8

ESET’s guide to deobfuscating and devirtualizing FinFisher

Te r ms an d d e f i n i t i o n s
There is no standard for naming particular parts
of a virtual machine. Hence, we will define some

In the following sections, we will describe the
parts of the virtual machine in more technical
detail and explain how to analyze them.

terms which will be referenced throughout the

A deobfuscated graph of the main malware

whole paper.

function consists of three parts – an

• Virtual machine (vm) – custom, virtual CPU;
contains parts like the
vm_‌d ispatcher, vm_‌s tart, vm_‌h andlers
• vm_‌s tart – the initialization part; memory

initialization part and two other parts which
we have named vm_‌s tart and interpreter
(vm_‌d ispatcher + vm_‌h andlers).
The initialization part specifies a unique

allocation and decryption routines are

identifier of what could be interpreted as a

executed here

bytecode entry point, and pushes it on the stack.

• Bytecode (also known as pcode) – virtual
opcodes of vm_‌i nstructions with their
arguments are stored here
• vm_‌d ispatcher – fetches and decodes virtual
opcode; is basically a preparation for the
execution of one of the vm_‌handlers
• vm_‌h andler – an implementation of a

Then, it jumps to the vm_‌start part that is an
initialization routine for the virtual machine
itself. It decrypts the bytecode and passes
control to the vm_‌d ispatcher that loops over
the virtual instructions of the bytecode and
interprets them using the vm_‌h andlers.
The vm_‌d ispatcher starts with a pusha

vm_‌i nstruction; executing one vm_‌h andler

instruction and ends with a jmp dword ptr

means executing one vm_‌i nstruction

[eax+ecx*4] instruction (or similar), which is a

• Interpreter (also known as vm_‌l oop) –

jump to the relevant vm_‌h andler.

vm_‌d ispatcher + vm_‌h andlers – the virtual
CPU
• Virtual opcode – an analog of the native
opcode
• vm_‌c ontext (vm_‌s tructure) – an internal
structure used by the interpreter
• vi_‌p arams – a structure in the vm_‌c ontext
structure; the virtual instruction parameters,
used by the vm_‌h andler; it includes the
vm_‌o pcode and arguments
When interpreting the bytecode, the virtual
machine uses a virtual stack and a single virtual
register.
• vm_‌s tack – an analog of a native stack, which
is used by the virtual machine
• vm_‌r egister – an analog of a native register,

Vm _‌s t a rt
The graph created after the deobfuscation of
the first layer is seen in Figure 4. The vm_‌s tart
part is not so important for the analysis of the
interpreter. However, it can help us understand
the whole implementation of the vm; how it
uses and handles virtual flags, virtual stack, etc.
The second part – the vm_‌d ispatcher with
vm_‌h andlers – is the crucial one.
The vm_‌s tart is called from almost every
function, including the main function. The calling
function always pushes a virtual instruction
identifier and then it jumps to vm_‌s tart. Every
virtual instruction has its own virtual identifier.
In this example, the identifier of the virtual

used by this virtual machine; further

entry point, where the execution from the main

referenced as tmp_‌REG

function starts, is 0x21CD0554. (Figure 5)

• vm_‌i nstruction – an instruction defined

In this part, there is a lot of code for preparing

by developers of vm; the body (the

the vm_‌d ispatcher – mainly for preparing

implementation) of the instruction is called its

the bytecode and allocating memory for the

vm_‌h andler

ESET’s guide to deobfuscating and devirtualizing FinFisher

Figure 5 // vm_start is called from each of the 119 virtualized functions.
The ID of the first virtual instruction of the respective function
is given as an argument.

whole interpreter. The most important parts of the code do the
following:
1. Allocate 1MB with RWX permission for bytecode and a few
more variables.
2. Allocate 0x10000 bytes RWX for local variables in the virtual
machine for the current thread – the vm_‌s tack.
3. Decrypt a piece of code using an XOR decryption routine. The
decrypted code is an aPLib unpacking routine.
The XOR decryption routine used in the sample is a slightly
modified version of XOR dword, key routine. Actually, it skips
the first of the six dwords and then XORs only the remaining
5 dwords with the key. Following is the algorithm for the
routine (further referred to as XOR decryption_‌code):
int array[6];
int key;
for (i = 1; i < 6; i++) {
array[i] ^= key;
}

4. Call aPLib unpacking routine to unpack bytecode. After
unpacking, virtual opcodes are still encrypted. (Figure 6)
Preparing virtual opcodes (step 1, 3 and 4) is done only once –
at the beginning – and is skipped in subsequent executions of
vm_‌s tart, when only instructions for proper handling of flags
and registers are executed.

Figure 4 // Graph of the vm_start and vm_dispatcher

9

10

ESET’s guide to deobfuscating and devirtualizing FinFisher

Figure 6 // All the code from the vm_start to the vm_dispatcher in grouped nodes named based on their purpose.

FINFISHER’S
INTERPRETER

instruction. In order to know what every
vm_‌h andler does, we first need to understand
the vm_‌c ontext and vm_‌d ispatcher.

1 . Cre a t ing a n IDA gra ph
This part includes the vm_‌d ispatcher with all

Before diving into it, creating a well-structured

the vm_‌h andlers (34 in FinFisher samples) and

graph can really help understanding the

is crucial for analyzing and/or devirtualizing the

interpreter. We recommend splitting the

virtual machine. The interpreter executes the

graph into two parts – the vm_‌s tart and the

bytecode.

vm_‌d ispatcher, i.e. to define a beginning of a

The instruction jmp dword ptr [eax+ecx*4]
jumps to one of the 34 vm_‌h andlers. Each
vm_‌h andler implements one virtual machine

function at the vm_‌dispatcher’s first instruction.
What is still missing is the actual vm_‌h andlers
referenced by the vm_‌d ispatcher. In order to
connect these handlers with the graph of the

11

ESET’s guide to deobfuscating and devirtualizing FinFisher

vm_‌d ispatcher, the following functions can be
used:

2. Vm _‌d is pa t che r
This part is responsible for fetching and

AddCodeXref(addr_‌of_‌jmp_‌instr,

decoding the bytecode. It performs the

vm_‌
handler, XREF_‌
USER|fl_‌
JN)

following steps:

adding references from the last vm_‌d ispatcher
instruction to the beginnings of the
vm_‌h andlers
AppendFchunk
appending tails again
After appending every vm_‌handler to the
dispatcher function, the resulting graph should
look like (Figure 7)

• Executes pusha and pusf instructions to
prepare virtual registers and virtual flags for
further execution of a virtual instruction.
• Retrieves the base address of the image and
address of vm_‌s tack
• Reads 24 bytes of bytecode specifying the
next vm_‌i nstruction
and its arguments

Figure 7 // Graph of the vm_dispatcher with all 34 vm_handlers.

12

ESET’s guide to deobfuscating and devirtualizing FinFisher

• Decrypts the bytecode with the previously
described XOR decryption routine

for instances when a non-virtualized function
follows).

• Adds the image base to the bytecode
argument in case the argument is a global
variable
• Retrieves the virtual opcode (number 0-33)
from the decrypted bytecode
• Jumps to the corresponding vm_‌h andler
which interprets the virtual opcode
After the vm_‌h andler for an instruction has
executed, the same sequence of steps is
repeated for the next one, starting from the
vm_‌d ispatcher’s first instruction.

3. Vm _‌c ont ext
In this part, we will describe the vm_‌c ontext
– a structure used by the virtual machine,
containing all the information necessary
for executing the vm_‌dispatcher and each
vm_‌h andler.
When looking at the code of both the
vm_‌d ispatcher and the vm_‌h andlers in greater
detail, we can notice there are a lot of data
operation instructions, referring to ebx+offset,

In the case of the vm_‌c all handler, the control

where offset is a number from 0x00 to 0x50.

is passed to the vm_‌s tart part instead (except

In Figure 8, we can see what the main part of
vm_‌h andler 0x05 in one FinFisher sample looks
like. (Figure 8)

Figure 8 // Screenshot of one of the vm_handlers

13

ESET’s guide to deobfuscating and devirtualizing FinFisher

The ebx register points to a structure we named
vm_‌c ontext. We must understand how this
structure is used – what the members are, what

there is the following instruction:
add dword ptr [ebx], 0x18.

they mean, and how they are used. When solving

This same member of the vm_‌c ontext was

this puzzle for the first time, a bit of guessing

also used earlier in the vm_‌d ispatcher’s

is needed as to how the vm_‌c ontext and its

code – just before jumping to a vm_‌h andler.

members are used.

The vm_‌d ispatcher copies 24 bytes from

For example, let’s have a look at the sequence of
instructions at the end of the vm_‌dispatcher:

movzx ecx, byte ptr [ebx+0x3C]

the structure member to a different location
([ebx+38h]) and decrypts it with the XOR
decryption routine to obtain a part of the actual
bytecode.

// opcode for vm_handler

Hence, we can start thinking of the first

jmp dword ptr [eax+ecx*4]

member of the vm_‌c ontext ([ebx+0h]) as a

// jumping to one of the 34 vm_

vm_‌i nstruction_‌p ointer, and of the decrypted

handlers

location (from [ebx+38h] to [ebx+50h]) as an
ID of a virtual instruction, its virtual opcode and

Since we know that the last instruction is a
jump to a vm_‌h andler, we can conclude that

arguments. Together, we will call the structure
vi_‌p arams.

ecx contains a virtual opcode and thus the

Following the steps described above, and using

0x3C member of a vm_‌s truct refers to a virtual

a debugger to see what values are stored in the

opcode number.

respective structure members, we can figure

Let’s make one more educated guess. At the end
of almost every vm_‌handler,

out all the members of the vm_‌c ontext.
After the analysis, we can rebuild both
FinFisher’s vm_‌c ontext and vi_‌p arams
structure:

struct vm_context {
DWORD vm_instruct_ptr; // instruction pointer to the bytecode
DWORD vm_stack; // address of the vm_stack
DWORD tmp_REG; // used as a “register” in the virtual machine
DWORD vm_dispatcher_loop; // address of the vm_dispatcher
DWORD cleanAndVMDispatchFn; // address of the function which pops values and jumps
to the vm_dispatcher skipping the first few instructions from it
DWORD cleanUpDynamicCodeFn; // address of the function which cleans vm_instr_ptr and
calls cleanAndVMDispatchFn
DWORD jmpLoc1; // address of jump location
DWORD jmpLoc2; // address of next vm_opcode – just executing next vm_instruction
DWORD Bytecode_start; // address of the start of the bytecode in data section
DWORD DispatchEBP;
DWORD ImageBase; // Image base address
DWORD ESP0_flags; // top of the native stack (there are saved flags of the vm_code)
DWORD ESP1_flags; // same as previous
DWORD LoadVOpcodesSectionFn;
vi_params bytecode; // everything necessary for executing vm_handler, see below
DWORD limitForTopOfStack; // top limit for the stack
};

14

ESET’s guide to deobfuscating and devirtualizing FinFisher

struct vi_params {
DWORD Virtual_instr_id;
DWORD OpCode; // values 0 – 33 -> tells which handler to execute
DWORD Arg0; // 4 dword arguments for vm_handler
DWORD Arg4; // sometimes unused
DWORD Arg8; // sometimes unused
DWORD ArgC; // sometimes unused
};

4. V
 i rt u al i n s t ru ct i o n
i mp l e m e n t a t i o n s –
v m _‌h an d l e r s

At the end of this function, we notice a

Each vm_‌h andler handles one virtual opcode

vi_‌params structure. Since this sequence

– since we have 34 vm_‌h andlers, there
are at most 34 virtual opcodes. Executing
one vm_‌h andler means executing one
vm_‌i nstruction, so in order to reveal what a
vm_‌i nstruction does, we need to analyze the
corresponding vm_‌handler.
After reconstructing the vm_‌c ontext and
naming all the offsets from ebx, the previously

sequence of instructions, starting with the
vm_‌instruction_‌pointer, being incremented
by 24 – the size of each vm_‌instruction’s
is repeated at the end of almost every
vm_‌handler, we conclude it is a standard
function epilogue and the actual body of the
vm_‌handler can be written as simply as:
mov

[tmp_‌REG], Arg0

So, there we go – we have just analyzed the
first instruction of the virtual machine. :-)

shown vm_‌h andler changes to a much more
readable form, as seen in Figure 9.

Figure 9 // The previous
vm_handler after
inserting the
vm_context structure

15

ESET’s guide to deobfuscating and devirtualizing FinFisher

To illustrate how the analyzed instruction works

At this point, we should understand what

when executed, let’s consider the vi_‌params

one of the vm_‌i nstructions does. The

structure filled as follows:

steps we followed should serve as a decent
demonstration of how the entire interpreter

struct vi_params {
DWORD ID_of_virt_instr = doesn’t
matter;
DWORD OpCode = 0x0C;
DWORD Arg0 = 0x42;
DWORD Arg4 = 0;
DWORD Arg8 = 0;
DWORD ArgC = 0;
};

works.
However, there are some vm_‌h andlers that are
harder to analyze. This vm’s conditional jumps
are tricky to understand because of the way
they translate flags.
As mentioned before, the vm_‌dispatcher starts
with pushing native EFLAGS (of vm_‌c ode) to
the top of the native stack. Therefore, when the
handler for a respective jump is deciding whether

From what was stated above, we can see that
the following instruction will be executed:
mov

[tmp_‌REG], 0x42

to jump or not, it looks at EFLAGS at the native
stack and implements its own jump method.
Figure 10 illustrates how the virtual JNP handler is
implemented by checking the parity flag.
(Figure 10)

Figure 10 // Screenshot of a JNP_handler

16

ESET’s guide to deobfuscating and devirtualizing FinFisher

For other virtual conditional jumps, it may be necessary to check several flags – for example, the jump
result of the virtualized JBE depends on the values of both CF and ZF – but the principle stays the
same.
After analyzing all 34 vm_‌h andlers in FinFisher’s virtual machine, we can describe its virtual
instructions as follows:

Figure 11 // vm_table with all 34 vm_handlers accessed

Please note that the keyword “tmp_‌R EG”

These two vm_‌handlers are implemented to

refers to a virtual register used by the virtual

execute native code directly – all they do is to

machine –temporary register in the vm_‌c ontext

read the opcode of a native instruction given as

structure, while “reg” refers to a native register,

an argument and execute the instruction.

e.g. eax.

One more thing to note is that the vm_‌registers

Let’s have a look at the analyzed instructions

are always at the top of the native stack, while

of the virtual machine. For example,

the identifier of the register to be used is stored

case_‌3 _‌v m_ ‌j cc is a general jump handler that

in the last byte of arg0 of the virtual instruction.

can execute any native jump, either conditional

The following code can be used to access the

or unconditional.

respective virtual register:

Apparently, this virtual machine does not
virtualize every native instruction – that’s where
instructions in cases 4 and 6 come in handy.

17

ESET’s guide to deobfuscating and devirtualizing FinFisher

def resolve_reg(reg_pos):
stack_regs = [‘eax’, ‘ecx’, ‘edx’, ‘ebx’, ‘esp’, ‘ebp’, ‘esi’, ‘edi’]
stack_regs.reverse()
return stack_regs[reg_pos]
reg_pos = 7 – (state[arg0] & 0x000000FF)
reg = resolve_reg(reg_pos)

5. Wr it i n g y o u r o wn
di sa ss e m b l e r

jump. This “jump offset” is actually an offset in

After we have correctly analyzed all the

For example, this code can be used:

vm_‌i nstructions, there is still one step to
be done before we can start the analysis
of the sample – we need to write our own
disassembler for the bytecode (parsing it
manually would be problematic due to its size).
By putting in the effort and writing a more
robust disassembler we can save ourselves
some trouble when FinFisher’s virtual machine
is changed and updated.
Let’s start with the vm_‌h andler 0x0C, which
executes the following instruction:
mov [tmp_‌
REG], reg
This instruction takes exactly one argument
– the identifier of a native register to be used
as reg. This identifier must be mapped into
a native register name, for instance using a
resolve_‌reg function as described above.
The following code can be used to dissasemble
this vm_‌h andler:
def vm_0C(state, vi_params):
global instr
reg_pos = 7 – (vi_arams[arg0]
& 0x000000FF)
tmpinstr = “mov [tmp_REG],
%s” % resolve_reg(reg_pos)
instr.append(tmpinstr)
return

Again, vm_‌h andlers for jumps are harder
to understand. In case of jumps, members
vm_‌c ontext.vi_‌p arams.Arg0 and vm_‌c ontext.
vi_‌p arams.Arg1 store the offset by which to

the bytecode. When parsing jumps, we need to
put a marker to the location to which it jumps.

def computeLoc1(pos, vi_params):
global instr
jmp_offset = (vi_params[arg0]
& 0x00FFFFFF) + (vi_params[arg1]
& 0xFF000000)
if jmp_offset < 0x7FFFFFFF:
jmp_offset /= 0x18 # their
increment by 0x18 is my
increment by 1
else:
jmp_offset = int((0x100000000 + jmp_offset)
/ 0x18)
return pos+jmp_offset

Finally, there is a vm_‌handler responsible for
executing native instructions from arguments,
which needs special treatment. For this, we
have to use a disassembler for native x86
instructions – for example, the open source tool
Distorm.
The length of an instruction is stored in
vm_‌context.vi_‌params.OpCode & 0x0000FF00.
The opcode of the native instruction that
will be executed is stored in the arguments.
The following code can be used to parse the
vm_‌handler that executes native code:

18

ESET’s guide to deobfuscating and devirtualizing FinFisher

def vm_04(vi_params, pos):
global instr
nBytes = vi_params[opCode] & 0x0000FF00
dyn_instr = pack(“<LLLL”, vi_params[arg0], vi_params[arg4],
vi_params[arg8], vi_params[argC])[0:nBytes]
dec_instr = distorm3.Decode(0x0, dyn_instr, distorm3.Decode32Bits)
tmpinstr = “%s” % (dec_instr[0][2])
instr.append(tmpinstr)
return

Up to this point, we have created Python
functions to disassemble each vm_‌handler. All
of these, combined with the code responsible
for marking jump locations, finding the ID of
a virtual instruction after the call and a few
others, are necessary for writing your own
disassembler.
Afterwards, we can run the finished
disassembler on the bytecode.

Figure 12 // Part of the unpacked and decrypted FinFisher bytecode

For example, from the part of the bytecode
shown in Figure 12, we may get the following
output:

mov tmp_REG, 0
add tmp_REG, EBP
add tmp_REG, 0x10
mov tmp_REG, [tmp_REG]
push tmp_REG
mov tmp_REG, EAX
push tmp_REG

19

ESET’s guide to deobfuscating and devirtualizing FinFisher

6 . U n d e rs t an d i n g t h e
i mp l e m e n t a t i o n o f
th is v i r t u al m a ch i ne

into NOR logic, with a number of temporary

After we have analyzed all the virtual handlers

go as far as to cover all the native instructions.

and constructed a custom disassembler, we can
have one more look at the virtual instructions to

registers being used instead of one.
Conversely, FinFisher’s virtual machine did not
While many of them can be virtualized, some
can’t – math instructions, such as add, imul and

get an overall idea of how they were created.

div, being some examples. If these instructions

First, we must understand that the virtualization

responsible for executing native instructions is

protection was implemented at the assembly
level. The authors translated native instructions
into their own, somewhat complicated
instructions, which are to be executed by a
custom virtual CPU. To achieve this, a temporary
“register” (tmp_‌R EG) is used.
We can look at some examples to see how
this translation works. For example, the virtual
instruction from the previous example –
mov tmp_‌
REG, EAX
push tmp_‌REG

appear in the original binary, the vm_‌h andler
called to handle them in the protected binary.
The only change is that EFLAGS and native
registers are popped from the native stack just
before the native instruction is executed, and
pushed back after it is executed. This is how the
virtualization of every native instruction was
avoided.
A significant drawback of protecting binaries
with a virtual machine is the performance
impact. In the caseof FinFisher’s virtual
machine, we estimate it to be more than one
hundred times slower than native code, based

– was translated from the original native

on the number of instructions that have to be

instruction push eax. When virtualized, a

executed to handle every single vm_‌i nstruction

temporary register was used in an intermediate

(vm_‌d ispatcher + vm_‌h andler).

step to change the instruction into something
more complicated.
Let’s consider another example:
mov tmp_REG, 0
add tmp_REG, EBP
add tmp_REG, 0x10
mov tmp_REG, [tmp_REG]
push tmp_REG

Therefore, it makes sense to protect only
selected parts of the binary– and this is also the
case in the FinFisher samples we analyzed.
Moreover, as mentioned before, some of
the virtual machine handlers can call native
functions directly. As a result, the users of the
virtual machine protection (i.e. the authors
of FinFisher) can look at the functions at the
assembly level and mark which of them are

The native instructions that were translated into

to be protected by the virtual machine. For

these virtualized instructions were the following

those that are marked, their instructions will be

(with reg being one of the native registers):

virtualized, for those that are not, the original

mov reg, [ebp+0x10]
push reg
This is, however, not the only way to virtualize
a set of instructions. There are other virtual
machine protectors with other approaches. For
instance, one of the commercial vm protectors
translates each math operation instruction

functions will be called by the respective virtual
handler. Thus, the execution might be less timeconsuming while the most interesting parts of
the binary stay protected. (Figure 13)

20

ESET’s guide to deobfuscating and devirtualizing FinFisher

Figure 13 // Scheme representing FinFisher’s entire vm protection and how the execution can jump out of the vm

7 . A u t o m a t i n g t h e
di sa s s e m b l y p ro ce ss
f o r m o re F i n F i s h e r
sa m p l e s

be used to recreate the signatures in case the

In addition to the length of the bytecode our

in the FinFisher sample you analyze may be

parser has to process, we have to keep in mind
that there is some randomization across various
FinFisher samples. Although the same virtual
machine has been used for the protection, the
mapping between the virtual opcodes and the
vm_‌h andlers is not always constant. They can
be (and are) paired randomly and differently
for each of the FinFisher samples we analyzed.
It means that if the vm_‌h andler for the 0x5
virtual opcode in this sample handles the mov
[tmp_‌REG], arg0 instruction, it may be
assigned a different virtual opcode in another
protected sample.
To address this issue, we can use a signature
for each of the analyzed vm_‌h andlers. The
IDA Python script in Appendix A can be applied
after we have generated a graph as shown in
Figure 7 (it is particularly important to have

vm_‌h andlers are changed in a future FinFisher
update.)
As mentioned above, the first vm_‌h andler
different than JL, as in the example FinFisher
sample, but the script will identify all of the
vm_‌h andlers correctly.

8 . C om piling
d is a s s e m b led cod e
wit hou t t he VM
After disassembly and after a few
modifications, it is possible to compile the
code. We will treat virtual instructions as native
instructions. As a result, we will get a pure
binary without the protection.
Most of the vm_‌instructions can be compiled
immediately using copy-paste, since the output
of our disassembler mostly consists of nativelooking instructions. But some cases need
special treatment:

the jz/jnz jump obfuscation eliminated – as

• tmp_‌REG – since we defined tmp_‌REG as

described in the first section of this guide) to

a global variable, we need to make code

name the handlers based on their signatures.

adjustments for cases when an address

(With a small modification, the script can also

stored in it is being dereferenced. (Since

21

ESET’s guide to deobfuscating and devirtualizing FinFisher

dereferencing an address which is in a global

• API function calls – in most cases, API

variable is not possible in the x86 instruction

functions are loaded dynamically, whereas

set.) For example, the vm contains the virtual

in others they are referenced from the IAT of

instruction mov tmp_‌REG, [tmp_‌REG] which

the binary, so these cases need to be handled

needs to be rewritten as follows:

accordingly.
• Global variables, native code – Some global

push eax
mov eax, tmp_REG
mov eax, [eax]
mov tmp_REG, eax
pop eax

variables need to be kept in the devirtualized
binary. Also in the FinFisher dropper, there is a
function for switching to x64 from x86 that is
executed natively (actually it is done only with
the retf instruction). All these must be kept

• Flags – Virtual instructions do not change
the flags, but native math instructions do.
Therefore, we need to make sure that virtual
math instruction won’t change flags in the
devirtualized binary either, which means
we have to save flags before executing
this instruction and restore them after the
execution.
• Jumps and calls – we have to put a marker to
the destination virtual instruction (jumps) or
function (calls).

in the code when compiling.
Depending on the output of your disassembler,
you may still need to do a few more
modifications to get pure native instructions
that can be compiled. Then, you can compile the
code with your favorite assembly-compiler into
a binary without the VM.

22

ESET’s guide to deobfuscating and devirtualizing FinFisher

CONCLUSION
In this guide, we have described how FinFisher
uses two elaborate techniques to protect
its main payload. The primary intention of
this protection is not to avoid AV detection,
but to cover the configuration files and new
techniques implemented in the spyware by
hindering analysis by reverse engineers. As
no other detailed analysis of the obfuscated
FinFisher spyware has been published to date,
it seems the developers of these protection
mechanisms have been successful.
We have shown how we can overcome the
anti-disassembly layer automatically, and how
the virtual machine can be efficiently analyzed.
We hope this guide can help reverse engineers
analyze vm-protected FinFisher samples, as
well to better understand other virtual machine
protectors in general.

23

ESET’s guide to deobfuscating and devirtualizing FinFisher

Appen d i x A
ID A Py t h o n s cr i p t f o r na m ing
F i n F i s h e r v m _‌h a n d l e rs
The script is also available on ESET’s GitHub repository:
https://github.com/eset/malware-research/blob/master/finfisher/ida_finfisher_vm.py

i​m​p​o​r​t​ ​s​y​s​
S​
IG
​​
S​ ​
=​ ​
{​ ​
‘​
8d
​​
4​
b4
​​
0​
8b
​​
4​
32
​​
c​
8b
​​
0​
a9
​​
0​
8​
0​
0​
f​
9​
5​
c​
2​
a​
9​
8​
0​
0​
0​
0​
f​
9​
5​
c​
0​
3​
a​
c​
2​
7​
5​
f​
f​
6​
3​
1​
c​
’​ ​
:​ ​
‘​
c​
a​
s​
e​
_​
0​
_​
J​
L​
_​
l​
oc
​​
1​
’​
,​ ​
‘​
8d
​​
4​
b4
​​
0​
8b
​​
4​
32
​​
c8
​b
​​
0a
​​
94
​​
0​
0​
0​
7​
4​
f​
f​
6​
3​
1​
c​
’​ ​
:​ ​
‘​
c​
a​
s​
e​
_​
1​
_​
J​
N​
P​
_​
l​
o​
c​
1​
’​
,​ ​
‘​
8​
d​
4​
b​
4​
0​
8​
b​
4​
3​
2​
c​
8​
b​
0​
a9
​​
4​
0​
0​
0​
07
​​
5​
a9
​​
0​
80
​​
0​
f9
​​
5​
c2
​​
a​
9​
80
​​
0​
0​
0​
f​
9​
5​
c​
0​
3​
a​
c​
2​
7​
5​
f​
f​
6​
3​
1​
c​
’​ ​
:​ ​
‘​
c​
a​
s​
e​
_​
2​
_​
J​
L​
E​
_​
l​
o​
c​
1​
’​
,​ ​
‘​
8​
d​
4​
b​4​0​8​b​7​b​5​0​8​b​4​3​2​c​8​3​e​0​2​f​8​d​b​c​3​8​3​1​1​8​1​2​b​5​c​7​8​7​c​f​e​7​e​d​4​a​e​9​2​f​8​b​0​6​6​c​7​8​7​d​3​e​7​e​
4​a​f​9​b​8​e​8​0​0​0​0​5​8​8​d​8​0​’​ ​:​ ​‘​c​a​s​e​_​3​_​v​m​_​j​c​c​’​,​ ​‘​8​b​7​b​5​0​8​b​4​3​2​c​8​3​e0
​ ​2​f​3​f​8​5​7​6​6​c​7​7​a​c​6​6​6​8​
1​3​7​3​1​6​7​8​3​c​7​2​8​d​7​3​4​0​f​b​6​4​b​3​d​f​3​a​4​c​6​7​e​9​8​0​3​7​8​1​8​b​4​3​c​8​9​4​7​1​c​6​4​7​5​6​c​8​0​7​7​5​a​f​8​3​3​1​8​5​8​8​b​6​
3​2​c​’​ ​:​ ​‘​c​a​s​e​_​4​_​e​x​e​c​_​n​a​ti
​ ​v​e​_​c​o​d​e​’​,​ ​‘​8​d​4​b​4​0​8​b​9​8​b​4​3​8​8​9​8​8​3​3​1​8​8​b​4​3​c​8​b​6​3​2​c​’​ ​:​ ​‘​c​
a​s​e​_​5​_​m​o​v​_​t​m​p​_​R​E​G​r​e​f​_​a​r​g​0​’​,​ ​‘​8​b​7​b​5​0​8​b​4​3​2​c​8​3​e​0​2​f​3​f​8​5​7​6​6​c​7​7​a​c​6​6​6​8​1​3​7​3​1​6​7​8​3​c​7​
2​8​d​7​3​4​0​f​b​6​4​b​3​d​f​3​a​4​c​6​7​e​9​8​0​3​7​8​1​8​b​4​3​c​8​9​4​7​1​c​6​4​7​5​6​c​8​0​7​7​5​a​f​8​3​3​1​8​5​8​8​b​6​3​2​c​’​ ​:​ ​‘​c​a​s​
e​
_6
​​
_e
​​
x​
e​
c_
​​
n​
a​
t​
iv
​​
e​
_c
​​
o​
de
​​
’​
,​ ​
‘​
8​
d​
4b
​​
4​
0​
8​
b​
4​
3​
2​
c​
8​
b​
0​
a​
9​
4​
0​
0​
0​
0​
7​
5​
f​
f​
6​
3​
1​
c​
’​ ​
:​ ​
‘​
c​
a​
s​
e​
_​
7​
_​
J​
Z​
_​
l​
o​
c​
1​
’​
,​ ​‘​8​d​4​b​4​0​8​b​4​3​2​c​8​b​0​a​9​4​0​0​0​0​7​5​a​9​0​8​0​0​f​9​5​c​2​a​9​8​0​0​0​0​f​9​5​c​0​3​a​c​2​7​5​f​f​6​3​1​8​’​ ​:​ ​‘​c​a​s​e​_​8​_​
J​
G​
_​
lo
​​
c​
1​
’​
,​ ​
‘​
8​
d4
​3
​​
40
​​
8​
b0
​​
8​
94
​​
3​
88
​​
3​
3​
1​
8​
8​
b​
4​
3​
c​
8​
b​
6​
3​
2​
c​
’​ ​
:​ ​
‘​
c​
a​
s​
e​
_​
9​
_​
m​
o​
v​
_​
t​
m​
p​
_​
R​
E​
G​
_​
a​
r​
g​
0​
’​
,​ ​
‘​
3​
3​c​9​8​9​4​b​8​8​3​3​1​8​8​b​6​3​2​c​8​b​4​3​c​’​ ​:​ ​‘​c​a​s​e​_​A​_​z​e​r​o​_​t​m​p​_​R​E​G​’​,​ ​‘​8​d​4​b​4​0​8​b​4​3​2​c​8​b​0​a​9​8​0​0​0​0​
7​
5​
ff
​​
6​
3​
1​
c’
​​ ​
:​ ​
‘​
c​
as
​​
e​
_B
​​
_J
​S
​​
_l
​​
oc
​​
1​
’​
,​ ​
‘​
8​
d​
4​
b​
4​
0​
f​
b​
6​
9​
b​
8​
7​
0​
0​
0​
2​
b​
c​
1​
8​
b​
4​
b​
2​
c​
8​
b​
5​
4​
8​
1​
4​
8​
b​
4​
b​
8​
8​
9​
1​
1​
8​
3​3​1​8​8​b​4​3​c​8​b​6​3​2​c​’​ ​:​ ​‘​c​a​s​e​_​C​_​m​o​v​_​t​m​p​_​R​E​G​D​e​r​e​f​_​t​m​p​_​R​E​G​’​,​ ​‘​8​d​4​b​4​0​f​b​6​9​b​8​7​0​0​0​2​b​c​
1​8​b​4​b​2​c​8​b​4​4​8​1​4​8​9​4​3​8​8​3​3​1​8​8​b​4​3​c​8​b​6​3​2​c​’​ ​:​ ​‘​c​a​s​e​_​D​_​m​o​v​_​t​m​p​_R
​ ​E​G​_​t​m​p​_​R​E​G​’​,​ ​‘​8​d​4​b​
4​
0​
8b
​​
4​
3​
2​
c8
​​
b​
0a
​​
9​
10
​​
0​
07
​​
5​
ff
​​
63
​1
​​
c​
’​ ​
:​ ​
‘​
c​
a​
s​
e​
_​
E​
_​
J​
B​
_​
l​
o​
c​
1​
’​
,​ ​
‘​
8​
d​
4​
b​
4​
0​
8​
b​
4​
3​
2​
c​
8​
b​
0​
a​
9​
1​
0​
0​
0​
7​
5​
a​
9​
4​
0​
0​
0​
07
​​
5​
f​
f​
63
​​
1​
c’
​​ ​
:​ ​
‘​
ca
​​
s​
e_
​​
F​
_J
​​
B​
E​
_​
l​
o​
c​
1​
’​
,​ ​
‘​
8​
d​
4​
b​
4​
0​
8​
b​
4​
3​
2​
c​
8​
b​
0​
a​
9​
4​
0​
0​
0​
0​
7​
4​
f​
f​
6​
3​
1​
c​
’​ ​
:​ ​
‘​
c​
a​
s​
e​
_1
​​
0_
​​
J​
N​
Z​
_l
​​
o​
c1
​​
’​
,​ ​
‘​
8​
d​
4b
​​
4​
08
​​
b​
4​
32
​​
c​
8​
b​
0​
a​
9​
0​
8​
0​
0​
7​
4​
f​
f​
6​
3​
1​
c​
’​ ​
:​ ​
‘​
c​
a​
s​
e​
_​
1​
1​
_​
J​
N​
O​
_​
l​
o​
c​
1​
’​
,​ ​
‘​
8​
b​
7​
b​5​0​8​3​4​3​5​0​3​0​8​d​4​b​4​0​8​b​4​1​4​3​4​3​2​8​5​7​6​6​c​7​7​3​f​5​0​6​6​8​1​3​7​a​2​3​1​c​6​4​7​2​c​2​8​0​7​7​2​a​a​8​d​5​7​d​8​3​c​7​3​8​9​
1​7​8​3​e​f​3​c​7​4​7​7​a​3​0​0​0​8​0​7​7​7​c​b​8​3​c​7​8​8​9​7​8​3​e​f​8​c​6​4​7​c​f​2​8​0​7​7​c​3​1​8​3​c​7​d​c​6​7​6​8​8​b​3​8​3​c​0​1​8​8​9​4​7​
1​8​3​c​7​5​6​6​c​7​7​7​7​f​e​6​6​8​1​3​7​1​7​6​2​8​3​c​7​2​c​6​7​2​d​8​0​3​7​4​5​8​9​5​f​1​8​3​c​7​5​c​6​7​8​4​8​0​3​7​d​f​4​7​8​b​4​3​1​4​c​6​7​4​
0​8​0​3​7​2​8​8​9​4​7​1​8​3​c​7​5​c​6​7​9​2​8​0​3​7​5​1​5​f​8​b​6​3​2​c​’​ ​:​ ​‘​c​a​s​e​_​1​2​_​v​m​_​c​a​l​l​’​,​ ​‘​8​d​4​b​4​0​b​8​7​0​0​0​2​b​
1​8​b​5​3​2​c​8​b​4​4​8​2​4​8​9​4​3​8​8​3​3​1​8​8​b​4​3​c​8​b​6​3​2​c​’​ ​:​ ​‘​c​a​s​e​_​1​3​_​m​o​v​_​t​m​p_
​ ​R​E​G​_​t​m​p​_​R​E​G​_​n​o​t​R​l​y​
’​
,​ ​
‘​
8d
​​
4​
b​
4​
08
​​
b​
43
​​
2​
c8
​​
b​
0a
​​
9​
40
​​
0​
07
​​
5​
f​
f​
6​
3​
1​
c​
’​ ​
:​ ​
‘​
c​
a​
s​
e​
_​
1​
4​
_​
J​
P​
_​
l​
o​
c​
1​
’​
,​ ​
‘​
8​
d​
4​
b​
4​
0​
f​
b​
6​
9​
b​
8​
7​
0​
0​
0​
2​
b​c​1​8​b​4​b​2​c​8​b​5​3​8​8​9​5​4​8​1​4​8​3​3​1​8​8​b​4​3​c​8​b​6​3​2​c​’​ ​:​ ​‘​c​a​s​e​_​1​5​_​m​o​v​_​t​m​p​_​R​E​G​_​t​m​p​_​R​E​G​’​,​ ​‘​8​
d​
4​
b4
​​
0​
8​
b​
43
​​
2​
c8
​​
b​
0a
​​
9​
08
​​
0​
07
​​
5f
​f
​​
6​
3​
1​
c​
’​ ​
:​ ​
‘​
c​
a​
s​
e​
_​
1​
6​
_​
J​
O​
_​
l​
o​
c​
1​
’​
,​ ​
‘​
8​
d​
4​
b​
4​
0​
8​
b​
4​
3​
2​
c​
8​
b​
0​
a​
9​
0​
8​
0​
0​
f​
9​
5​
c​
2a
​​
9​
8​
0​
00
​​
0​
f9
​​
5c
​0
​​
3a
​​
c​
27
​​
4​
ff
​​
6​
31
​​
c​
’​ ​
:​ ​
‘​
c​
a​
s​
e​
_​
1​
7​
_​
J​
G​
E​
_​
l​
o​
c​
1​
’​
,​ ​
‘​
8​
b​
4​
3​
8​
8​
b​
0​
8​
9​
4​
3​
8​
8​
3​
3​
1​
8​
8​
b​
4​
3​c​8​b​6​3​2​c​’​ ​:​ ​‘​c​a​s​e​_​1​8​_​d​e​r​e​f​_​t​m​p​_​R​E​G​’​,​ ​‘​8​d​4​b​4​0​8​b​4​3​8​8​b​9​d​3​e​0​8​9​4​3​8​8​3​3​1​8​8​b​4​3​c​8​b​6​
3​2​c​’​ ​:​ ​‘​c​a​s​e​_​1​9​_​s​h​l​_​t​m​p_
​ ​R​E​G​_​a​r​g​0​l​’​,​ ​‘​8​d​4​b​4​0​8​b​4​3​2​c​8​b​0​a​9​8​0​0​0​0​7​4​f​f​6​3​1​c​’​ ​:​ ​‘​c​a​
s​
e​
_1
​​
A​
_​
J​
NS
​​
_​
lo
​​
c​
1’
​​
,​ ​
‘​
8d
​​
4b
​4
​​
08
​​
b4
​​
3​
2​
c​
8​
b​
0​
a​
9​
1​
0​
0​
0​
7​
4​
f​
f​
6​
3​
1​
c​
’​ ​
:​ ​
‘​
c​
a​
s​
e​
_​
1​
B​
_​
J​
N​
B​
_​
l​
o​
c​
1​
’​
,​ ​
‘​
8​
b​
7​b​2​c​8​b​7​3​2​c​8​3​e​f​4​b​9​2​4​0​0​0​f​c​f​3​a​4​8​3​6​b​2​c​4​8​b​4​b​2​c​8​b​4​3​8​8​9​4​1​2​4​8​3​3​1​8​8​b​4​3​c​8​b​6​3​2​c​’​ ​:​ ​‘​c​
a​s​e​_​1​C​_​p​u​s​h​_​t​m​p​_​R​E​G​’​,​ ​‘​8​d​4​b​4​0​8​b​4​3​2​c​8​b​0​a​9​4​0​0​0​0​7​5​a​9​1​0​0​0​7​5​f​f​6​3​1​8​’​ ​:​ ​‘​c​a​s​e​_​1​D​_​
J​
A_
​​
lo
​​
c​
1​
’​
,​ ​
‘​
8​
d​
4b
​​
4​
0b
​​
8​
70
​​
0​
02
​​
b​
1​
8b
​​
5​
3​
2​
c​
8​
b​
4​
4​
8​
2​
4​
1​
4​
3​
8​
8​
3​
3​
1​
8​
8​
b​
4​
3​
c​
8​
b​
6​
3​
2​
c​
’​ ​
:​ ​
‘​
c​
a​
s​
e​
_​
1​
E​
_​
a​
d​
d​_​s​t​a​c​k​_​v​a​l​_​t​o​_​t​m​p​_​R​E​G​’​,​ ​‘​8​b​7​b​5​0​8​3​4​3​5​0​3​0​6​6​c​7​7​a​c​3​7​6​6​8​1​3​7​3​1​5​6​5​7​8​3​c​7​2​8​d​4​b​4​0​c​6​
7​2​e​8​0​3​7​4​6​f​b​6​4​3​3​d​3​c​7​8​3​c​0​5​8​9​4​7​1​8​3​c​7​5​8​d​7​1​4​f​b​6​4​b​3​d​f​3​a​4​5​a​c​6​7​1​2​8​0​3​7​7​a​8​b​3​8​3​c​0​1​8​8​9​
4​7​1​8​3​c​7​5​6​6​c​7​7​7​f​3​0​6​6​8​1​3​7​1​f​a​c​8​3​c​7​2​c​6​7​1​f​8​0​3​7​7​7​8​9​5​f​1​8​3​c​7​5​c​6​7​7​0​8​0​3​7​2​b​4​7​c​6​7​9​8​0​3​7​
6​1​8​b​4​b​1​4​8​9​4​f​1​8​3​c​7​5​c​6​7​7​7​8​0​3​7​b​4​8​b​6​3​2​c​8​d​1​2​’​ ​:​ ​‘​c​a​s​e​_​1​F​_​v​m​_​j​m​p​’​,​ ​‘​8​d​4​b​4​0​8​b​9​1​4​b​
8​8​3​3​1​8​8​b​4​3​c​8​b​6​3​2​c​’​ ​:​ ​‘​c​a​s​e​_​2​0​_​a​d​d​_​a​r​g​0​_​t​o​_​t​m​p​_​R​E​G​’​,​ ​‘​8​d​4​b​4​0​8​b​9​8​b​4​3​8​8​9​1​8​3​3​1​
8​8​b​6​3​2​c​8​b​4​3​c​’​ ​:​ ​‘​c​a​s​e​_​2​1​_​m​o​v​_​t​m​p​_​R​E​G​_​t​o​_​a​r​g​0​D​e​r​e​f​e​r​e​n​c​e​d​’​ ​}​
S​W​I​T​C​H​ ​=​ ​0​ ​#​ ​a​d​d​r​ ​o​f​ ​j​m​p​ ​ ​ ​ ​ ​d​w​o​r​d​ ​p​t​r​ ​[​e​a​x​+​e​c​x​*​4​]​ ​(​j​u​m​p​ ​t​o​ ​v​m​_​h​a​n​d​l​e​r​s​)​
S​
WI
​​
TC
​​
H​
_​
S​
IZ
​​
E​ ​
=​ ​
3​
4​ ​ ​ ​ ​
s​i​g​ ​=​ ​[​]​
d​e​f​ ​a​p​p​e​n​d​_​b​y​t​e​s​(​i​n​s​t​r​,​ ​a​d​d​r​)​:​
​ ​ ​ ​f​o​r​ ​j​ ​i​n​ ​r​a​n​g​e​(​i​n​s​t​r​.​s​i​z​e​)​:​
​ ​ ​ ​ ​ ​ ​ ​s​i​g​.​a​p​p​e​n​d​(​B​y​t​e​(​a​d​d​r​)​)​

24

ESET’s guide to deobfuscating and devirtualizing FinFisher

​ ​ ​ ​ ​ ​ ​ ​a​d​d​r​ ​+​=​ ​1​
​ ​ ​ ​r​e​t​u​r​n​ ​a​d​d​r​
d​
e​
f​ ​
m​
a​
k​
eS
​​
i​
gN
​​
am
​e
​​
(s
​​
i​
g_
​​
n​
am
​​
e​
,​ ​
v​
m​
_​
h​
a​
n​
d​
l​
e​
r​
)​
:​
​ ​ ​ ​p​r​i​n​t​ ​“​n​a​m​i​n​g​ ​%​x​ ​a​s​ ​%​s​”​ ​%​ ​(​v​m​_​h​a​n​d​l​e​r​,​ ​s​i​g​_​n​a​m​e​)​
 ​ ​ ​ ​
M​
a​
k​
e​
Na
​​
m​
e(
​​
v​
m_
​​
ha
​n
​​
dl
​​
e​
r,
​​ ​
s​
i​
g​
_​
n​
a​
m​
e​
)​
​ ​ ​ ​r​e​t​u​r​n​
i​f​ ​S​W​I​T​C​H​ ​=​=​ ​0​:​
​ ​ ​ ​p​r​i​n​t​ ​“​F​i​r​s​t​ ​s​p​e​c​i​f​y​ ​a​d​d​r​e​s​s​ ​o​f​ ​s​w​i​t​c​h​ ​j​u​m​p​ ​-​ ​j​u​m​p​ ​t​o​ ​v​m​_​h​a​n​d​l​e​r​s​!​”​
​ ​ ​ ​s​y​s​.​e​x​i​t​(​1​)​
​​​​
f​
or
​​ ​
i​ ​
i​
n​ ​
r​
a​
ng
​​
e(
​S
​​
WI
​​
T​
CH
​​
_​
SI
​​
Z​
E)
​​
:​
​ ​ ​ ​a​d​d​r​ ​=​ ​D​w​o​r​d​(​S​W​I​T​C​H​+​i​*​4​)​
​ ​ ​ ​f​a​d​d​r​ ​=​ ​a​d​d​r​
​​​​
​ ​ ​ ​s​i​g​ ​=​ ​[​]​
​​​​
​ ​ ​ ​w​h​i​l​e​ ​1​:​
​​​​​​​​
​ ​ ​ ​ ​ ​ ​ ​i​n​s​t​r​ ​=​ ​D​e​c​o​d​e​I​n​s​t​r​u​c​t​i​o​n​(​a​d​d​r​)​
​ ​ ​ ​ ​ ​ ​ ​i​f​ ​i​n​s​t​r​.​g​e​t​_​c​a​n​o​n​_​m​n​e​m​(​)​ ​=​=​ ​“​j​m​p​”​ ​a​n​d​ ​(​B​y​t​e​(​a​d​d​r​)​ ​=​=​ ​0​x​e​b​ ​o​r​ ​B​y​t​e​
(​a​d​d​r​)​ ​=​=​ ​0​x​e​9​)​:​
​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​a​d​d​r​ ​=​ ​i​n​s​t​r​.​O​p​1​.​a​d​d​r​
​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​c​o​n​t​i​n​u​e​
​ ​ ​ ​ ​ ​ ​ ​i​f​ ​i​n​s​t​r​.​g​e​t​_​c​a​n​o​n​_​m​n​e​m​(​)​ ​=​=​ ​“​j​m​p​”​ ​a​n​d​ ​B​y​t​e​(​a​d​d​r​)​ ​=​=​ ​0​x​f​f​ ​a​n​d​ ​B​y​t​e​
(​a​d​d​r​+​1​)​ ​=​=​ ​0​x​6​3​ ​a​n​d​ ​(​B​y​t​e​(​a​d​d​r​+​2​)​ ​=​=​ ​0​x​1​8​ ​o​r​ ​B​y​t​e​(​a​d​d​r​+​2​)​ ​=​=​ ​0​x​1​C​)​:​
​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​a​d​d​r​ ​=​ ​a​p​p​e​n​d​_​b​y​t​e​s​(​i​n​s​t​r​,​ ​a​d​d​r​)​
​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​b​r​e​a​k​
​ ​ ​ ​ ​ ​ ​ ​i​f​ ​i​n​s​t​r​.​g​e​t​_​c​a​n​o​n​_​m​n​e​m​(​)​ ​=​=​ ​“​j​m​p​”​ ​a​n​d​ ​B​y​t​e​(​a​d​d​r​)​ ​=​=​ ​0​x​f​f​:​
​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​b​r​e​a​k​
​ ​ ​ ​ ​ ​ ​ ​i​f​ ​i​n​s​t​r​.​g​e​t​_​c​a​n​o​n​_​m​n​e​m​(​)​ ​=​=​ ​“​j​z​”​:​
​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​s​i​g​.​a​p​p​e​n​d​(​B​y​t​e​(​a​d​d​r​)​)​
​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​a​d​d​r​ ​+​=​ ​i​n​s​t​r​.​s​i​z​e​
​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​c​o​n​t​i​n​u​e​
​ ​ ​ ​ ​ ​ ​ ​i​f​ ​i​n​s​t​r​.​g​e​t​_​c​a​n​o​n​_​m​n​e​m​(​)​ ​=​=​ ​“​j​n​z​”​:​
​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​s​i​g​.​a​p​p​e​n​d​(​B​y​t​e​(​a​d​d​r​)​)​
​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​a​d​d​r​ ​+​=​ ​i​n​s​t​r​.​s​i​z​e​
​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​c​o​n​t​i​n​u​e​
​ ​ ​ ​ ​ ​ ​ ​i​f​ ​i​n​s​t​r​.​g​e​t​_​c​a​n​o​n​_​m​n​e​m​(​)​ ​=​=​ ​“​n​o​p​”​:​
​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​a​d​d​r​ ​+​=​ ​1​
​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​c​o​n​t​i​n​u​e​
​ ​ ​ ​ ​ ​ ​ ​a​d​d​r​ ​=​ ​a​p​p​e​n​d​_​b​y​t​e​s​(​i​n​s​t​r​,​ ​a​d​d​r​)​
​​​​
​ ​ ​ ​s​i​g​_​s​t​r​ ​=​ ​“​”​.​j​o​i​n​(​[​h​e​x​(​l​)​[​2​:​]​ ​f​o​r​ ​l​ ​i​n​ ​s​i​g​]​)​
​ ​ ​ ​h​s​i​g​ ​=​ ​‘​’​.​j​o​i​n​(​m​a​p​(​c​h​r​,​ ​s​i​g​)​)​.​e​n​c​o​d​e​(​“​h​e​x​”​)​
​​​​
​ ​ ​ ​f​o​r​ ​k​e​y​,​ ​v​a​l​u​e​ ​i​n​ ​S​I​G​S​.​i​t​e​r​i​t​e​m​s​(​)​:​
​ ​ ​ ​ ​ ​ ​ ​i​f​ ​l​e​n​(​k​e​y​)​ ​>​ ​l​e​n​(​s​i​g​_​s​t​r​)​:​
 ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​
i​
f​ ​
k​
e​
y​
.​f​i​
n​
d​
(​
s​
i​
g​
_​
s​
t​
r​
)​ ​
>​
=​ ​
0​
:​
 ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​
m​
a​
k​
eS
​​
i​
gN
​​
a​
m​
e(
​​
v​
a​
l​
u​
e​
,​ ​
f​
a​
d​
d​
r​
)​
​ ​ ​ ​ ​ ​ ​ ​e​l​s​e​:​
 ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​
i​
f​ ​
s​
i​
g​
_​
s​
t​
r​
.​f​i​
n​
d​
(​
k​
e​
y​
)​ ​
>​
=​ ​
0​
:​
 ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​
m​
ak
​​
e​
Si
​​
g​
Na
​​
m​
e(
​​
v​
a​
l​
u​
e​
,​ ​
f​
a​
d​
d​
r​
)​